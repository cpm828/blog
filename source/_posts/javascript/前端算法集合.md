---
title:         前端算法集合 # 标题
description:   前端常见的算法 # 副标题
tags: # 标签分类
    - JavaScript
---


## 不借助临时变量，进行整数量交换
```js
// 利用 + 、- 来进行运算
funtion swap(a, b) {
  b = b - a;
  a = a + b;
  b = a - b;
  return [a， b];
}
module.exports = swap; --> 对应 var s = require('../*.js');
// 或：
export default swap --> 对应 import s from '../*.js'
// 或:
export {swap} --> 对应 import {swap} from '../*.js'
```

## 数组去重
* 方法1
```js
function uniqueArr(arr){
  var newArr = []; //一个新的临时数组
  for(var i = 0; i < arr.length; i++){ //遍历当前数组
    //如果当前数组的第i项已经保存进了临时数组，那么跳过，
    //否则把当前项push到临时数组里面
    if (newArr.indexOf(arr[i]) == -1){ //在新数组中查找原数组的每一项是否存在
      newArr.push(arr[i]); //如果不存在就加到新数组中
    }
  }
  return newArr;
}
```

* 方法2
```js
function uniqueArr(arr) {
  var obj = {}, newArr = []; //n为hash表，r为临时数组
  for(var i = 0; i < arr.length; i++) { //遍历当前数组 , 可改成 for (var i in arr) {
    if (!obj[arr[i]]){ //如果hash表中没有当前项
      obj[arr[i]] = true; //存入hash表
      newArr.push(arr[i]); //把当前数组的当前项push到临时数组里面
    }
  }
  return newArr;
}
```

* 方法3
```js
function uniqueArr(arr) {
  var newArr = [arr[0]]; //结果数组
  for (var i = 1; i < arr.length; i++) { //从第二项开始遍历
    //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
    //那么表示第i项是重复的，忽略掉。否则存入结果数组
    if (arr.indexOf(arr[i]) == i) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```

* 方法4（同时排序）
```js
function uniqueArr(arr){
  arr.sort(); //数组排序
  var newArr = [arr[0]]; //先提取最小的
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] !== newArr[newArr.length-1]) { //将不等于的放在新数组的后面，等于的跳过
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```



## 数组排序
* 数字、英文排序
```js
// 顺序：
function sortArr (arr){
  return arr.sort();
}
// 或：
function sortArr (arr){
  return arr.sort(function (a, b) {
    return a > b
  });
}

// 倒序：
function sortArr (arr){
  return arr.sort(function (a, b) {
    return a < b
  });
}
```

* 中文姓名排序
```js
// 顺序
function sortNameArr (arr) {
  return arr.sort(function (a, b) {
    return b.localeCompare(a, 'zh-Hans-CN')
    })
}

// 倒序
function sortNameArr (arr) {
  return arr.sort(function (a, b) {
    return a.localeCompare(b, 'zh-Hans-CN')
    })
}
```



## 数组乱序
```js
function shuffle(array) {
   for (var i = array.length - 1; i > 0; i--) {
     var j = Math.floor(Math.random() * (i + 1));
     var temp = array[i];
     array[i] = array[j];
     array[j] = temp;
   }
   return array;
 }
```


## Number数组中最大差值
```js
function getMaxProfit (arr) {
  var min = arr[0], max = arr[0];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max - min;
}
```


## 字符串翻转
* 转换成array
```js
function reverseString(str) {
  return str.split('').reverse().join();
}
```

* 反向遍历
```js
function reverseString(str){
    var tmp = '';
    for(var i=str.length-1;i>=0;i--)
        tmp += str[i];
    return tmp
}
```


## 生成指定长度的随机字符串
```js
function randomString(n){
    var str = 'abcdefghijklmnopqrstuvwxyz0123456789';
    var tmp = '';
    for(var i=0;i<n;i++)
        tmp += str.charAt(Math.round(Math.random()*str.length));
    return tmp;
}
```


## 判断回文
```js
// 算法思想：每次判断第一个字符和最后一个字符是否相等，然后取第二个字符到倒数第二个字符之间的字符串递归
function palindrome(str){
    // \W匹配任何非单词字符，即去除非正常字符。等价于“[^A-Za-z0-9_]”。
    var re = /[\W_]/g;
    // 将字符串变成小写字符,并干掉除字母数字外的字符
    var lowRegStr = str.toLowerCase().replace(re,'');
    // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome
    if(lowRegStr.length===0)
        return true;
    // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome
    if(lowRegStr[0]!=lowRegStr[lowRegStr.length-1])
        return false;
    //递归
    return palindrome(lowRegStr.slice(1,lowRegStr.length-1));
}
```


## 二路归并排序
将两个按值有序序列合并成一个按值有序序列
```js
function merge(left, right) {
    var result = [],
        il = 0,
        ir = 0;

    while (il < left.length && ir < right.length) {
        if (left[il] < right[ir]) {
            result.push(left[il++]);
        } else {
            result.push(right[ir++]);
        }
    }
    while(left[il]){
        result.push(left[il++]);
    }
    while(right[ir]){
        result.push(right[ir++]);
    }
    return result;
}
```

## 统计字符串中次数最多的字母
```js
// 算法思想：先遍历，将出现的字符和次数以object的形式输出；再obj遍历，输出次数最多的字符
function findMaxDuplicateChar(str) {
    if(str.length == 1) {
        return str;
    }
    var charObj = {};
    for(var i = 0; i < str.length; i++) {
        if(!charObj[str.charAt(i)]) {
            charObj[str.charAt(i)] = 1;
        } else {
            charObj[str.charAt(i)] += 1;
        }
    }
    console.log('charObj', charObj)
    var maxChar = '',
        maxValue = 1;
    for(var k in charObj) { // k为key, charObj[k]为value
        if(charObj[k] >= maxValue) {
            maxChar = k;
            maxValue = charObj[k];
        }
    }
    return maxChar + '：' + maxValue;
}
```


## 阶乘
1x2x3x4x5...
* 方法1（非递归实现）
```js
function factorialize(num) {
    var result = 1;
    if(num < 0) return -1;
    if(num == 0 || num == 1) return 1;
    while(num>1)
        result *= num--;
    return result;
}
```

* 方法2（递归实现）
```js
function factorialize(num) {
    var result = 1;
    if(num < 0) return -1;
    if(num == 0 || num == 1) return 1;
    if(num > 1){
        return num*factorialize(num-1);
    }
}
```


## 生成斐波那契数列（黄金分割数列）
斐波那契数列: 0、1、1、2、3、5、8、13、21、34，考察递归

* 方法1（强行递归实现）
```js
function getfib(n){
    if(n == 0)
        return 0;
    if(n == 1)
        return 1;
    if(n > 1){
        return getfib(n-1) + getfib(n-2);
    }
}
function fibo(len){
    var fibo = [];
    for(var i=0;i<len;i++)
        fibo.push(getfib(i));
    return fibo;
}
```

* 方法2（简约非递归实现）
```js
function getFibonacci(n) {
    var fibarr = [];
    var i = 0;
    while(i < n) {
        if(i <= 1) {
            fibarr.push(i);
        } else {
            fibarr.push(fibarr[i - 1] + fibarr[i - 2])
        }
        i++;
    }
    return fibarr;
}
```


## 二分查找
查找某个值是否在有序数组中，数组必须是有序的
* 方法1（非递归实现）
```js
function binary_search(arr, key) {
    var low = 0,
        high = arr.length - 1;
    while(low <= high){
        var mid = parseInt((high + low) / 2);
        if(key == arr[mid]){
            return  mid;
        }else if(key > arr[mid]){
            low = mid + 1;
        }else if(key < arr[mid]){
            high = mid - 1;
        }
    }
    return -1;
};
```

* 方法2（递归实现）
```js
function binary_search2(arr, low, high, key) {
    if(low > high)
        return -1;
    var mid = parseInt((low + high)/2);
    if(key == arr[mid])
        return mid;
    else if(key > arr[mid])
        return binary_search2(arr, mid+1, high, key);
    else if(key < arr[mid])
        return binary_search2(arr, low, mid-1, key);
}
```

