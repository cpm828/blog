---
title:         前端算法集合 # 标题
description:   前端常见的算法面试题 # 副标题
date:          2019-03-09 # 建立日期
updated:       2020-02-29 # 更新日期
comments:      true  # 开启评论功能
tags: # 标签分类
    - JavaScript
---


# 使用前介绍
```js
// How to export and import 
module.exports = swap; --> 对应 var s = require('../*.js');
// 或：
export default swap --> 对应 import s from '../*.js'
// 或:
export {swap} --> 对应 import {swap} from '../*.js'
```

# 不借助临时变量，交换整数

## 加减乘除法
注意：如果是浮点数，对于加减乘除法需要注意[浮点数的精度丢失](/javascript/浮点数运算导致精度丢失.html)问题。
```js
// 思想：先求两个数的“和”，再用“和”去减
function swap(a, b) { // 如 [1, 3]
  a = a + b; // a = 1 + 3 = 4
  b = a - b; // b = 4 - 3 = 1
  a = a - b; // a = 4 - 1 = 3
  return [a, b]; // [3, 1]
}

// 思想：先求两个数的“差”，再用“差”去加
function swap(a, b) { // 如 [3, 1]
  a = a - b; // a = 3 - 1 = 2
  b = a + b; // b = 2 + 1 = 3
  a = b - a; // a = 3 - 2 = 1
  return [a, b]; // [1, 3]
}

// 思想：先求两个数的“乘积”，再用“乘积”去除
function swap(a, b) { // 如 [3, 8]
  a = a * b; // a = 3 * 8 = 24
  b = a / b; // b = 24 / 8 = 3
  a = a / b; // a = 24 / 3 = 8
  return [a, b]; // [8, 3]
}

// 思想：先求两个数的“商”，再用“商”去乘
function swap(a, b) { // 如 [8, 3]
  a = a / b; // a = 8 / 3 = 8 / 3
  b = a * b; // b = (8 / 3) * 3 = 8
  a = b / a; // a = 8 / (8 / 3) = 3
  return [a, b]; // [3, 8]
}
```

## 对象法
```js
function swap(a, b) { // 如 [1, 3]
  a = {
    a: b,
    b: a
  }
  b = a.b; // 1
  a = a.a; // 3
  return [a, b]; // [3, 1]
}
```

## 数组法
```js
function swap(a, b) { // 如 [1, 3]
  a = [a, b];
  b = a[0]; // 1
  a = a[1]; // 3
  return [a, b]; // [3, 1]
}

function swap(a, b) { // 如 [1, 3]
  a = [b, b = a][0]; // a = 3, b = 1;
  return [a, b]; // [3 ,1]
}
```

## ES6数组解构法，推荐
```js
function swap(a, b) { // 如 [1, 3]
  [a, b] = [b, a];
  return [a, b];
}
```


# 数组去重
## 方法1（filter，推荐使用）
```js
// filter函数会过滤出满足条件的元素
function uniqueArr(arr){
  var newArr = arr.filter((item, index, self) => { // 三个参数依次是：当前项、索引值、arr对象
    return self.indexOf(item) === index; // 对于重复的元素，只有第一个元素符合条件，后面的都会被过滤掉
  });
  return newArr;
}
```

## 方法2（新数组法）
```js
function uniqueArr(arr){
  var newArr = []; // 一个新的临时数组
  for(var i = 0; i < arr.length; i++){ // 遍历当前数组
    // 如果当前数组的第i项已经保存进了临时数组，那么跳过，
    // 否则把当前项push到临时数组里面
    if (newArr.indexOf(arr[i]) === -1){ // 在新数组中查找原数组的每一项是否存在
      newArr.push(arr[i]); // 如果不存在就加到新数组中
    }
  }
  return newArr;
}
```

## 方法3（hash表法）
```js
function uniqueArr(arr) {
  var obj = {}, newArr = []; // obj为hash表，newArr为临时数组
  for(var i = 0; i < arr.length; i++) { // 遍历当前数组 , 可改成 for (var i in arr) {
    if (!obj[arr[i]]){ // 如果hash表中没有当前项
      obj[arr[i]] = true; // 存入hash表
      newArr.push(arr[i]); // 把当前数组的当前项push到临时数组里面
    }
  }
  return newArr;
}
```

## 方法4
```js
function uniqueArr(arr) {
  var newArr = [arr[0]]; // 结果数组
  for (var i = 1; i < arr.length; i++) { // 从第二项开始遍历
    // 如果当前数组的第i项在当前数组中第一次出现的位置不是i，
    // 那么表示第i项是重复的，忽略掉。否则存入结果数组
    if (arr.indexOf(arr[i]) === i) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```

## 方法5（同时排序）
```js
function uniqueArr(arr){
  arr.sort(); // 数组排序
  var newArr = [arr[0]]; // 先提取最小的
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] !== newArr[newArr.length-1]) { // 将不等于的放在新数组的后面，等于的跳过
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```

## 方法6（set + Array.from）
```js
function uniqueArr(arr) {
  // new Set(arr); // input: [2, 3, 4, 5, 3, 5], output: {2, 3, 4, 5}
  return Array.from(new Set(arr));
}
```

## 方法7（set + ...扩展运算符）
```js
function uniqueArr(arr) {
  // new Set(arr); // input: [2, 3, 4, 5, 3, 5], output: {2, 3, 4, 5}
  return [...new Set(arr)];
}
```

# 数组中含所有不定类型值的去重
## 普通法
```js
function uniqueArr(arr) {
  for(let i = 0, len = arr.length; i < len; i++){
    // 先处理特殊的类型：array、object、null
    if (typeof arr[i] === 'object' || Array.isArray(arr[i]) || ) {

    }
  }
}
```

## map法 
```js
function uniqueArr(arr) {
    var res = [];
    var o = Object.create(null); // 创建一个完全干净的空对象，内部没有__proto__属性
    for(let v of arr) {
        var type = typeof v;
        if(!o[v]) {
            res.push(v);
            o[v] = [type];
        }else if(o[v].indexOf(type) == -1) {
            o[v].push(type);
             res.push(v);
        }
    }
    return res;
}
```



# 取数组中的最大最小值
## 排序法
```js
var arr = [0, 2, 5, 1, 4, 3];

arr.sort(function (a, b) {
  return a - b;
}); // [0, 1, 2, 3, 4, 5]

var min = arr[0];  // 0
var max = arr[arr.length - 1];  // 5
```

## apply方法
```js
Math.max.apply(null, [1, 2, 3, 4]);
Math.min.apply(null, [1, 2, 3, 4]);

// apply()方法
function.apply(thisObj[, argArray]); // 2个参数，参数2为数组

// call()方法
function.call(thisObj[, arg1[, arg2[, [, ...argN]]]]); // 多个参数，其他参数为非数组

// 同理，利用apply方法还可以用于拼接数组：
var arr1 = new Array("1", "2", "3");
var arr2 = new Array("4", "5", "6");
Array.prototype.push.apply(arr1, arr2); // 返回数组长度 6
arr1.push.apply(arr1, arr2); // arr1:["1", "2", "3", "4", "5", "6"]
// 上面的等同于
arr1.push(...arr2); // ES6语法
arr1.concat(arr2); // ES5语法


// 更多apply和call用法见：https://www.cnblogs.com/lengyuehuahun/p/5643625.html
```


# 数组排序
> 参考：[segmentfault【wscats】 十大经典排序算法](https://segmentfault.com/a/1190000010413296)

## 冒泡排序
<img src="../images/javascript/js_bubble_sort.gif" title="冒泡排序原理图" />
1. 比较相邻的元素，如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
5. 实际排序时，由后往前完成排序动作。

```js
function bubbleSort(arr) {
  var len = arr.length;
  for (var i = 0; i < len - 1; i++) {
    for (var j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j+1]) { // 相邻元素两两对比
        // 使用中间变量实现元素交互
        // var temp = arr[j+1];
        // arr[j+1] = arr[j];
        // arr[j] = temp;
        
        // es6数组解构实现元素交互
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
      }
    }
  }
  return arr;
}

// 假设arr是一个数组为5的数组
// i  j
// ----
// 0  0
// 0  1
// 0  2
// 0  3
// ----
// 1  0
// 1  1
// 1  2
// ----
// 2  0
// 2  1
// ----
// 3  0

// 由上面可以看出，取arr[j]和arr[j+1]即是两个相邻元素的比较


// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际冒泡排序如下：
// ① ⑧ 5 4 7 3 9 2 6   // 1与8比较 => 1 8 5 4 7 3 9 2 6
// 1 ⑧ ⑤ 4 7 3 9 2 6   // 8与5比较 => 1 5 8 4 7 3 9 2 6
// 1 5 ⑧ ④ 7 3 9 2 6   // 8与4比较 => 1 5 4 8 7 3 9 2 6
// 1 5 4 ⑧ ⑦ 3 9 2 6   // 8与7比较 => 1 5 4 7 8 3 9 2 6
// 1 5 4 7 ⑧ ③ 9 2 6   // 8与3比较 => 1 5 4 7 3 8 9 2 6
// 1 5 4 7 3 ⑧ ⑨ 2 6   // 8与9比较 => 1 5 4 7 3 8 9 2 6
// 1 5 4 7 3 8 ⑨ ② 6   // 9与2比较 => 1 5 4 7 3 8 2 9 6
// 1 5 4 7 3 8 2 ⑨ ⑥   // 9与6比较 => 1 5 4 7 3 8 2 6 9
// 
// ① ⑤ 4 7 3 8 2 9 6   // 1与5比较 => 1 5 4 7 3 8 2 6 9
// 1 ⑤ ④ 7 3 8 2 6 9   // 5与4比较 => 1 4 5 7 3 8 2 6 9
// 1 4 ⑤ ⑦ 3 8 2 6 9   // 5与7比较 => 1 4 5 7 3 8 2 6 9
// 1 4 5 ⑦ ③ 8 2 6 9   // 7与3比较 => 1 4 5 3 7 8 2 6 9
// 1 4 5 3 ⑦ ⑧ 2 6 9   // 7与8比较 => 1 4 5 3 7 8 2 6 9
// 1 4 5 3 7 ⑧ ② 6 9   // 8与2比较 => 1 4 5 3 7 2 8 6 9
// 1 4 5 3 7 2 ⑧ ⑥ 9   // 8与6比较 => 1 4 5 3 7 2 6 8 9
//
// ① ④ 5 3 7 2 6 8 9   // 1与4比较 => 1 4 5 3 7 2 6 8 9
// 1 ④ ⑤ 3 7 2 6 8 9   // 4与5比较 => 1 4 5 3 7 2 6 8 9
// 1 4 ⑤ ③ 7 2 6 8 9   // 5与3比较 => 1 4 3 5 7 2 6 8 9
// 1 4 3 ⑤ ⑦ 2 6 8 9   // 5与7比较 => 1 4 3 5 7 2 6 8 9
// 1 4 3 5 ⑦ ② 6 8 9   // 7与2比较 => 1 4 3 5 2 7 6 8 9
// 1 4 3 5 2 ⑦ ⑥ 8 9   // 7与6比较 => 1 4 3 5 2 6 7 8 9
// 
// ① ④ 3 5 2 6 7 8 9   // 1与4比较 => 1 4 3 5 2 6 7 8 9
// 1 ④ ③ 5 2 6 7 8 9   // 4与3比较 => 1 3 4 5 2 6 7 8 9
// 1 3 ④ ⑤ 2 6 7 8 9   // 4与5比较 => 1 3 4 5 2 6 7 8 9
// 1 3 4 ⑤ ② 6 7 8 9   // 5与2比较 => 1 3 4 2 5 6 7 8 9
// 1 3 4 2 ⑤ ⑥ 7 8 9   // 5与6比较 => 1 3 4 2 5 6 7 8 9
// 
// ... ...
// 
// ① ② 3 4 5 6 7 8 9   // 1与2比较 => 1 2 3 4 5 6 7 8 9
```

## 选择排序
<img src="../images/javascript/js_select_sort.gif" title="选择排序原理图" />
1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到***已排序序列***的末尾。
3. 重复第二步，直到所有元素均排序完毕。

```js
function selectionSort(arr) {
  var len = arr.length;
  var minIndex, temp;
  for (var i = 0; i < len - 1; i++) { // 此处循环到倒数第二项即可，届时最后一项已经完成排序（最大或最小）
    minIndex = i; // 假设次数最小数的索引为当前i

    for (var j = i + 1; j < len; j++) { // 遍历i之后的数
      if (arr[j] < arr[minIndex]) { // 存在比minIndex还小的数
        minIndex = j;               // 将最小数的索引赋给minIndex
      }
    }
    // 此时minIndex可能等于i（即上面遍历之后不存在更小的），也可能不等于i（存在更小的，即arr[minIndex] < arr[i]）;
    // 但是此时minIndex >= i，所以我们交换arr[i]和arr[minIndex]的位置即可

    // 将 minIndex对应的数 放在当前索引对应的数的前面
    // temp = arr[i];
    // arr[i] = arr[minIndex];
    // arr[minIndex] = temp;

    // es6数组结构实现元素交换
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }
  return arr;
}

// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际选择排序如下：
// ① 8 5 4 7 3 9 2 6   // 1与1交换
// 
// 1 ⑧ 5 4 7 3 9 ② 6  // 8与2交换
// 1 2 5 4 7 3 9 8 6
// 
// 1 2 ⑤ 4 7 ③ 9 8 6  // 5与3交换
// 1 2 3 4 7 5 9 8 6
// 
// 1 2 3 ④ 7 5 9 8 6   // 4与4交换
// 1 2 3 4 7 5 9 8 6
// 
// 1 2 3 4 ⑦ ⑤ 9 8 6  // 7与5交换
// 1 2 3 4 5 7 9 8 6
// 
// 1 2 3 4 5 ⑦ 9 8 ⑥  // 7与6交换
// 1 2 3 4 5 6 9 8 7
// 
// 1 2 3 4 5 6 ⑨ 8 ⑦  // 9与7交换
// 1 2 3 4 5 6 7 8 9
// 
// 1 2 3 4 5 6 7 ⑧ 9   // 8与8交换
// 1 2 3 4 5 6 7 8 9 
```

## 快速排序
<img src="../images/javascript/js_quick_sort.gif" title="快速排序原理图" />
1. 从数列中挑出一个元素，称为 “基准”（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  let leftArr = [];
  let rightArr = [];
  let pivot = arr[0]; // 选择第一项作为基准值
  for (let i = 1; i < arr.length; i++) { // 从1开始遍历，因为0已经作为基准值使用了
    if (arr[i] > pivot) {
      rightArr.push(arr[i]);     
    } else{
      leftArr.push(arr[i]);
    }
  }
  return [].concat(quickSort(leftArr), [q], quickSort(rightArr)); // 拼接左分区、基准值、右分区（进行递归）
}

// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际快速排序如下：
// arr:[1, 8, 5, 4, 7, 3, 9, 2, 6] 
// ├── left: []
// │
// ├── pivot: 1
// │
// └── right:[8, 5, 4, 7, 3, 9, 2, 6]
//     │
//     ├── left: [5, 4, 7, 3, 2, 6]
//     │   │
//     │   ├── left: [4, 3, 2]
//     │   │   │
//     │   │   ├── left: [3, 2]
//     │   │   │   │ 
//     │   │   │   ├── left: [2]
//     │   │   │   │
//     │   │   │   ├── pivot: 3
//     │   │   │   │
//     │   │   │   └── right: []
//     │   │   │    
//     │   │   ├── pivot: 4
//     │   │   │
//     │   │   └── right: []
//     │   │   
//     │   ├── pivot: 5
//     │   │
//     │   └── right: [7, 6]
//     │       │
//     │       ├── left: [6]
//     │       │
//     │       ├── pivot: 7
//     │       │
//     │       └── right: []
//     │ 
//     ├── pivot: 8
//     │
//     └── right: [9]
//     
// 
// 按上图拆分完毕后，从内到外拼接（递归）即可完成排序得到：[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 插入排序

<img src="../images/javascript/js_insert_sort.gif" title="插入排序原理图" />
1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

```js
function insertionSort(arr) {
  var len = arr.length;
  var preIndex, current;
  for (var i = 1; i < len; i++) {
    preIndex = i - 1;
    current = arr[i];
    while(preIndex >= 0 && arr[preIndex] > current) {
      arr[preIndex+1] = arr[preIndex];
      preIndex--;
    }
    arr[preIndex+1] = current;
  }
  return arr;
}
```

## 二路归并排序
将两个按值有序序列合并成一个按值有序序列
<img src="../images/javascript/js_merge_sort.gif" title="二路归并排序原理图" />
```js
function merge(left, right) {
  var result = [],
      il = 0,
      ir = 0;

  while (il < left.length && ir < right.length) {
    if (left[il] < right[ir]) {
      result.push(left[il++]);
    } else {
      result.push(right[ir++]);
    }
  }
  while(left[il]){
    result.push(left[il++]);
  }
  while(right[ir]){
    result.push(right[ir++]);
  }
  return result;
}
```

## 希尔排序
```js
function shellSort(arr) {
  var len = arr.length,
      temp,
      gap = 1;
  while(gap < len/3) {          //动态定义间隔序列
    gap =gap*3+1;
  }
  for (gap; gap > 0; gap = Math.floor(gap/3)) {
    for (var i = gap; i < len; i++) {
      temp = arr[i];
      for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
        arr[j+gap] = arr[j];
      }
      arr[j+gap] = temp;
    }
  }
  return arr;
}
```

## 其他常见应用
### 数字、英文排序
```js
// 顺序：
function sortArr (arr){
  return arr.sort();
}
// 或：
function sortArr (arr){
  return arr.sort(function (a, b) {
    return a > b
  });
}

// 倒序：
function sortArr (arr){
  return arr.sort(function (a, b) {
    return a < b
  });
}
```

### 中文姓名排序
```js
// 顺序
function sortNameArr (arr) {
  return arr.sort(function (a, b) {
    return b.localeCompare(a, 'zh-Hans-CN')
    })
}

// 倒序
function sortNameArr (arr) {
  return arr.sort(function (a, b) {
    return a.localeCompare(b, 'zh-Hans-CN')
    })
}
```



# 数组乱序
## 遍历法
取随机位的值与当前的互换
```js
function shuffle(arr) {
  for (var i = arr.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return array;
 }
```

## sort法
随机数大于0.5的概率为1/2，然后选择顺序或倒序即可
```js
function shuffle(arr) {
  arr.sort((a, b) => {
    var sign = (Math.random() > 0.5) ? 1 : -1;
    return (a - b) * sign;
  });
}
```


# Number数组中最大差值
```js
function getMaxProfit (arr) {
  var min = arr[0], max = arr[0];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max - min;
}
```


# 打印九九乘法表

```js
for (var n = 1; n <= 9; n++) {
  for (var m = 1; m < n+1; m++) {
    var b = m * n;
    document.write(m + "×" + n + "=" + b + " ");
  }
  document.write("<br/><br/>");
}
```


# 求数组交集和差级
ES7方法：
```js
let intersection = a.filter(v => b.includes(v))
 
let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v))
```


# 字符串翻转

## 转换成array
```js
function reverseString(str) {
  return str.split('').reverse().join();
}
```

## 反向遍历
```js
function reverseString(str){
  var tmp = '';
  for(var i = str.length - 1;i >= 0; i--)
    tmp += str[i];
  return tmp
}
```


# 生成随机字符串
```js
function randomString(n){
  var str = 'abcdefghijklmnopqrstuvwxyz0123456789';
  var tmp = '';
  for(var i = 0; i < n; i++)
    tmp += str.charAt(Math.round(Math.random()*str.length));
  return tmp;
}
```


# 判断回文
```js
// 算法思想：每次判断第一个字符和最后一个字符是否相等，然后取第二个字符到倒数第二个字符之间的字符串递归
function palindrome(str){
  // \W匹配任何非单词字符，即去除非正常字符。等价于“[^A-Za-z0-9_]”。
  var re = /[\W_]/g;
  // 将字符串变成小写字符,并干掉除字母数字外的字符
  var lowRegStr = str.toLowerCase().replace(re, '');
  // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome
  if(lowRegStr.length === 0)
    return true;
  // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome
  if(lowRegStr[0] !== lowRegStr[lowRegStr.length - 1])
    return false;
  //递归
  return palindrome(lowRegStr.slice(1, lowRegStr.length - 1));
}
```


# 统计出现最多的元素
最常见的思路是先使用object统计出元素和个数，再循环取最大的，但这样无疑会增加复杂度。所以需要在第一次遍历的时候就缓存好最大的元素。

## 统计字符串中最多的字母和出现的次数
```js
// 算法思想：先遍历，将出现的字符和次数以object的形式输出；再obj遍历，输出次数最多的字符
function findMaxDuplicateChar(str) {
  if(str.length == 1) {
    return str;
  }
  var charObj = {};
  var maxElArr = [str.charAt(0), 0];//  次数最多的元素和次数，默认为第一个
  for(var i = 0; i < str.length; i++) {
    if(!charObj[str.charAt(i)]) {
      charObj[str.charAt(i)] = 1;
    } else {
      charObj[str.charAt(i)] += 1;
      if (charObj[str.charAt(i)] >= maxElArr[1]) {
        maxElArr = [str.charAt(i), charObj[str.charAt(i)]];
      }
    }
  }
  console.log(charObj, maxElArr);
  return maxElArr;
}
```

## 统计数组中出现最多次数的元素和次数
```js
function findMaxDuplicateArr(arr) {
  if(arr.length == 1) {
    return arr[0];
  }

  var obj = {};
  var maxElArr = [arr[0], 0]; //  次数最多的元素和次数，默认为第一个
  for(var i = 0; i < arr.length; i++) {
    if(!obj[arr[i]]) {
      obj[arr[i]] = 1;
    } else {
      obj[arr[i]] += 1;
      if (obj[arr[i]] >= maxElArr[1]) {
        maxElArr = [arr[i], obj[arr[i]]];
      }
    }
  }
  console.log(obj, maxElArr);
  return maxElArr;
}
```


# 阶乘
1x2x3x4x5...
## 递归
```js
function factorialize(num) {
  var result = 1;
  if(num < 0) return -1;
  if(num == 0 || num == 1) return 1;
  if(num > 1){
    return num * factorialize(num - 1);
  }
}
```

## 非递归
```js
function factorialize(num) {
  var result = 1;
  if(num < 0) return -1;
  if(num == 0 || num == 1) return 1;
  while(num > 1)
    result *= num--;
  return result;
}
```




# 生成斐波那契数列
斐波那契数列（黄金分割数列）: 0、1、1、2、3、5、8、13、21、34，考察递归

## 递归
```js
function getfib(n){
  if (n == 0)
    return 0;
  if (n == 1)
    return 1;
  if (n > 1) {
    return getfib(n - 1) + getfib(n - 2);
  }
}
function fibo(len){
  var fibo = [];
  for(var i = 0; i < len; i++)
    fibo.push(getfib(i));
  return fibo;
}
```

## 非递归
```js
function getFibonacci(n) {
  var fibarr = [];
  var i = 0;
  while(i < n) {
    if(i <= 1) {
      fibarr.push(i);
    } else {
      fibarr.push(fibarr[i - 1] + fibarr[i - 2])
    }
    i++;
  }
  return fibarr;
}
```


# 二分查找
查找某个值是否在有序数组中，有则返回索引，数组必须是有序的

注意：
还有一种不传起始和终止下标参数，通过在函数体内使用slice取到新的arr，整体没有这种方法好。
## 递归
```js
function binarySearch(arr, key, start, end) {
  if (start < 0 || end > arr.length || start > end) {
    // throw(Error('error'))
    return -1;
  }

  const mid = parseInt((start + end) / 2);
  if(key == arr[mid]) {
    return mid;
  } else if(key > arr[mid]) {
    return binarySearch(arr, key, mid + 1, end);
  } else if(key < arr[mid]) {
    return binarySearch(arr, key, start, mid - 1);
  }
}
binarySearch([1, 2, 3, 4, 5], 2, 0, 5 - 1);
```

## 非递归
```js
function binaryQuery (arr, key) {
  var start = 0,
    end = arr.length - 1;
  while (start <= end) {
    var mid = parseInt((start + end) / 2)
    if (key === arr[mid]) {
      return mid;
    } else if (key > arr[mid]) {
      start = mid + 1;
    } else if (key < arr[mid]) {
      end = mid - 1;
    }
  }
  return -1;
}
binaryQuery([1, 2, 3, 4, 5, 6], 5)
```



# 找出数组当中的质数
质数：也称素数，>1, 有无限个。除1和它自身之外不能被其他数整除，如2、3、5、7等，否则称为合数。
```js
// 思想：m % n === 0, 等于0表示能整除，即不是质数

// 循环生成一个100内的数组
var i, arr = [];
for (i = 1; i < 100; i++) {
  arr.push(i);
}

var getPrimes = arr.filter((el) => {
  var flag = true; // 定义一个boolean值，filter返回布尔值

  if (el < 2) { // 小于2的直接排除
    flag = false;
  } else {
    // 使用小于当前元素的数值去整除当前当前元素，有一个可以整除则跳出循环
    for (var j = 2; j < el; j++) {
      if (el % j === 0) {
        flag = false;
        break;
      }
    }
  }

  return flag;
});
console.log(getPrimes)
```


# js求1! + 2! + 3! + 4! + 5!(阶乘)
思路：s
转换成 `1! + (2 * 1!) + (3 * 2!) + (4 * 3!) + (5 * 4!) `
```js
var sum = 0, // 总和
  sum2 = 1;

for (var i = 1; i <= 5; i++) {
  sum2 *= i; // 当前第一数
  sum += sum2;
}

console.log(sum)
```




# leetcode算法题
## 两数之和
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
**示例**
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

**解答**
```js
// 常规错误想法
// 原因：未考虑相同位相加，如[3, 2, 4]，会返回[0, 0]，因为相同位的3 + 3已经满足了条件
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    for (var i = 0; i < nums.length; i++) {
        for (var j = 0; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
};



// 正确解法: 双重循环式避开i和j相等的情况
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    for (var i = 0; i < nums.length; i++) {
        for (var j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
};
```

## 无重复字符的最长子串
给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例**
示例 1:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
示例 2:
```js
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
示例 3:
```js
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**解答**
```js
// 暴力法：耗时过长
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    var maxLen = 0;
    for (var i = 0; i < s.length; i++) {
        for (var j = i + 1; j <= s.length; j++) {
            // 通过确定i、j来获取所有的连续的子串，再通过方法查找该子串中是否存在重复的字符
            if (allUnique(s, i, j)) maxLen = Math.max(maxLen, j - i);
        }
    }
    return maxLen;
};
    
/**
 * 检查一个子字符串是否含有重复的字符
 * @param {string} str
 * @param {number} start
 * @param {number} end
 * @return {boolean}
 */
var allUnique = function(str, start, end) {
    var tempStr = '';
    for (var i = start; i < end; i++) {
        // 查看临时字符串中是否已经包含了当前字符
        if (tempStr.includes(str.charAt(i))) return false;
        tempStr += str.charAt(i); // 不包含则存储
    }
    return true;
}
```


## 整数反转
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
**示例**
示例 1:
```
输入: 123
输出: 321
```

示例 2:
```
输入: -123
输出: -321
```

示例 3:
```
输入: 120
输出: 21
```
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

**解答**
```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    let sum = 0, // 翻转后的
        num = Math.abs(x); // 取绝对值
    
    // 核心
    while(num) {
        sum = sum * 10 + num % 10;
        num = parseInt(num / 10);
    }

    // 核心代码壳可改成：借助数组reverse方法直接翻转
    // sum = parseInt(String(num).split('').reverse().join(''));
    
    sum = x > 0 ? sum : -sum; // 补上原先的正负符号
    
    // 判断溢出情况
    if (sum > Math.pow(2, 31) || sum < -Math.pow(2, 31)) {
        return 0;
    }
    
    return sum;
};
```
