---
title:         前端算法集合 # 标题
description:   前端常见的算法面试题 # 副标题
tags: # 标签分类
    - JavaScript
---


# 使用前介绍
```js
// How to export and import 
module.exports = swap; --> 对应 var s = require('../*.js');
// 或：
export default swap --> 对应 import s from '../*.js'
// 或:
export {swap} --> 对应 import {swap} from '../*.js'
```

# 不借助临时变量，交换整数

## 加减乘除法
注意：如果是浮点数，对于加减乘除法需要注意[浮点数的精度丢失](/javascript/浮点数运算导致精度丢失.html)问题。
```js
// 思想：先求两个数的“和”，再用“和”去减
function swap(a, b) { // 如 [1, 3]
  a = a + b; // a = 1 + 3 = 4
  b = a - b; // b = 4 - 3 = 1
  a = a - b; // a = 4 - 1 = 3
  return [a, b]; // [3, 1]
}

// 思想：先求两个数的“差”，再用“差”去加
function swap(a, b) { // 如 [3, 1]
  a = a - b; // a = 3 - 1 = 2
  b = a + b; // b = 2 + 1 = 3
  a = b - a; // a = 3 - 2 = 1
  return [a, b]; // [1, 3]
}

// 思想：先求两个数的“乘积”，再用“乘积”去除
function swap(a, b) { // 如 [3, 8]
  a = a * b; // a = 3 * 8 = 24
  b = a / b; // b = 24 / 8 = 3
  a = a / b; // a = 24 / 3 = 8
  return [a, b]; // [8, 3]
}

// 思想：先求两个数的“商”，再用“商”去乘
function swap(a, b) { // 如 [8, 3]
  a = a / b; // a = 8 / 3 = 8 / 3
  b = a * b; // b = (8 / 3) * 3 = 8
  a = b / a; // a = 8 / (8 / 3) = 3
  return [a, b]; // [3, 8]
}
```

## 对象法
```js
function swap(a, b) { // 如 [1, 3]
  a = {
    a: b,
    b: a
  }
  b = a.b; // 1
  a = a.a; // 3
  return [a, b]; // [3, 1]
}
```

## 数组法
```js
function swap(a, b) { // 如 [1, 3]
  a = [a, b];
  b = a[0]; // 1
  a = a[1]; // 3
  return [a, b]; // [3, 1]
}

function swap(a, b) { // 如 [1, 3]
  a = [b, b = a][0]; // a = 3, b = 1;
  return [a, b]; // [3 ,1]
}
```

## ES6数组解构法，推荐
```js
function swap(a, b) { // 如 [1, 3]
  [a, b] = [b, a];
  return [a, b];
}
```


# 数组去重
## 方法1（filter，推荐使用）
```js
// filter函数会过滤出满足条件的元素
function uniqueArr(arr){
  var newArr = arr.filter((item, index, self) => { // 三个参数依次是：当前项、索引值、arr对象
    return self.indexOf(item) === index; // 对于重复的元素，只有第一个元素符合条件，后面的都会被过滤掉
  });
  return newArr;
}
```

## 方法2（新数组法）
```js
function uniqueArr(arr){
  var newArr = []; // 一个新的临时数组
  for(var i = 0; i < arr.length; i++){ // 遍历当前数组
    // 如果当前数组的第i项已经保存进了临时数组，那么跳过，
    // 否则把当前项push到临时数组里面
    if (newArr.indexOf(arr[i]) === -1){ // 在新数组中查找原数组的每一项是否存在
      newArr.push(arr[i]); // 如果不存在就加到新数组中
    }
  }
  return newArr;
}
```

## 方法3（hash表法）
```js
function uniqueArr(arr) {
  var obj = {}, newArr = []; // obj为hash表，newArr为临时数组
  for(var i = 0; i < arr.length; i++) { // 遍历当前数组 , 可改成 for (var i in arr) {
    if (!obj[arr[i]]){ // 如果hash表中没有当前项
      obj[arr[i]] = true; // 存入hash表
      newArr.push(arr[i]); // 把当前数组的当前项push到临时数组里面
    }
  }
  return newArr;
}
```

## 方法4
```js
function uniqueArr(arr) {
  var newArr = [arr[0]]; // 结果数组
  for (var i = 1; i < arr.length; i++) { // 从第二项开始遍历
    // 如果当前数组的第i项在当前数组中第一次出现的位置不是i，
    // 那么表示第i项是重复的，忽略掉。否则存入结果数组
    if (arr.indexOf(arr[i]) === i) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```

## 方法5（同时排序）
```js
function uniqueArr(arr){
  arr.sort(); // 数组排序
  var newArr = [arr[0]]; // 先提取最小的
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] !== newArr[newArr.length-1]) { // 将不等于的放在新数组的后面，等于的跳过
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
```


# 取数组中的最大最小值
## 排序法
```js
var arr = [0, 2, 5, 1, 4, 3];

arr.sort(function (a, b) {
  return a - b;
}); // [0, 1, 2, 3, 4, 5]

var min = arr[0];  // 0
var max = arr[arr.length - 1];  // 5
```

## apply方法
```js
Math.max.apply(null, [1, 2, 3, 4]);
Math.min.apply(null, [1, 2, 3, 4]);

// apply()方法
function.apply(thisObj[, argArray]); // 2个参数，参数2为数组

// call()方法
function.call(thisObj[, arg1[, arg2[, [, ...argN]]]]); // 多个参数，其他参数为非数组

// 同理，利用apply方法还可以用于拼接数组：
var arr1 = new Array("1", "2", "3");
var arr2 = new Array("4", "5", "6");
Array.prototype.push.apply(arr1, arr2); // 返回数组长度 6
arr1.push.apply(arr1, arr2); // arr1:["1", "2", "3", "4", "5", "6"]
// 上面的等同于
arr1.push(...arr2); // ES6语法
arr1.concat(arr2); // ES5语法


// 更多apply和call用法见：https://www.cnblogs.com/lengyuehuahun/p/5643625.html
```


# 数组排序
[segmentfault【wscats】 十大经典排序算法](https://segmentfault.com/a/1190000010413296)
## 冒泡排序
<img src="../images/javascript/js_bubble_sort.gif" title="冒泡排序原理图" />
1. 比较相邻的元素，如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
5. 实际排序时，由后往前完成排序动作。

```js
function bubbleSort(arr) {
  var len = arr.length;
  for (var i = 0; i < len - 1; i++) {
    for (var j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j+1]) { // 相邻元素两两对比
        // 使用中间变量实现元素交互
        // var temp = arr[j+1];
        // arr[j+1] = arr[j];
        // arr[j] = temp;
        
        // es6数组解构实现元素交互
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
      }
    }
  }
  return arr;
}

// 假设arr是一个数组为5的数组
// i  j
// ----
// 0  0
// 0  1
// 0  2
// 0  3
// ----
// 1  0
// 1  1
// 1  2
// ----
// 2  0
// 2  1
// ----
// 3  0

// 由上面可以看出，取arr[j]和arr[j+1]即是两个相邻元素的比较


// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际冒泡排序如下：
// ① ⑧ 5 4 7 3 9 2 6   // 1与8比较 => 1 8 5 4 7 3 9 2 6
// 1 ⑧ ⑤ 4 7 3 9 2 6   // 8与5比较 => 1 5 8 4 7 3 9 2 6
// 1 5 ⑧ ④ 7 3 9 2 6   // 8与4比较 => 1 5 4 8 7 3 9 2 6
// 1 5 4 ⑧ ⑦ 3 9 2 6   // 8与7比较 => 1 5 4 7 8 3 9 2 6
// 1 5 4 7 ⑧ ③ 9 2 6   // 8与3比较 => 1 5 4 7 3 8 9 2 6
// 1 5 4 7 3 ⑧ ⑨ 2 6   // 8与9比较 => 1 5 4 7 3 8 9 2 6
// 1 5 4 7 3 8 ⑨ ② 6   // 9与2比较 => 1 5 4 7 3 8 2 9 6
// 1 5 4 7 3 8 2 ⑨ ⑥   // 9与6比较 => 1 5 4 7 3 8 2 6 9
// 
// ① ⑤ 4 7 3 8 2 9 6   // 1与5比较 => 1 5 4 7 3 8 2 6 9
// 1 ⑤ ④ 7 3 8 2 6 9   // 5与4比较 => 1 4 5 7 3 8 2 6 9
// 1 4 ⑤ ⑦ 3 8 2 6 9   // 5与7比较 => 1 4 5 7 3 8 2 6 9
// 1 4 5 ⑦ ③ 8 2 6 9   // 7与3比较 => 1 4 5 3 7 8 2 6 9
// 1 4 5 3 ⑦ ⑧ 2 6 9   // 7与8比较 => 1 4 5 3 7 8 2 6 9
// 1 4 5 3 7 ⑧ ② 6 9   // 8与2比较 => 1 4 5 3 7 2 8 6 9
// 1 4 5 3 7 2 ⑧ ⑥ 9   // 8与6比较 => 1 4 5 3 7 2 6 8 9
//
// ① ④ 5 3 7 2 6 8 9   // 1与4比较 => 1 4 5 3 7 2 6 8 9
// 1 ④ ⑤ 3 7 2 6 8 9   // 4与5比较 => 1 4 5 3 7 2 6 8 9
// 1 4 ⑤ ③ 7 2 6 8 9   // 5与3比较 => 1 4 3 5 7 2 6 8 9
// 1 4 3 ⑤ ⑦ 2 6 8 9   // 5与7比较 => 1 4 3 5 7 2 6 8 9
// 1 4 3 5 ⑦ ② 6 8 9   // 7与2比较 => 1 4 3 5 2 7 6 8 9
// 1 4 3 5 2 ⑦ ⑥ 8 9   // 7与6比较 => 1 4 3 5 2 6 7 8 9
// 
// ① ④ 3 5 2 6 7 8 9   // 1与4比较 => 1 4 3 5 2 6 7 8 9
// 1 ④ ③ 5 2 6 7 8 9   // 4与3比较 => 1 3 4 5 2 6 7 8 9
// 1 3 ④ ⑤ 2 6 7 8 9   // 4与5比较 => 1 3 4 5 2 6 7 8 9
// 1 3 4 ⑤ ② 6 7 8 9   // 5与2比较 => 1 3 4 2 5 6 7 8 9
// 1 3 4 2 ⑤ ⑥ 7 8 9   // 5与6比较 => 1 3 4 2 5 6 7 8 9
// 
// ... ...
// 
// ① ② 3 4 5 6 7 8 9   // 1与2比较 => 1 2 3 4 5 6 7 8 9
```

## 选择排序
<img src="../images/javascript/js_select_sort.gif" title="选择排序原理图" />
1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到***已排序序列***的末尾。
3. 重复第二步，直到所有元素均排序完毕。

```js
function selectionSort(arr) {
  var len = arr.length;
  var minIndex, temp;
  for (var i = 0; i < len - 1; i++) { // 此处循环到倒数第二项即可，届时最后一项已经完成排序（最大或最小）
    minIndex = i; // 假设次数最小数的索引为当前i

    for (var j = i + 1; j < len; j++) { // 遍历i之后的数
      if (arr[j] < arr[minIndex]) { // 存在比minIndex还小的数
        minIndex = j;               // 将最小数的索引赋给minIndex
      }
    }
    // 此时minIndex可能等于i（即上面遍历之后不存在更小的），也可能不等于i（存在更小的，即arr[minIndex] < arr[i]）;
    // 但是此时minIndex >= i，所以我们交换arr[i]和arr[minIndex]的位置即可

    // 将 minIndex对应的数 放在当前索引对应的数的前面
    // temp = arr[i];
    // arr[i] = arr[minIndex];
    // arr[minIndex] = temp;

    // es6数组结构实现元素交换
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }
  return arr;
}

// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际选择排序如下：
// ① 8 5 4 7 3 9 2 6   // 1与1交换
// 
// 1 ⑧ 5 4 7 3 9 ② 6  // 8与2交换
// 1 2 5 4 7 3 9 8 6
// 
// 1 2 ⑤ 4 7 ③ 9 8 6  // 5与3交换
// 1 2 3 4 7 5 9 8 6
// 
// 1 2 3 ④ 7 5 9 8 6   // 4与4交换
// 1 2 3 4 7 5 9 8 6
// 
// 1 2 3 4 ⑦ ⑤ 9 8 6  // 7与5交换
// 1 2 3 4 5 7 9 8 6
// 
// 1 2 3 4 5 ⑦ 9 8 ⑥  // 7与6交换
// 1 2 3 4 5 6 9 8 7
// 
// 1 2 3 4 5 6 ⑨ 8 ⑦  // 9与7交换
// 1 2 3 4 5 6 7 8 9
// 
// 1 2 3 4 5 6 7 ⑧ 9   // 8与8交换
// 1 2 3 4 5 6 7 8 9 
```

## 快速排序
<img src="../images/javascript/js_quick_sort.gif" title="快速排序原理图" />
1. 从数列中挑出一个元素，称为 “基准”（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  let leftArr = [];
  let rightArr = [];
  let pivot = arr[0]; // 选择第一项作为基准值
  for (let i = 1; i < arr.length; i++) { // 从1开始遍历，因为0已经作为基准值使用了
    if (arr[i] > pivot) {
      rightArr.push(arr[i]);     
    } else{
      leftArr.push(arr[i]);
    }
  }
  return [].concat(quickSort(leftArr), [q], quickSort(rightArr)); // 拼接左分区、基准值、右分区（进行递归）
}

// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际快速排序如下：
// arr:[1, 8, 5, 4, 7, 3, 9, 2, 6] 
// ├── left: []
// │
// ├── pivot: 1
// │
// └── right:[8, 5, 4, 7, 3, 9, 2, 6]
//     │
//     ├── left: [5, 4, 7, 3, 2, 6]
//     │   │
//     │   ├── left: [4, 3, 2]
//     │   │   │
//     │   │   ├── left: [3, 2]
//     │   │   │   │ 
//     │   │   │   ├── left: [2]
//     │   │   │   │
//     │   │   │   ├── pivot: 3
//     │   │   │   │
//     │   │   │   └── right: []
//     │   │   │    
//     │   │   ├── pivot: 4
//     │   │   │
//     │   │   └── right: []
//     │   │   
//     │   ├── pivot: 5
//     │   │
//     │   └── right: [7, 6]
//     │       │
//     │       ├── left: [6]
//     │       │
//     │       ├── pivot: 7
//     │       │
//     │       └── right: []
//     │ 
//     ├── pivot: 8
//     │
//     └── right: [9]
//     
// 
// 按上图拆分完毕后，从内到外拼接（递归）即可完成排序得到：[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 插入排序
<img src="../images/javascript/js_insert_sort.gif" title="插入排序原理图" />
1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
```js
function insertionSort(arr) {
  var len = arr.length;
  var preIndex, current;
  for (var i = 1; i < len; i++) {
    preIndex = i - 1;
    current = arr[i];
    while(preIndex >= 0 && arr[preIndex] > current) {
      arr[preIndex+1] = arr[preIndex];
      preIndex--;
    }
    arr[preIndex+1] = current;
  }
  return arr;
}
```

## 二路归并排序
将两个按值有序序列合并成一个按值有序序列
<img src="../images/javascript/js_merge_sort.gif" title="二路归并排序原理图" />
```js
function merge(left, right) {
  var result = [],
      il = 0,
      ir = 0;

  while (il < left.length && ir < right.length) {
    if (left[il] < right[ir]) {
      result.push(left[il++]);
    } else {
      result.push(right[ir++]);
    }
  }
  while(left[il]){
    result.push(left[il++]);
  }
  while(right[ir]){
    result.push(right[ir++]);
  }
  return result;
}
```

## 希尔排序
```js
function shellSort(arr) {
  var len = arr.length,
      temp,
      gap = 1;
  while(gap < len/3) {          //动态定义间隔序列
    gap =gap*3+1;
  }
  for (gap; gap > 0; gap = Math.floor(gap/3)) {
    for (var i = gap; i < len; i++) {
      temp = arr[i];
      for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
        arr[j+gap] = arr[j];
      }
      arr[j+gap] = temp;
    }
  }
  return arr;
}
```

## 其他常见应用
### 数字、英文排序
```js
// 顺序：
function sortArr (arr){
  return arr.sort();
}
// 或：
function sortArr (arr){
  return arr.sort(function (a, b) {
    return a > b
  });
}

// 倒序：
function sortArr (arr){
  return arr.sort(function (a, b) {
    return a < b
  });
}
```

### 中文姓名排序
```js
// 顺序
function sortNameArr (arr) {
  return arr.sort(function (a, b) {
    return b.localeCompare(a, 'zh-Hans-CN')
    })
}

// 倒序
function sortNameArr (arr) {
  return arr.sort(function (a, b) {
    return a.localeCompare(b, 'zh-Hans-CN')
    })
}
```



# 数组乱序
```js
function shuffle(array) {
   for (var i = array.length - 1; i > 0; i--) {
     var j = Math.floor(Math.random() * (i + 1));
     var temp = array[i];
     array[i] = array[j];
     array[j] = temp;
   }
   return array;
 }
```


# Number数组中最大差值
```js
function getMaxProfit (arr) {
  var min = arr[0], max = arr[0];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max - min;
}
```


# 打印九九乘法表
```js
for (var n = 1; n <= 9; n++) {
  for (var m = 1; m < n+1; m++) {
    var b = m * n;
    document.write(m + "×" + n + "=" + b + " ");
  }
  document.write("<br/><br/>");
}
```


# 求数组交集和差级
ES7方法：
```js
let intersection = a.filter(v => b.includes(v))
 
let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v))
```


# 字符串翻转
## 转换成array
```js
function reverseString(str) {
  return str.split('').reverse().join();
}
```

## 反向遍历
```js
function reverseString(str){
  var tmp = '';
  for(var i = str.length - 1;i >= 0; i--)
    tmp += str[i];
  return tmp
}
```


# 生成随机字符串
```js
function randomString(n){
  var str = 'abcdefghijklmnopqrstuvwxyz0123456789';
  var tmp = '';
  for(var i = 0; i < n; i++)
    tmp += str.charAt(Math.round(Math.random()*str.length));
  return tmp;
}
```


# 判断回文
```js
// 算法思想：每次判断第一个字符和最后一个字符是否相等，然后取第二个字符到倒数第二个字符之间的字符串递归
function palindrome(str){
  // \W匹配任何非单词字符，即去除非正常字符。等价于“[^A-Za-z0-9_]”。
  var re = /[\W_]/g;
  // 将字符串变成小写字符,并干掉除字母数字外的字符
  var lowRegStr = str.toLowerCase().replace(re, '');
  // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome
  if(lowRegStr.length === 0)
    return true;
  // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome
  if(lowRegStr[0] !== lowRegStr[lowRegStr.length - 1])
    return false;
  //递归
  return palindrome(lowRegStr.slice(1, lowRegStr.length - 1));
}
```



# 统计字符串中最多的字母
```js
// 算法思想：先遍历，将出现的字符和次数以object的形式输出；再obj遍历，输出次数最多的字符
function findMaxDuplicateChar(str) {
  if(str.length == 1) {
    return str;
  }
  var charObj = {};
  for(var i = 0; i < str.length; i++) {
    if(!charObj[str.charAt(i)]) {
      charObj[str.charAt(i)] = 1;
    } else {
      charObj[str.charAt(i)] += 1;
    }
  }
  console.log('charObj', charObj)
  var maxChar = '',
      maxValue = 1;
  for(var k in charObj) { // k为key, charObj[k]为value
    if(charObj[k] >= maxValue) {
      maxChar = k;
      maxValue = charObj[k];
    }
  }
  return maxChar + '：' + maxValue;
}
```


# 阶乘
1x2x3x4x5...
## 递归
```js
function factorialize(num) {
  var result = 1;
  if(num < 0) return -1;
  if(num == 0 || num == 1) return 1;
  if(num > 1){
    return num * factorialize(num - 1);
  }
}
```

## 非递归
```js
function factorialize(num) {
  var result = 1;
  if(num < 0) return -1;
  if(num == 0 || num == 1) return 1;
  while(num > 1)
    result *= num--;
  return result;
}
```




# 生成斐波那契数列
斐波那契数列（黄金分割数列）: 0、1、1、2、3、5、8、13、21、34，考察递归

## 递归
```js
function getfib(n){
  if (n == 0)
    return 0;
  if (n == 1)
    return 1;
  if (n > 1) {
    return getfib(n - 1) + getfib(n - 2);
  }
}
function fibo(len){
  var fibo = [];
  for(var i = 0; i < len; i++)
    fibo.push(getfib(i));
  return fibo;
}
```

## 非递归
```js
function getFibonacci(n) {
  var fibarr = [];
  var i = 0;
  while(i < n) {
    if(i <= 1) {
      fibarr.push(i);
    } else {
      fibarr.push(fibarr[i - 1] + fibarr[i - 2])
    }
    i++;
  }
  return fibarr;
}
```


# 二分查找
查找某个值是否在有序数组中，数组必须是有序的
## 递归
```js
function binary_search2(arr, low, high, key) {
  if(low > high)
    return -1;
  var mid = parseInt((low + high)/2);
  if(key == arr[mid])
    return mid;
  else if(key > arr[mid])
    return binary_search2(arr, mid+1, high, key);
  else if(key < arr[mid])
    return binary_search2(arr, low, mid-1, key);
}
```

## 非递归
```js
function binary_search(arr, key) {
  var low = 0,
      high = arr.length - 1;
  while(low <= high){
    var mid = parseInt((high + low) / 2);
    if (key == arr[mid]) {
      return  mid;
    } else if(key > arr[mid]) {
      low = mid + 1;
    } else if(key < arr[mid]) {
      high = mid - 1;
    }
  }
  return -1;
};
```



# 找出数组当中的质数
质数：也称素数，>1, 有无限个。除1和它自身之外不能被其他数整除，如2、3、5、7等，否则称为合数。
```js
// 思想：m % n === 0, 等于0表示能整除，即不是质数

// 循环生成一个100内的数组
var i, arr = [];
for (i = 1; i < 100; i++) {
  arr.push(i);
}

var getPrimes = arr.filter((el) => {
  var flag = true; // 定义一个boolean值，filter返回布尔值

  if (el < 2) { // 小于2的直接排除
    flag = false;
  } else {
    // 使用小于当前元素的数值去整除当前当前元素，有一个可以整除则跳出循环
    for (var j = 2; j < el; j++) {
      if (el % j === 0) {
        flag = false;
        break;
      }
    }
  }

  return flag;
});
console.log(getPrimes)
```

