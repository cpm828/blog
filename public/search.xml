<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux安装node环境]]></title>
    <url>%2Flinux%2Flinux%E5%AE%89%E8%A3%85node%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[1 安装1wget https://nodejs.org/dist/v8.11.3/node-v8.11.3-linux-x64.tar.xz # 二进制地址（from node website） 2 解压123xz -d node-v8.11.3-linux-x64.tar.xztar -xvf node-v8.11.3-linux-x64.tar 3 重命名1mv node-v8.11.3-linux-x64 node 4 创建软链接1234567891011ln -s /usr/local/node/bin/node /usr/bin/nodenode --versionln -s /usr/local/node/bin/npm /usr/bin/npmnpm --versionln -s /usr/local/node/bin/npx /usr/bin/npxnpx --version]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js执行机制]]></title>
    <url>%2Fjavascript%2Fjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[抛出问题，输出下列程序：1234567891011121314setTimeout(function()&#123; console.log(&apos;定时器开始啦&apos;)&#125;);new Promise(function(resolve)&#123; console.log(&apos;马上执行for循环啦&apos;); for(var i = 0; i &lt; 10000; i++)&#123; i == 99 &amp;&amp; resolve(); &#125;&#125;).then(function()&#123; console.log(&apos;执行then函数啦&apos;)&#125;);console.log(&apos;代码执行结束&apos;); 1234马上执行for循环啦代码执行结束执行then函数啦定时器开始啦 内部执行机制查看掘金 ssssyoki]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery封装插件]]></title>
    <url>%2Fjquery%2Fjquery%E5%B0%81%E8%A3%85%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[使用jQuery封装插件，此处我们只讲jquery的导入方法，不去理会import和export的导入导出，常见的如下： 通用方法封装 封装plugin1 1234567891011121314151617181920212223242526272829303132333435363738394041424344(function(root)&#123; var YQ = &#123;&#125;; // 设置cookie YQ.setCookie = function(name, value, day)&#123; var Days = day || 1; var exp = new Date(); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString(); &#125;; // 获取cookie YQ.getCookie = function(name)&#123; var arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)"); if(arr=document.cookie.match(reg)) return unescape(arr[2]); else return null; &#125;; // 获取链接参数 YQ.getQuery = function(item)&#123; var svalue = location.search.match(new RegExp('[\?\&amp;]' + item + '=([^\&amp;]*)(\&amp;?)', 'i')); return svalue ? decodeURIComponent(svalue[1]) : ''; &#125;; if(typeof root === "undefined")&#123; root = &#123;&#125;; &#125; if(typeof root['YQ'] === 'undefined')&#123; root.YQ = YQ; &#125;else&#123; YQ.extend(root.YQ, YQ); &#125; if(typeof define === 'function' &amp;&amp; define.amd)&#123; define([], function () &#123; 'use strict'; return root.YQ; &#125;); &#125;else if(typeof module !== 'undefined')&#123; module.exports = root.YQ; &#125;&#125;(window)); 导入plugin1 1&lt;script src="lib/plugin1.js"&gt;&lt;/script&gt; 使用plugin1 123// 导入之后，可以直接使用YQ当中的任何方法YQ.getQuery('a'); 常见的插件封装一般封装 封装plugin2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 封装插件demo */// 自调用匿名函数包裹（块级作用域）// 前面的;符号 的作用：分割代码，防止代码再合并压缩时出错;(function() &#123; /* * @param el: dom 元素 * @param opt: 传入的配置项参数 */ var testObj = function (el, opt) &#123; this.$element = el; this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration': 'none' &#125;; this.options = $.extend(&#123;&#125;, this.defaults, opt); // 拼接传入参数和默认参数 &#125;; // 定义方法 testObj.prototype = &#123; changeClass: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125;, methodA: function () &#123; // *** &#125;, methodB: function () &#123; // *** &#125;, &#125;; // 调用方法 $.fn.myPlugin2 = function (options) &#123; // 创建实体 var testIndividual = new testObj(this, options); // 调用方法 return testIndividual.changeClass(); &#125;;&#125;)(); 导入plugin2 123&lt;a href="#" id="testDom2"&gt;plugin2&lt;/a&gt;&lt;script src="lib/plugin2.js"&gt;&lt;/script&gt; 使用plugin2 1234$('#testDom2').myPlugin2(&#123; 'color': 'blue', 'fontSize': '20px'&#125;); 使用$.fn.a使用$.fn.a(a表示方法名)逐一封装方法，可以写多个 封装plugin3.js 1234567891011121314151617;(function() &#123; $.fn.myPlugin3 = function (opt) &#123; var defaults = &#123; Event: 'click', msg: 'Hello World' &#125;; var options = $.extend(defaults, opt); // var $this = $(this); var $this = this; // fn中的this已经是个jquery对象，无需使用$(this)来获取 // 绑定事件 $this.on(options.Event, function(e) &#123; alert(options.msg); &#125;); &#125;&#125;)(); 导入plugin3 123&lt;button id="testDom3"&gt;plugin3&lt;/button&gt;&lt;script src="lib/plugin3.js"&gt;&lt;/script&gt; 使用plugin3 1234$('#testDom3').myPlugin3(&#123; Event: 'click', msg: '12112'&#125;); 使用$.fn.extend使用$.fn.extend可以同时注册多个方法 封装plugin4 1234567891011121314;(function() &#123; $.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;, uncheck: function() &#123; return this.each(function() &#123; this.checked = false; &#125;); &#125; &#125;);&#125;)(); 导入plugin4 1&lt;script src="lib/plugin4.js"&gt;&lt;/script&gt; 导入plugin4 123$("input[type='checkbox']" ).check();$("input[type='checkbox']" ).uncheck(); 使用$.fn.a传参（方法名）使用$.fn.a传参来注册多个方法 封装plugin5 123456789101112131415161718192021222324252627282930313233343536373839404142(function($) &#123; // $.fn.tooltip = function (options) &#123; // this // &#125;; // $.fn.tooltipShow = function () &#123; // is // &#125;; // $.fn.tooltipHide = function () &#123; // bad // &#125;; // $.fn.tooltipUpdate = function (content) &#123; // !!! // &#125; // 上面的方式是不被鼓励的写法，会使$.fn命名空间混乱，可以收集所有方法，通过传参来调用它们 var methods = &#123; init: function (options) &#123; &#125;, show: function () &#123; &#125;, hide: function () &#123; &#125;, update: function (content) &#123; &#125; &#125;; $.fn.tooltip = function(methods) &#123; if (methods[method]) &#123; return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); &#125; else if (typeof method === 'object' || !method) &#123; return methods.init.apply(this, arguments); &#125; else &#123; $.error('Method' + method + 'does not exist on jQuery.tooltip'); &#125; &#125;&#125;)(jQuery); 导入plugin5 1&lt;script src="lib/plugin5.js"&gt;&lt;/script&gt; 使用plugin5 12345678910111213// 调用init方法（无参数）:$('div').tooltip();// 调用init方法（带参数）:$('div').tooltip(&#123; foo: 'bar'&#125;);// 调用hide方法:$('div').tooltip('hide');// 调用update方法:$('div').tooltip('update', '****');]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows系统端口占用解决办法]]></title>
    <url>%2Ftools%2Fwindows%E7%94%B5%E8%84%91%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[123456781、查看端口对应的PID（最后一项） netstat -ano |findstr &quot;8081&quot;2、查看PID对应的应用程序 tasklist |findstr &quot;PID&quot;3、杀掉该应用程序的进程 taskkill /f /t /im &quot;java.exe&quot; 注：必须使用window的 cmd 窗口来运行程序，某些应用的内置终端无法运行]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态插入link标签]]></title>
    <url>%2Fjavascript%2Fjs%E5%8A%A8%E6%80%81%E6%8F%92%E5%85%A5css%E6%A0%B7%E5%BC%8F%E6%A0%87%E7%AD%BE.html</url>
    <content type="text"><![CDATA[12345678var includeCss = function(url) &#123; var link = document.createElement("link"); link.rel = "stylesheet"; link.type = "text/css"; link.href = url; document.getElementsByTagName("head")[0].appendChild(link)&#125;;includeCss("./css/Mdate.css");]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断字符串是否是时间格式]]></title>
    <url>%2Fjavascript%2Fjs%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F.html</url>
    <content type="text"><![CDATA[1234567891011121314151617const isDateString = (sDate) =&gt; &#123; const mp = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/, matchArray = sDate.match(mp); if (matchArray === null) return false; const iaMonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; let iaDate = new Array(3); iaDate = sDate.split('-'); const year = parseFloat(iaDate[0]), month = parseFloat(iaDate[1]), day = parseFloat(iaDate[2]); if (year &lt; 1900 || year &gt; 2100) return false; if (((year % 4 === 0) &amp;&amp; (year % 100 !== 0)) || (year % 400 === 0)) iaMonthDays[1] = 29; if (month &lt; 1 || month &gt; 12) return false; if (day &lt; 1 || day &gt; iaMonthDays[month - 1]) return false; return true;&#125;;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas将图片和文本合成图片]]></title>
    <url>%2Fjavascript%2Fcanvas%E5%90%88%E6%88%90%E5%9B%BE%E7%89%87%E5%92%8C%E6%96%87%E6%9C%AC.html</url>
    <content type="text"><![CDATA[需求为：将一张图片和用户输入的文字（居中显示，且超出指定宽度显示…）合成一张新的图片 12345&lt;canvas id="posterCanvas" width="240" height="180"&gt;&lt;/canvas&gt;&lt;hr&gt;用户输入的文本：&lt;input type="text" id="inputText"&gt;&lt;button id="convertBtn"&gt;合成图片&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940window.onload = function () &#123; var convertBtn = document.getElementById('convertBtn'); convertBtn.onclick = function () &#123; drawCanvasDefaultPoster(); &#125; function drawCanvasDefaultPoster() &#123; var inputText = document.getElementById('inputText'), posterCanvas = document.getElementById('posterCanvas'), posterContext = posterCanvas.getContext('2d'), posterCanvasWidth = posterCanvas.width, posterCanvasHeight = posterCanvas.height, posterDefaultImg = new Image(); posterDefaultImg.src = 'https://cdn-portrait.test.17zuoye.net//public/skin/teacher_coursewarev2/images/upload_example.png'; posterDefaultImg.onload = function () &#123; posterContext.drawImage(posterDefaultImg, 0, 0, posterCanvasWidth, posterCanvasHeight); // 填充图片 posterContext.font = '16px MicrosoftYaHei'; // 填充title posterContext.textAlign = 'center'; // posterContext.fillText(inputText.value, 120, 114); // 如不处理限制文本宽度，直接绘制即可 var wordWidth = 0; // 字符宽度 var inputValue = inputText.value; // 操作的title if (posterContext.measureText(inputValue).width &lt; 190) &#123; // title小于最大宽度，直接绘制 posterContext.fillText(inputValue, 120, 114); &#125; else &#123; // title大于最大宽度则需要截取绘制 for (var i = 0; i &lt; inputValue.length; i++) &#123; // 遍历，根据当前的文本长度是否大于指定宽度，来截取 wordWidth += posterContext.measureText(inputValue[i]).width; // 逐渐追加的文本宽度 if (wordWidth &gt; 190) &#123; // 指定（190 + '...'） posterContext.fillText(inputValue.substring(0, i) + '...', 120, 114); break; &#125; &#125; &#125; var base64Url = posterCanvas.toDataURL('image/jpeg', 1.0); // toBase64 // 此处取到base64就可以用了，如传给后端等 &#125; &#125;;&#125; // 如何限定宽度： https://blog.csdn.net/lishihong108/article/details/52483867?ref=myread]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端吸顶效果]]></title>
    <url>%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[在开发移动端的时候，经常需要对tab做吸顶效果处理。 吐槽一下~ 有些程序员明知道增加吸顶效果对用户更加友好却嫌麻烦不加，非得产品经理提需求。 一个好的程序员应该再看见tab的时候就会想到这些，而不用等产品经理来提醒。开发产品的时候应该多站在用户的角度去思考问题，而不是首先考虑代码的实现。 好了，废话不多说，开始看代码: 12345678910111213&lt;div class="banner"&gt;&lt;/div&gt;&lt;div class="tab-content" id="tabContent"&gt; &lt;ul class="tab-box" id="tabBox"&gt; &lt;li&gt;精选&lt;/li&gt; &lt;li&gt;推荐&lt;/li&gt; &lt;li&gt;活动&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class="main"&gt; &lt;/div&gt; 12345678910111213141516var ua = window.navigator.userAgent.toLowerCase();var isIos = /iphone|ipod|ipad/ig.test(ua)if (isIos) &#123; // iOS使用 sticky属性 $('#tabContent').addClass('position-sticky'); // 操作外层&#125; else &#123; var tabOffsetTop = $('#tabBox').offset().top; // tab 距离头部的高度（定值） $(window).on('scroll', () =&gt; &#123; const scrollTop = $(window).scrollTop(); // 当前滚动条的高度（变值） if (scrollTop &gt;= tabOffsetTop) &#123; $('#tabBox').addClass('position-fix'); // 安卓操作内层div，外层div用于占位（此处占位的div很有必须） &#125; else &#123; $('#tabBox').removeClass('position-fix'); &#125; &#125;);&#125; 特别提示：安卓在滚动顶部的时候设置为fix定位，此时必须有个div占位，否则占位突然消失，可能会造成bug 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="initial-scale=1, user-scalable=0, minimal-ui" charset="UTF-8"&gt; &lt;title&gt;移动端吸顶效果&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .banner&#123; height: 160px; background: #eee; margin-bottom: 20px; &#125; .tab-content&#123; width: 100%; background: #ddd; height: 50px; margin-bottom: 20px; &#125; .tab-box&#123; background: #ddd; width: 100%; overflow: hidden; height: 50px; line-height: 50px; &#125; .tab-box li &#123; display: inline-block; width: 33.33%; float: left; text-align: center; &#125; .main&#123; background: #eee; &#125; .main p &#123; line-height: 100px; &#125; .position-sticky&#123; position: -webkit-sticky; position: sticky; top: 0px; z-index: 1; &#125; .position-fix&#123; position: fixed; left: 0; top: 0px; z-index: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="banner"&gt;&lt;/div&gt; &lt;div class="tab-content" id="tabContent"&gt; &lt;ul class="tab-box" id="tabBox"&gt; &lt;li&gt;精选&lt;/li&gt; &lt;li&gt;推荐&lt;/li&gt; &lt;li&gt;活动&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="main"&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;p&gt;1sdsdsd&lt;/p&gt; &lt;/div&gt; &lt;script src="./js/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var ua = window.navigator.userAgent.toLowerCase(); var isIos = /iphone|ipod|ipad/ig.test(ua); if (isIos) &#123; // iOS使用 sticky属性 $('#tabContent').addClass('position-sticky'); &#125; else &#123; var tabOffsetTop = $('#tabBox').offset().top; // tab 距离头部的高度（定值） $(window).on('scroll', () =&gt; &#123; const scrollTop = $(window).scrollTop(); // 当前滚动条的高度（变值） if (scrollTop &gt;= tabOffsetTop) &#123; $('#tabBox').addClass('position-fix'); // 安卓操作内层div，外层div用于占位 &#125; else &#123; $('#tabBox').removeClass('position-fix'); &#125; &#125;); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断css属性兼容性]]></title>
    <url>%2Fjavascript%2Fjs%E5%88%A4%E6%96%ADcss%E5%B1%9E%E6%80%A7%E5%85%BC%E5%AE%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[在css3兴起的今天，仍然有一些阻碍进步的机器在被使用中，web开发人员依然要痛苦的兼容它们。 我们可以在js中判断css属性是否可以正常使用，以便来正确的向下兼容。 123456789101112131415161718192021222324252627cssSupport: function (attr, value) &#123; var element = document.createElement('div'); if (attr in element.style) &#123; element.style[attr] = value; // 此处会直接设置 return element.style[attr] === value; &#125; else &#123; return false; &#125;&#125;// 例如我们检测css3的position:sticky的兼容性// 需求，吸顶悬浮效果（向上滚动到顶部时，tab栏吸顶，向下离开顶部时tab又跟随页面移动）init: function () &#123; if (this.cssSupport('position', 'sticky')) &#123; return ; &#125; // 对于不支持position:sticky的还是走常规的监听scroll事件（mescroll插件中，iOS使用sticky属性，安卓走scroll监听） $('el_parent').on('scroll', function () &#123; if (scrollTop &gt; topValue) &#123; $el.style.position = 'fixed'; &#125; else &#123; $el.style.position = 'relative'; &#125; &#125;);&#125;]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown文件夹说明]]></title>
    <url>%2Fother%2Fmarkdown%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[123456789101112131415161718├── base // 定义游戏开发基础类│ ├── animatoin.js // 帧动画的简易实现│ ├── pool.js // 对象池的简易实现│ └── sprite.js // 游戏基本元素精灵类├── libs│ ├── symbol.js // ES6 Symbol简易兼容│ └── weapp-adapter.js // 小游戏适配器├── npc│ └── enemy.js // 敌机类├── player│ ├── bullet.js // 子弹类│ └── index.js // 玩家类├── runtime│ ├── background.js // 背景类│ ├── gameinfo.js // 用于展示分数和结算界面│ └── music.js // 全局音效管理器├── databus.js // 管控游戏状态└── main.js]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css媒体查询]]></title>
    <url>%2Fcss%2Fcss%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637/* iPhone4 */@media only screen and (device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2) &#123;&#125;/* iPhone5 */@media only screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) &#123; &#125;/* iPhone6、iPhone7、iPhone8 */@media only screen and (device-height:375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) &#123; &#125;/* iPhone6Plus、iPhone7Plus、iPhone8Plus */@media only screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) &#123; &#125;/* iPhoneX */@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* iPhoneX */@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123; &#125;/* iPhoneXR */@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) &#123;&#125;/* iPhoneXs */@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* iPhoneXs Max */@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery上传文件]]></title>
    <url>%2Fjquery%2F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[12345678&lt;input type="text" onfocus="this.blur()" id="choiceInput" placeholder="请选择需要上传的文件"&gt;&lt;!-- 上传excel --&gt;&lt;input type="file" accept=".xls, .xlsx" id="hiddenInput" style="display: none;"&gt;&lt;!-- 上传图片 --&gt;&lt;input type="file" accept="image/gif,image/jpeg,image/jpg,image/png,image/svg" id="hiddenInput" style="display: none;"&gt;&lt;button id="uploadBtn"&gt;上传&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$('#choiceInput').on('click', function () &#123; $('#hiddenInput').click(); // 触发隐藏的file input&#125;);$('#hiddenInput').on('change', function () &#123; $('#choiceInput').val($(this)[0].files[0].name); // 显示上传文件的名称 // 如果没有上传按钮，则在此处开始上传&#125;);var uploadFlag = false; // 上传flag，防止多次点击$('#uploadBtn').on('click', function () &#123; if (uploadFlag) return; uploadFlag = true; var fileName = $('#choiceInput').val(); var file = $('#hiddenInput')[0].files[0]; if (fileName == "")&#123; alert("您还没有选择excel文档"); return ; &#125; // 判断上传的文件类型（判断excel） if (fileName.substring(fileName.length - 4) != ".xls" &amp;&amp; fileName.substring(fileName.length - 5) != ".xlsx") &#123; alert("仅支持上传excel文档"); return ; &#125; // 判断上传的文件类型（判断图片） if(!/image\/\w+/.test(file.type))&#123; alert("仅支持上传图片"); return ; &#125; var formData = new FormData(); // 注意formData存在兼容性，IE10开始支持 formData.append("adId", '10001'); formData.append("type", '1'); formData.append("file", file); $.ajax(&#123; url: "saveidbyfile.vpage", type: "POST", data: formData, processData: false, contentType: false, async: true, timeout: 10 * 1000, success: function (data) &#123; uploadFlag = false; if (data.success) &#123; alert('上传成功') &#125; else &#123; alert('上传失败：' + data.info); &#125; &#125;, error: function () &#123; uploadFlag = false; &#125; &#125;);&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker继承]]></title>
    <url>%2Ffreemarker%2Ffreemarker%E7%BB%A7%E6%89%BF.html</url>
    <content type="text"><![CDATA[freemarker有很好的继承机制，大体用法如下： 12345678||__layout.ftl | |__changeClazz.ftl | |__module.ftl | |__center.ftl 父级文件 layout.ftl123456789101112&lt;#marko page pageName="index" clazzName="t-center-bg1"&gt; &lt;!-- 此处暴露pageName和clazzName，可在子级中设置 --&gt; &lt;div class="$&#123;clazzName!''&#125;" data-page="$&#123;pageName!''&#125;"&gt; &lt;div class="header"&gt;&lt;/div&gt; &lt;#nested /&gt; # 此处暴露接口 &lt;div class="footer"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/#macro&gt; 子级文件 无孙子文件changeClazz.ftl 1234567891011&lt;#import "./layout.ftl" as temp /&gt;&lt;!-- import 父文件layout.ftl --&gt;@temp.page pageName='changeClazz' clazzName='t-center-bg2'&gt;&lt;!-- 设置layout的pageName 和 clazzName --&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/@temp.page&gt; 有孙子文件module.ftl 1234567891011121314151617181920212223&lt;#import "./layout.ftl" as temp /&gt;&lt;!-- import 父文件 --&gt;&lt;#marko center currentPage="index"&gt;&lt;!-- 此处暴露currentPage，可在子级中设置 --&gt; @temp.page pageName='center' clazzName='t-center-bg3'&gt; &lt;!-- 设置layout的pageName 和 clazzName --&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center" data-currentpage="$&#123;currentPage!''&#125;"&gt; &lt;div class="top"&gt;&lt;/div&gt; &lt;#nested /&gt; # 此处暴露接口 &lt;div class="bototm"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/@temp.page&gt;&lt;/#macro&gt; 孙子文件center.ftl123456789&lt;#import "module.ftl" as module&gt;&lt;!-- import 父文件module.ftl --&gt;@module.center currentPage='1'&gt;&lt;!-- 设置module的currentPage --&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/@module.page&gt;]]></content>
      <tags>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node安装的小型服务器]]></title>
    <url>%2Fnode%2Fnode%E5%B0%8F%E5%9E%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[node可以安装一些小型的服务器，如browser-sync、live-server、npx、Python服务器、anyproxy、spy-debugger browser-sync 详见BrowserSync 安装 123npm install -g browser-sync # 全局安装npm install --save-dev browser-sync # 局部安装 使用 12345browser-sync start --server --files "css/*.css" # 执行具体目录browser-sync start --server --files "css/*.css, *.html" # 监听多个类型的文件，逗号分开browser-sync start --server --files "**" # 自动运行 live-server 详见live-server 安装 123npm install -g live-server # 全局安装npm install --save-dev live-server # 局部安装 使用 12345live-serverlive-server --port=8080 # 指定端口live-server --browser=chrome # 指定浏览器访问 其他用法在package.json的scripts下配置 123"scripts": &#123; "server": "live-server ./ --port=8081" &#125; 运行 1npm run server npx 如果你把NPM升级到最新版本npm@5.2.0，可能会发现，它会安装一个新的包npx。 开启静态服务器 1npx http-server Python服务器 安装了 Python 的机器上，可以使用 nohup python -m SimpleHTTPServer [port] &amp; 快速搭建一个http服务。 使用123python -m SimpleHTTPServer 8000 # 只能前台运行python -m SimpleHTTPServer 8000 &amp; # 可后台运行，不影响终端的使用 anyproxy 详见anyproxy 安装 123npm install -g anyproxy # 全局安装npm install --save-dev anyproxy # 局部安装 使用 12345671、anyproxy2、电脑打开相应地址3、手机设置代理，默认端口98884、手机浏览器方位调试 更改端口 1anyproxy --port 1080 # 更改端口 代理HTTPS AnyProxy默认不对https请求做处理，如需看到明文信息，需要配置CA证书 解析https请求的原理是中间人攻击（man-in-the-middle），用户必须信任AnyProxy生成的CA证书，才能进行后续流程 生成证书并解析所有https请求 12anyproxy-ca #生成rootCA证书，生成后需要手动信任anyproxy --intercept #启动AnyProxy，并解析所有https请求 - [附录：如何信任CA证书](http://anyproxy.io/cn/#%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE) spy-debugger 详见spy-debugger 集成了anyproxy，可进行微信调试，各种WebView样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备。 安装 123npm install -g spy-debugger # 全局安装npm install --save-dev spy-debugger # 局部安装 使用 1234567891、spy-debugger2、电脑打开相应地址3、手机设置代理，默认端口98884、手机安装证书，手机浏览器访问http://s.xxx5、手机浏览器方位调试 配置1234567891011spy-debugger -p 8888 # 更改端口spy-debugger -e http://127.0.0.1:8888 # 设置外部代理spy-debugger -c true # 是否允许HTTP缓存，默认falsespy-debugger -b false # 是否只拦截浏览器发起的https请求，默认truespy-debugger -w true # 设置页面内容为可编辑模式，默认falsespy-debugger -i true # 是否允许weinre监控iframe加载的页面]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 求幂运算]]></title>
    <url>%2Fes7%2Fes7-%E6%B1%82%E5%B9%82%E8%BF%90%E7%AE%97.html</url>
    <content type="text"><![CDATA[ES7只新增了2个新特性 Array.prototype.includes Exponentiation Operator(求幂运算) 本文只讲解ES7求幂运算，includes方法请移步ES7 includes 在ES6中，可以使用Math.pow来实现求幂运算12Math.pow(2, 3); // 8Math.pow(3, 2); // 9 ES7中，可以使用**来实习求幂运算122 ** 3 // 83 ** 2 // 9]]></content>
      <tags>
        <tag>ES7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 includes方法]]></title>
    <url>%2Fes7%2Fes7-includes%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[ES7只新增了2个新特性 Array.prototype.includes Exponentiation Operator(求幂运算) 本文只讲解includes方法，Exponentiation Operator(求幂运算)请移步ES7求幂运算 Array.prototype.includes用法都容易和简单。它是一个替代indexOf（ES6新增），开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。 1234567891011let arr = ['react', 'angular', 'vue']// WRONGif (arr.indexOf('react')) &#123; // 0 -&gt; evaluates to false, definitely as we expected console.log('Can use React') // this line would never be executed&#125;// Correctif (arr.indexOf('react') !== -1) &#123; console.log('Can use React')&#125; 或者使用一点点hack 位运算符 ~ 使代码更加紧凑一些，因为~（位异或）对任何数字相当于-(a + 1): 123456let arr = ['react', 'angular', 'vue']// Correctif (~arr.indexOf('react')) &#123; console.log('Can use React')&#125; 而在ES7中，可以使用includes开替代indexOf作为检测： 123456let arr = ['react', 'angular', 'vue']// Correctif (arr.includes('react')) &#123; console.log('Can use React')&#125; 开发者还能在字符串中使用includes:123456let str = 'React Quickly'// Correctif (str.toLowerCase().includes('react')) &#123; // true console.log('Found "react"') &#125; includes第二可选参数fromIndex，这对于优化是有好处的，因为它允许从特定位置开始寻找匹配。 12345678console.log([1, 2, 3].includes(2)) // === trueconsole.log([1, 2, 3].includes(4)) // === falseconsole.log([1, 2, NaN].includes(NaN)) // === trueconsole.log([1, 2, -0].includes(+0)) // === trueconsole.log([1, 2, +0].includes(-0)) // === trueconsole.log(['a', 'b', 'c'].includes('a')) // === trueconsole.log(['a', 'b', 'c'].includes('a', 1)) // === falseconsole.log('React Quickly'.includes('React')) // === true]]></content>
      <tags>
        <tag>ES7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js检测浏览器是否出于放缩状态]]></title>
    <url>%2Fjavascript%2Fjs%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%90%A6%E5%87%BA%E4%BA%8E%E6%94%BE%E7%BC%A9%E7%8A%B6%E6%80%81.html</url>
    <content type="text"><![CDATA[先来说说浏览器提供的标准检测接口，window.devicePixelRatio 是设备上物理像素和设备独立像素的比例，该属性就可以用于检测网页是否被缩放了。在普通的 PC 浏览器上，在默认无缩放的情况下其默认值是 1。目前Firefox、chrome等都得到了很好的支持。 好吧，接下来该说说 IE 的处理方法了。IE 提供了 window.screen.deviceXDPI 和 window.screen.logicalXDPI 两个属性，deviceXDPI 就是对应的设备上的物理像素，而 logicalXDPI 就是对应了设备独立像素的比例。估计标准的检测接口也只是基于 IE 这种方法的一种改进。这两个属性在 windows XP+ 以上的系统上的默认值都是 96，因为系统默认的就是 96dpi 。 对于以上两种都不支持的浏览器，还可以利用window.outerWidth 和 window.innerWidth 这两个属性。outerWidth 返回的是窗口元素的外部实际宽度，innerWidth 返回的是窗口元素的内部实际宽度，这两个宽度都包含了滚动条在内的宽度。 123456789101112131415161718192021function detectZoom ()&#123; var ratio = 0, screen = window.screen, ua = navigator.userAgent.toLowerCase(); if (window.devicePixelRatio !== undefined) &#123; ratio = window.devicePixelRatio; &#125; else if (~ua.indexOf('msie')) &#123; if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) &#123; ratio = screen.deviceXDPI / screen.logicalXDPI; &#125; &#125; else if (window.outerWidth !== undefined &amp;&amp; window.innerWidth !== undefined) &#123; ratio = window.outerWidth / window.innerWidth; &#125; if (ratio)&#123; ratio = Math.round(ratio * 100); &#125; return ratio;&#125;; detectZoom 函数的返回值如果是 100 就是默认缩放级别，大于 100 则是放大了，小于 100 则是缩小了。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端算法集合]]></title>
    <url>%2Fjavascript%2F%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[使用前介绍123456// How to export and import module.exports = swap; --&gt; 对应 var s = require('../*.js');// 或：export default swap --&gt; 对应 import s from '../*.js'// 或:export &#123;swap&#125; --&gt; 对应 import &#123;swap&#125; from '../*.js' 不借助临时变量，交换整数加减乘除法注意：如果是浮点数，对于加减乘除法需要注意浮点数的精度丢失问题。12345678910111213141516171819202122232425262728293031// 思想：先求两个数的“和”，再用“和”去减function swap(a, b) &#123; // 如 [1, 3] a = a + b; // a = 1 + 3 = 4 b = a - b; // b = 4 - 3 = 1 a = a - b; // a = 4 - 1 = 3 return [a, b]; // [3, 1]&#125;// 思想：先求两个数的“差”，再用“差”去加function swap(a, b) &#123; // 如 [3, 1] a = a - b; // a = 3 - 1 = 2 b = a + b; // b = 2 + 1 = 3 a = b - a; // a = 3 - 2 = 1 return [a, b]; // [1, 3]&#125;// 思想：先求两个数的“乘积”，再用“乘积”去除function swap(a, b) &#123; // 如 [3, 8] a = a * b; // a = 3 * 8 = 24 b = a / b; // b = 24 / 8 = 3 a = a / b; // a = 24 / 3 = 8 return [a, b]; // [8, 3]&#125;// 思想：先求两个数的“商”，再用“商”去乘function swap(a, b) &#123; // 如 [8, 3] a = a / b; // a = 8 / 3 = 8 / 3 b = a * b; // b = (8 / 3) * 3 = 8 a = b / a; // a = 8 / (8 / 3) = 3 return [a, b]; // [3, 8]&#125; 对象法123456789function swap(a, b) &#123; // 如 [1, 3] a = &#123; a: b, b: a &#125; b = a.b; // 1 a = a.a; // 3 return [a, b]; // [3, 1]&#125; 数组法1234567891011function swap(a, b) &#123; // 如 [1, 3] a = [a, b]; b = a[0]; // 1 a = a[1]; // 3 return [a, b]; // [3, 1]&#125;function swap(a, b) &#123; // 如 [1, 3] a = [b, b = a][0]; // a = 3, b = 1; return [a, b]; // [3 ,1]&#125; ES6数组解构法，推荐1234function swap(a, b) &#123; // 如 [1, 3] [a, b] = [b, a]; return [a, b];&#125; 数组去重方法1（filter，推荐使用）1234567// filter函数会过滤出满足条件的元素function uniqueArr(arr)&#123; var newArr = arr.filter((item, index, self) =&gt; &#123; // 三个参数依次是：当前项、索引值、arr对象 return self.indexOf(item) === index; // 对于重复的元素，只有第一个元素符合条件，后面的都会被过滤掉 &#125;); return newArr;&#125; 方法2（新数组法）1234567891011function uniqueArr(arr)&#123; var newArr = []; // 一个新的临时数组 for(var i = 0; i &lt; arr.length; i++)&#123; // 遍历当前数组 // 如果当前数组的第i项已经保存进了临时数组，那么跳过， // 否则把当前项push到临时数组里面 if (newArr.indexOf(arr[i]) === -1)&#123; // 在新数组中查找原数组的每一项是否存在 newArr.push(arr[i]); // 如果不存在就加到新数组中 &#125; &#125; return newArr;&#125; 方法3（hash表法）12345678910function uniqueArr(arr) &#123; var obj = &#123;&#125;, newArr = []; // obj为hash表，newArr为临时数组 for(var i = 0; i &lt; arr.length; i++) &#123; // 遍历当前数组 , 可改成 for (var i in arr) &#123; if (!obj[arr[i]])&#123; // 如果hash表中没有当前项 obj[arr[i]] = true; // 存入hash表 newArr.push(arr[i]); // 把当前数组的当前项push到临时数组里面 &#125; &#125; return newArr;&#125; 方法41234567891011function uniqueArr(arr) &#123; var newArr = [arr[0]]; // 结果数组 for (var i = 1; i &lt; arr.length; i++) &#123; // 从第二项开始遍历 // 如果当前数组的第i项在当前数组中第一次出现的位置不是i， // 那么表示第i项是重复的，忽略掉。否则存入结果数组 if (arr.indexOf(arr[i]) === i) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 方法5（同时排序）12345678910function uniqueArr(arr)&#123; arr.sort(); // 数组排序 var newArr = [arr[0]]; // 先提取最小的 for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== newArr[newArr.length-1]) &#123; // 将不等于的放在新数组的后面，等于的跳过 newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 取数组中的最大最小值排序法12345678var arr = [0, 2, 5, 1, 4, 3];arr.sort(function (a, b) &#123; return a - b;&#125;); // [0, 1, 2, 3, 4, 5]var min = arr[0]; // 0var max = arr[arr.length - 1]; // 5 apply方法1234567891011121314151617181920Math.max.apply(null, [1, 2, 3, 4]);Math.min.apply(null, [1, 2, 3, 4]);// apply()方法function.apply(thisObj[, argArray]); // 2个参数，参数2为数组// call()方法function.call(thisObj[, arg1[, arg2[, [, ...argN]]]]); // 多个参数，其他参数为非数组// 同理，利用apply方法还可以用于拼接数组：var arr1 = new Array("1", "2", "3");var arr2 = new Array("4", "5", "6");Array.prototype.push.apply(arr1, arr2); // 返回数组长度 6arr1.push.apply(arr1, arr2); // arr1:["1", "2", "3", "4", "5", "6"]// 上面的等同于arr1.push(...arr2); // ES6语法arr1.concat(arr2); // ES5语法// 更多apply和call用法见：https://www.cnblogs.com/lengyuehuahun/p/5643625.html 数组排序segmentfault【wscats】 十大经典排序算法 冒泡排序 比较相邻的元素，如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实际排序时，由后往前完成排序动作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 // 使用中间变量实现元素交互 // var temp = arr[j+1]; // arr[j+1] = arr[j]; // arr[j] = temp; // es6数组解构实现元素交互 [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; &#125; &#125; &#125; return arr;&#125;// 假设arr是一个数组为5的数组// i j// ----// 0 0// 0 1// 0 2// 0 3// ----// 1 0// 1 1// 1 2// ----// 2 0// 2 1// ----// 3 0// 由上面可以看出，取arr[j]和arr[j+1]即是两个相邻元素的比较// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际冒泡排序如下：// ① ⑧ 5 4 7 3 9 2 6 // 1与8比较 =&gt; 1 8 5 4 7 3 9 2 6// 1 ⑧ ⑤ 4 7 3 9 2 6 // 8与5比较 =&gt; 1 5 8 4 7 3 9 2 6// 1 5 ⑧ ④ 7 3 9 2 6 // 8与4比较 =&gt; 1 5 4 8 7 3 9 2 6// 1 5 4 ⑧ ⑦ 3 9 2 6 // 8与7比较 =&gt; 1 5 4 7 8 3 9 2 6// 1 5 4 7 ⑧ ③ 9 2 6 // 8与3比较 =&gt; 1 5 4 7 3 8 9 2 6// 1 5 4 7 3 ⑧ ⑨ 2 6 // 8与9比较 =&gt; 1 5 4 7 3 8 9 2 6// 1 5 4 7 3 8 ⑨ ② 6 // 9与2比较 =&gt; 1 5 4 7 3 8 2 9 6// 1 5 4 7 3 8 2 ⑨ ⑥ // 9与6比较 =&gt; 1 5 4 7 3 8 2 6 9// // ① ⑤ 4 7 3 8 2 9 6 // 1与5比较 =&gt; 1 5 4 7 3 8 2 6 9// 1 ⑤ ④ 7 3 8 2 6 9 // 5与4比较 =&gt; 1 4 5 7 3 8 2 6 9// 1 4 ⑤ ⑦ 3 8 2 6 9 // 5与7比较 =&gt; 1 4 5 7 3 8 2 6 9// 1 4 5 ⑦ ③ 8 2 6 9 // 7与3比较 =&gt; 1 4 5 3 7 8 2 6 9// 1 4 5 3 ⑦ ⑧ 2 6 9 // 7与8比较 =&gt; 1 4 5 3 7 8 2 6 9// 1 4 5 3 7 ⑧ ② 6 9 // 8与2比较 =&gt; 1 4 5 3 7 2 8 6 9// 1 4 5 3 7 2 ⑧ ⑥ 9 // 8与6比较 =&gt; 1 4 5 3 7 2 6 8 9//// ① ④ 5 3 7 2 6 8 9 // 1与4比较 =&gt; 1 4 5 3 7 2 6 8 9// 1 ④ ⑤ 3 7 2 6 8 9 // 4与5比较 =&gt; 1 4 5 3 7 2 6 8 9// 1 4 ⑤ ③ 7 2 6 8 9 // 5与3比较 =&gt; 1 4 3 5 7 2 6 8 9// 1 4 3 ⑤ ⑦ 2 6 8 9 // 5与7比较 =&gt; 1 4 3 5 7 2 6 8 9// 1 4 3 5 ⑦ ② 6 8 9 // 7与2比较 =&gt; 1 4 3 5 2 7 6 8 9// 1 4 3 5 2 ⑦ ⑥ 8 9 // 7与6比较 =&gt; 1 4 3 5 2 6 7 8 9// // ① ④ 3 5 2 6 7 8 9 // 1与4比较 =&gt; 1 4 3 5 2 6 7 8 9// 1 ④ ③ 5 2 6 7 8 9 // 4与3比较 =&gt; 1 3 4 5 2 6 7 8 9// 1 3 ④ ⑤ 2 6 7 8 9 // 4与5比较 =&gt; 1 3 4 5 2 6 7 8 9// 1 3 4 ⑤ ② 6 7 8 9 // 5与2比较 =&gt; 1 3 4 2 5 6 7 8 9// 1 3 4 2 ⑤ ⑥ 7 8 9 // 5与6比较 =&gt; 1 3 4 2 5 6 7 8 9// // ... ...// // ① ② 3 4 5 6 7 8 9 // 1与2比较 =&gt; 1 2 3 4 5 6 7 8 9 选择排序 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; // 此处循环到倒数第二项即可，届时最后一项已经完成排序（最大或最小） minIndex = i; // 假设次数最小数的索引为当前i for (var j = i + 1; j &lt; len; j++) &#123; // 遍历i之后的数 if (arr[j] &lt; arr[minIndex]) &#123; // 存在比minIndex还小的数 minIndex = j; // 将最小数的索引赋给minIndex &#125; &#125; // 此时minIndex可能等于i（即上面遍历之后不存在更小的），也可能不等于i（存在更小的，即arr[minIndex] &lt; arr[i]）; // 但是此时minIndex &gt;= i，所以我们交换arr[i]和arr[minIndex]的位置即可 // 将 minIndex对应的数 放在当前索引对应的数的前面 // temp = arr[i]; // arr[i] = arr[minIndex]; // arr[minIndex] = temp; // es6数组结构实现元素交换 [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; &#125; return arr;&#125;// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际选择排序如下：// ① 8 5 4 7 3 9 2 6 // 1与1交换// // 1 ⑧ 5 4 7 3 9 ② 6 // 8与2交换// 1 2 5 4 7 3 9 8 6// // 1 2 ⑤ 4 7 ③ 9 8 6 // 5与3交换// 1 2 3 4 7 5 9 8 6// // 1 2 3 ④ 7 5 9 8 6 // 4与4交换// 1 2 3 4 7 5 9 8 6// // 1 2 3 4 ⑦ ⑤ 9 8 6 // 7与5交换// 1 2 3 4 5 7 9 8 6// // 1 2 3 4 5 ⑦ 9 8 ⑥ // 7与6交换// 1 2 3 4 5 6 9 8 7// // 1 2 3 4 5 6 ⑨ 8 ⑦ // 9与7交换// 1 2 3 4 5 6 7 8 9// // 1 2 3 4 5 6 7 ⑧ 9 // 8与8交换// 1 2 3 4 5 6 7 8 9 快速排序 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let pivot = arr[0]; // 选择第一项作为基准值 for (let i = 1; i &lt; arr.length; i++) &#123; // 从1开始遍历，因为0已经作为基准值使用了 if (arr[i] &gt; pivot) &#123; rightArr.push(arr[i]); &#125; else&#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(quickSort(leftArr), [q], quickSort(rightArr)); // 拼接左分区、基准值、右分区（进行递归）&#125;// 以数组[1, 8, 5, 4, 7, 3, 9, 2, 6]为例，实际快速排序如下：// arr:[1, 8, 5, 4, 7, 3, 9, 2, 6] // ├── left: []// │// ├── pivot: 1// │// └── right:[8, 5, 4, 7, 3, 9, 2, 6]// │// ├── left: [5, 4, 7, 3, 2, 6]// │ │// │ ├── left: [4, 3, 2]// │ │ │// │ │ ├── left: [3, 2]// │ │ │ │ // │ │ │ ├── left: [2]// │ │ │ │// │ │ │ ├── pivot: 3// │ │ │ │// │ │ │ └── right: []// │ │ │ // │ │ ├── pivot: 4// │ │ │// │ │ └── right: []// │ │ // │ ├── pivot: 5// │ │// │ └── right: [7, 6]// │ │// │ ├── left: [6]// │ │// │ ├── pivot: 7// │ │// │ └── right: []// │ // ├── pivot: 8// │// └── right: [9]// // // 按上图拆分完毕后，从内到外拼接（递归）即可完成排序得到：[1, 2, 3, 4, 5, 6, 7, 8, 9] 插入排序 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 二路归并排序将两个按值有序序列合并成一个按值有序序列1234567891011121314151617181920function merge(left, right) &#123; var result = [], il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); &#125; else &#123; result.push(right[ir++]); &#125; &#125; while(left[il])&#123; result.push(left[il++]); &#125; while(right[ir])&#123; result.push(right[ir++]); &#125; return result;&#125; 希尔排序123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap =gap*3+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 其他常见应用数字、英文排序1234567891011121314151617// 顺序：function sortArr (arr)&#123; return arr.sort();&#125;// 或：function sortArr (arr)&#123; return arr.sort(function (a, b) &#123; return a &gt; b &#125;);&#125;// 倒序：function sortArr (arr)&#123; return arr.sort(function (a, b) &#123; return a &lt; b &#125;);&#125; 中文姓名排序12345678910111213// 顺序function sortNameArr (arr) &#123; return arr.sort(function (a, b) &#123; return b.localeCompare(a, 'zh-Hans-CN') &#125;)&#125;// 倒序function sortNameArr (arr) &#123; return arr.sort(function (a, b) &#123; return a.localeCompare(b, 'zh-Hans-CN') &#125;)&#125; 数组乱序123456789function shuffle(array) &#123; for (var i = array.length - 1; i &gt; 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; return array; &#125; Number数组中最大差值123456789101112function getMaxProfit (arr) &#123; var min = arr[0], max = arr[0]; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; return max - min;&#125; 打印九九乘法表1234567for (var n = 1; n &lt;= 9; n++) &#123; for (var m = 1; m &lt; n+1; m++) &#123; var b = m * n; document.write(m + "×" + n + "=" + b + " "); &#125; document.write("&lt;br/&gt;&lt;br/&gt;");&#125; 求数组交集和差级ES7方法：123let intersection = a.filter(v =&gt; b.includes(v)) let difference = a.concat(b).filter(v =&gt; !a.includes(v) || !b.includes(v)) 字符串翻转转换成array123function reverseString(str) &#123; return str.split('').reverse().join();&#125; 反向遍历123456function reverseString(str)&#123; var tmp = ''; for(var i = str.length - 1;i &gt;= 0; i--) tmp += str[i]; return tmp&#125; 生成随机字符串1234567function randomString(n)&#123; var str = 'abcdefghijklmnopqrstuvwxyz0123456789'; var tmp = ''; for(var i = 0; i &lt; n; i++) tmp += str.charAt(Math.round(Math.random()*str.length)); return tmp;&#125; 判断回文123456789101112131415// 算法思想：每次判断第一个字符和最后一个字符是否相等，然后取第二个字符到倒数第二个字符之间的字符串递归function palindrome(str)&#123; // \W匹配任何非单词字符，即去除非正常字符。等价于“[^A-Za-z0-9_]”。 var re = /[\W_]/g; // 将字符串变成小写字符,并干掉除字母数字外的字符 var lowRegStr = str.toLowerCase().replace(re, ''); // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome if(lowRegStr.length === 0) return true; // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome if(lowRegStr[0] !== lowRegStr[lowRegStr.length - 1]) return false; //递归 return palindrome(lowRegStr.slice(1, lowRegStr.length - 1));&#125; 统计字符串中最多的字母123456789101112131415161718192021222324// 算法思想：先遍历，将出现的字符和次数以object的形式输出；再obj遍历，输出次数最多的字符function findMaxDuplicateChar(str) &#123; if(str.length == 1) &#123; return str; &#125; var charObj = &#123;&#125;; for(var i = 0; i &lt; str.length; i++) &#123; if(!charObj[str.charAt(i)]) &#123; charObj[str.charAt(i)] = 1; &#125; else &#123; charObj[str.charAt(i)] += 1; &#125; &#125; console.log('charObj', charObj) var maxChar = '', maxValue = 1; for(var k in charObj) &#123; // k为key, charObj[k]为value if(charObj[k] &gt;= maxValue) &#123; maxChar = k; maxValue = charObj[k]; &#125; &#125; return maxChar + '：' + maxValue;&#125; 阶乘1x2x3x4x5… 递归12345678function factorialize(num) &#123; var result = 1; if(num &lt; 0) return -1; if(num == 0 || num == 1) return 1; if(num &gt; 1)&#123; return num * factorialize(num - 1); &#125;&#125; 非递归12345678function factorialize(num) &#123; var result = 1; if(num &lt; 0) return -1; if(num == 0 || num == 1) return 1; while(num &gt; 1) result *= num--; return result;&#125; 生成斐波那契数列斐波那契数列（黄金分割数列）: 0、1、1、2、3、5、8、13、21、34，考察递归 递归123456789101112131415function getfib(n)&#123; if (n == 0) return 0; if (n == 1) return 1; if (n &gt; 1) &#123; return getfib(n - 1) + getfib(n - 2); &#125;&#125;function fibo(len)&#123; var fibo = []; for(var i = 0; i &lt; len; i++) fibo.push(getfib(i)); return fibo;&#125; 非递归12345678910111213function getFibonacci(n) &#123; var fibarr = []; var i = 0; while(i &lt; n) &#123; if(i &lt;= 1) &#123; fibarr.push(i); &#125; else &#123; fibarr.push(fibarr[i - 1] + fibarr[i - 2]) &#125; i++; &#125; return fibarr;&#125; 二分查找查找某个值是否在有序数组中，数组必须是有序的 递归1234567891011function binary_search2(arr, low, high, key) &#123; if(low &gt; high) return -1; var mid = parseInt((low + high)/2); if(key == arr[mid]) return mid; else if(key &gt; arr[mid]) return binary_search2(arr, mid+1, high, key); else if(key &lt; arr[mid]) return binary_search2(arr, low, mid-1, key);&#125; 非递归123456789101112131415function binary_search(arr, key) &#123; var low = 0, high = arr.length - 1; while(low &lt;= high)&#123; var mid = parseInt((high + low) / 2); if (key == arr[mid]) &#123; return mid; &#125; else if(key &gt; arr[mid]) &#123; low = mid + 1; &#125; else if(key &lt; arr[mid]) &#123; high = mid - 1; &#125; &#125; return -1;&#125;; 找出数组当中的质数质数：也称素数，&gt;1, 有无限个。除1和它自身之外不能被其他数整除，如2、3、5、7等，否则称为合数。1234567891011121314151617181920212223242526// 思想：m % n === 0, 等于0表示能整除，即不是质数// 循环生成一个100内的数组var i, arr = [];for (i = 1; i &lt; 100; i++) &#123; arr.push(i);&#125;var getPrimes = arr.filter((el) =&gt; &#123; var flag = true; // 定义一个boolean值，filter返回布尔值 if (el &lt; 2) &#123; // 小于2的直接排除 flag = false; &#125; else &#123; // 使用小于当前元素的数值去整除当前当前元素，有一个可以整除则跳出循环 for (var j = 2; j &lt; el; j++) &#123; if (el % j === 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125;);console.log(getPrimes)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React官方CDN]]></title>
    <url>%2Freact%2Freact%E5%AE%98%E6%96%B9cdn.html</url>
    <content type="text"><![CDATA[开发版本： 12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 生产版本 12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt;]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router懒加载]]></title>
    <url>%2Fvue%2Fvue-router%E8%B5%96%E5%8A%A0%E8%BD%BD%E5%86%99%E6%B3%95.html</url>
    <content type="text"><![CDATA[默认的加载模式：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 但当项目过大时需要使用懒加载方法 用法1：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'const HelloWorld = resolve =&gt; require(['@/components/HelloWorld'], resolve)Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 用法2：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'const HelloWorld = resolve =&gt; import('@/components/HelloWorld').then((module) =&gt; resolve(module))Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 用法3：12345678910111213141516import Vue from 'vue'import Router from 'vue-router'const HelloWorld = resolve =&gt; require.ensure([], () =&gt; resolve(require('@/components/HelloWorld')), 'HelloWorld')Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;)]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识requirejs]]></title>
    <url>%2Fjavascript%2F%E5%88%9D%E8%AF%86%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDrequirejs.html</url>
    <content type="text"><![CDATA[在浏览器中可以作为js文件的模块加载器，也可以用在Node和Rhino环境。 初识requirejs先看一个小demo： index.html:123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;body&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; a.js:1234567891011121314function fun1()&#123; alert("it works");&#125;fun1();// 或 使用块作用域来申明function防止污染全局变量(function()&#123; function fun1()&#123; alert("it works"); &#125; fun1();&#125;)() 运行结果：alert执行的时候，页面上的span元素还未显示。这是因为js阻塞浏览器渲染，导致body内容未能被读取。 requirejs写法:先去require官网下载jsindex.html:123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="require.js"&gt;&lt;/script&gt; &lt;script&gt; require(["a"]); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;body&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; a.js:1234567define(function () &#123; function func1 () &#123; alert('it works'); &#125; func1();&#125;) 运行结果：alert执行的时候，页面能正常显示body了 这个时候可以知道require的优点：1.防止js加载阻塞页面渲染2.管理模块之间的依赖性，便于代码的编写和维护，防止出现如下丑陋的场景。这种写法需要将依赖最大的放在最后加载，如j.js依赖前面的js，就必须放到最后，当关系很复杂时，极难维护。12345678910&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="c.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="d.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="e.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="f.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="g.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="h.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="i.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="j.js"&gt;&lt;/script&gt; 基本APIrequire会定义三个变量：define、require、requirejs，require = requirejs，一般使用require更简短 define 用来定义一个模块define后面也可以增加参数[“jqueyr”],即保证jquery加载完成后读取该js文件 123define([&quot;jquery&quot;], function ($) &#123; console.log(&apos;it is loaded&apos;)&#125;) require 加载依赖模块，并执行加载后的回调函数 require([“js/a.js”, “js/b.js”])的第一个参数时一个数组，即加载的脚本，第二个参数时callback，处理加载完毕后的回调123require(["js/a.js", "js/b.js"], function () &#123; console.log('load finished');&#125;) 加载文件使用require()来加载模块的使用只能加载本地js，但如果需要加载服务器、其他网站或CDN，就需要用require.config来配置加载123456789101112require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery"], // 或省略中括号 "bootstrap": ["https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap"] &#125;&#125;);require(["jquery", "js/a.js"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); require.config 用来配置加载位置，给模块起一个更短更好记的名字，配置别名之后就可以再require中使用别名了。注意：require中的可以带.js后缀；paths中的路径不能带.js后缀，否则会报错，paths中的每个别名对应的js如果只有一个时可以省略中括号； require.config 中也可以用来配置本地的js 12345678910111213require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery"], "bootstrap": ["https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap"], "a": "js/a" &#125;&#125;);require(["jquery", "a"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); 最终渲染成下面这样：12&lt;script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="jquery" src="http://cdn.bootcss.com/jquery/2.2.4/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="a" src="./a.js"&gt;&lt;/script&gt; 通过require.config配置模块名称时可以配置多个路径，比如配置一个CDN路径，再配一个本地的库1234567891011require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery", 'js/jquery'], "a": "js/a" &#125;&#125;);require(["jquery", "a"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); 当paths中都是本地路径时，可以指定一个baseUrl表示目录123456789101112require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": jquery', "a": "a" &#125;&#125;);require(["jquery", "a"], function ($) &#123; $(function () &#123; console.log('load finished'); &#125;)&#125;); 上例中require的callback中的参数$是jquery模块的输出变量，如果依赖多个模块，可以依次写入多个参数。将需要输出的模块写在前面，位置不能错乱。12345require(["jquery", "underscore", "js/a"], function($, _) &#123; $(function () &#123; _.each([1,2,3], alert); &#125;);&#125;) 全局配置require.config配置如果在每个页面中都加入，显然会十分不雅，requirejs提供了一种叫”主数据“的功能，我们首先创建一个main.js：1234567require.config(&#123; paths: &#123; "jquery": ["https://cdn.bootcss.com/jquery/2.2.4/jquery", 'js/jquery'], "a": "js/a" &#125;&#125;); 然后在页面中使用下面的方式来使用requirejs：1&lt;script data-main="js/main src="js/require.js"&gt;&lt;/script&gt; data-main属性表示指定的js将在加载完require.js后处理，我们把require.config的配置加入到data-main后，就可以使每一个页面都使用这个配置，然后页面中就可以直接使用require来加载所有的短模块名data-main还有一个功能，当script标签指定data-main属性时，require会默认将data-main指定的js为根路径。如上面的data-main=”js/main”设定后，我们在直接使用require([“jquery”])，而不是require([“js/jquery”])，require会自动加载js/jquery这个文件，而不是jquery.js。相当于默认配置了：123require.config(&#123; baseUrl: 'js'&#125;); 第三方模块通过require加载的模块一般都要符合AMD规范及使用define来申明模块，但是部分时候需要加载非AMD规范的js，这时候就需要用到另一个功能：shim，中文意思”垫“. 1、非AMD模块输出，例如，在老版本的jquery中，是没有继承AMD规范的，所以不能只能require([“jquery”])，这个时候就需要用到 shim，比如要使用underscore类库，但是它并没有实现AMD规范，可以这样配置1234567requier.config(&#123; shim: &#123; "underscore": &#123; export: "_" &#125; &#125;&#125;) 这样配置后，我们就可以再其他模块中引用underscore模块：123require(["underscore"], function (_) &#123; _.each([1, 2, 3], alert)&#125;) 2、插件形式的非AMD模块，我们经常会用到jquery的插件，而这些插件基本都不符合AMD规范比如，jquery的form插件，这时候就需要将form插件”垫“到jquery中12345678910require.config(&#123; shim: &#123; "underscore" : &#123; exports : "_"; &#125;, "jquery.form" : &#123; deps : ["jquery"] &#125; &#125;&#125;); 也可以简写成：12345678require.config(&#123; shim: &#123; "underscore" : &#123; exports : "_"; &#125;, "jquery.form" : ["jquery"] &#125;&#125;); exports表明该模块外部调用时的名称，deps数组表示该模块的依赖 这样配置之后我们就可以使用加载插件后的jquery了12345require.config(["jquery", "jquery.form"], function($)&#123; $(function()&#123; $("#form").ajaxSubmit(&#123;...&#125;); &#125;)&#125;); 来源：runoob文档]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用mint-ui移动端组件库]]></title>
    <url>%2Fvue%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8mint-ui%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93.html</url>
    <content type="text"><![CDATA[mint-ui官网mint-ui 1.0文档mint-ui 2.0文档 预览http://elemefe.github.io/mint-ui/#/ 安装12345# Vue 1.xnpm install mint-ui@1 -S# Vue 2.0npm install mint-ui -S 引入1234567891011// main.js引入全部组件import Vue from &apos;vue&apos;;import Mint from &apos;mint-ui&apos;;import &apos;mint-ui/lib/style.css&apos; Vue.use(Mint);// 按需引入部分组件import &#123; Toast, Indicator &#125; from &apos;minu-ui&apos;;import &apos;mint-ui/lib/style.css&apos; components: &#123;Toast, Indicator&#125; 部分用法 Toast 1234567891011121314151617Toast('我就是那个3s的toast') // 默认3sToast(&#123; message: '哈哈，我是5s的toast', position: 'bottom', duration: 5000 // -1表示一直开启&#125;)Toast(&#123; message: '操作成功', iconClass: 'icon icon-success' // 增加icon class类名&#125;)let instance = Toast('提示信息');setTimeout(() =&gt; &#123; instance.close(); // 手动关闭&#125;, 2000); Indicator加载 12345678Indicator.open('加载中...')Indicator.open(&#123; text: '加载中...', spinnerType: 'triple-bounce' // snake(默认)、fading-circle、double-bounce、triple-bounce&#125;)Indicator.close(); // 手动关闭 MessageBox 1234567891011121314151617181920212223242526272829303132MessageBox('提示', '操作成功')MessageBox(&#123; title: '提示', message: '操作成功', showCancelButton: true // 带取消按钮&#125;)MessageBox.alert('操作成功', '提示')MessageBox.alert('操作成功', '提示').then(action =&gt; &#123; // 点击按钮的回调&#125;);MessageBox.confirm('确定执行此操作', '提示')MessageBox.confirm('确定执行此操作', '提示').then(action =&gt; &#123; // 点击按钮的回调&#125;);MessageBox.prompt('请输入姓名', '提示');MessageBox.prompt('确定执行此操作', '提示').then((&#123;value, action&#125;) =&gt; &#123; // 点击按钮的回调 console.log(value)&#125;);// title: 标题// message: 提示框内容// showConfirmButton: 是否显示确认按钮，默认true// showCancelButton: 是否显示取消按钮，默认false// confirmButtonText、confirmButtonHighlight、confirmButtonClass: 确认按钮文本、加粗、类名// cancelButtonText、cancelButtonHighlight、cancelButtonClass: 取消按钮文本、加粗、类名// closeOnClickModal: 点击遮罩关闭提示框// showInput、inputType、inputValue、inputPlaceholder: 是否显示输入框、输入框类型、输入框的值、输入框的占位符 Action sheet操作表 1234567891011121314151617181920212223242526272829303132333435363738// template&lt;button @click="showActionSheet"&gt;点击上拉 action sheet&lt;/button&gt;&lt;mt-actionsheet :actions="actions" :cancelText="cancelText" :closeOnClickModal="true" v-model="sheetVisible"&gt;&lt;/mt-actionsheet&gt;// js:data () &#123; return &#123; actions: [ // 可选择的 &#123; name: '拍照', method: this.choiceCamera // 点击后回调 &#125;, &#123; name: '从相册中选择', method: this.choicePhoto &#125; ], sheetVisible: false, cancelText: '取消', // 取消按钮的文本 &#125;&#125;,methods: &#123; showActionSheet () &#123; this.sheetVisible = true &#125;, choiceCamera () &#123; console.log('选择了拍照') &#125;, choicePhoto () &#123; console.log('选择了从相册中选择') &#125;&#125; 更多用法请查看官方文档 mint-ui 1.0文档mint-ui 2.0文档]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在js文件中调用一个vue组件]]></title>
    <url>%2Fvue%2F%E5%9C%A8js%E9%87%8C%E9%9D%A2%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AAvue%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[通常情况下我们都是在一个父组件中调用一个子组件，有时我们可能需要在一个js文件内来调用子组件，如在全局的index.js中设置请求拦截器时调用一个message弹窗子组件，用来显示报错信息 component中有一个message子组件：123456789101112// htmldiv.message-mask(v-if="alertMsg.isShowMessage") div p &#123;&#123;alertMsg.errInfo&#125;&#125; button(@click="close") 关闭// scriptmethods: &#123; close () &#123; this.$emit('close'); &#125;&#125; 如果是在父组件中调用message组件，这样写：123456789101112131415161718// htmldiv message(:alert-msg="alertMessage", @close="closeEvent")// scriptdata () &#123; return &#123; alertMessage: &#123; isShowMessage: true, errInfo: '' &#125; &#125;&#125;，methods: &#123; closeEvent () &#123; this.alertMessage.isShowMessage = false; &#125;&#125; 如果是在其他js中调用，这样写： 在util文件中设置一个alert.js文件12345678910111213141516171819202122import Vue from 'vue';import alert from '../components/alert';let instance = null;const MessageConstructor = Vue.extend(alert);const Message = (config) =&gt; &#123; instance = new MessageConstructor(&#123; el: document.createElement('div') &#125;); document.body.appendChild(instance.$el); Vue.nextTick(()=&gt;&#123; instance.alertMsg = config; instance.$on('close', function () &#123; document.body.removeChild(this.$el); &#125;) &#125;);&#125;export default Message; 在全局的index.js文件中这样使用（Message处）：12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from 'vue';import axios from "axios";import Message from './util/alert';Vue.prototype.$ajax = axios;// axios相关配置axios.interceptors.request.use( function(config) &#123; config.data=qs.stringify(config.data); return config; &#125;, function(error) &#123; // Do something with request error return Promise.reject(error); &#125;);// Add a response interceptoraxios.interceptors.response.use( function(response) &#123; // Do something with response data if (response.data.success) &#123; return response.data; &#125; else &#123; //此处需要弹框组件 var isShowAlert = document.getElementsByClassName('message-mask').length != 0; if (!isShowAlert) &#123; // 此处设置检查弹窗，只出现一次，防止同步请求都请求失败时弹窗出现两次bug Message(&#123; isShowMessage: true, errInfo: response.data.errorInfo || '请求失败，稍后重试' &#125;); &#125; return Promise.reject(response.data.error); &#125; &#125;, function(error) &#123; // Do something with response error return Promise.reject(error); &#125;); 实际上我们在构建时就应当考虑这种写法的弊端，正确的做法应该是在顶层组件中挂载message组件，需要显示是通过$emit派发事件显示或关闭即可]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewport各宽高值]]></title>
    <url>%2Fhtml%2Fviewport%E5%90%84%E5%AE%BD%E9%AB%98%E5%80%BC.html</url>
    <content type="text"><![CDATA[js中viewport的各个宽高值如下：]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ftl的js中获取freemarker的值]]></title>
    <url>%2Ffreemarker%2Fjs%E8%8E%B7%E5%8F%96freemarker%E7%9A%84%E5%80%BC.html</url>
    <content type="text"><![CDATA[假设后端往ftl模板中注入了下列值1234567891011121314151617testA: 'aaaa'testB: &#123; bDataOne: 'b1', bDateTwo: 'b2'&#125;testC: [ &#123; cDateOne: 'c11' cDateTwo: 'c12' &#125;, &#123; cDateOne: 'c21' cDateTwo: 'c22' &#125;] 想在ftl页面的js中获取testA、testB、testC12345678910111213141516171819202122// 获取testAvar getA = &quot;$&#123;testA!&apos;&apos;&#125;&quot;;// 获取testB&lt;#if testB?? &amp;&amp; testB.bDataOne??&gt; var getB1 = &quot;$&#123;testB.bDataOne!&apos;&apos;&#125;&quot;; var getB2 = &quot;$&#123;testB.bDataTwo!&apos;&apos;&#125;&quot;;&lt;/#if&gt;// 获取testC，对于list，我们不能直接使用list数据，必选转换一下才能正常使用// 收集list中每一项的某个key&lt;#if testC??&gt; var arr = []; &lt;#list testC as c&gt; arr.push(&apos;$&#123;c.cDateOne&#125;&apos;) &lt;/#list&gt;&lt;/#if&gt;console.log(arr); // 然后将可以正常的使用了// 获取整个list，正在搜索中...]]></content>
      <tags>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker部分语法]]></title>
    <url>%2Ffreemarker%2Ffreemarker%E9%83%A8%E5%88%86%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[假设后端往ftl模板中注入了下列值1234567891011121314151617181920212223testA: '1111'testB: &#123; bDataOne: 'b1', bDateTwo: 'b2'&#125;testC: [ &#123; cDateOne: 'c11' cDateTwo: 'c12' &#125;, &#123; cDateOne: 'c21' cDateTwo: 'c22' &#125;]testD: falsetestE: &#123; eData: false&#125; 在ftl中页面中我们可以这样获取：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354$&#123;testA&#125; // 直接获取$&#123;testA!&#125; // 获取，取不到时为空串，空序列或空哈希表（arr or object）$&#123;testA!&apos;&apos;&#125; // 获取，取不到时为空字符串$&#123;testA!&apos;test&apos;&#125; // 获取，取不到位test字符串$&#123;testD.eData!false&#125; // 获取testD里面的eData，取不到为false;取到testD，取不到eData，为false;取不到testD会出问题$&#123;(testD.eData)!false&#125; // 获取testD里面的eData，取不到testD或testD.eData，均为false// 判断testA存在时&lt;#if testA&gt; ***&lt;/#if&gt;// 判断testA存在时&lt;#if testA??&gt; ***&lt;/#if&gt;// 判断testA存在时&lt;#if testA?has_content&gt; ***&lt;/#if&gt;// 判断testA为&apos;1111&apos;时&lt;#if testA === &apos;1111&apos;&gt; ***&lt;/#if&gt;// 判断testD为false存在时，如果取不到就用false&lt;#if testD!false&gt; ***&lt;/#if&gt;// 判断testB及testB.bDataOne存在时&lt;#if testB?? &amp;&amp; testB.bDataOne??&gt; ***&lt;/#if&gt;// 渲染列表testC&lt;#list testC as c&gt; &lt;p&gt;&lt;span&gt;$&#123;c.cDateOne!&#125;&lt;/span&gt;和&lt;span&gt;$&#123;c.cDateTwo!&#125;&lt;/span&gt;&lt;/p&gt;&lt;/#list&gt;// data属性存储testD&lt;p data-isShow=&quot;$&#123;(testD!false)?string(&apos;yes&apos;, &apos;no&apos;)&#125;&quot;&gt; // testD为true时，属性记录为yes，为false时或取不到时为false// data属性存储testE.eData&lt;p data-isShow=&quot;$&#123;((testE.eData)!false)?string(&apos;yes&apos;, &apos;no&apos;)&#125;&quot;&gt; // testD为true时，属性记录为yes，为false时或取不到时为false...]]></content>
      <tags>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复选框全选和取消全选问题]]></title>
    <url>%2Fjquery%2F%E5%A4%8D%E9%80%89%E6%A1%86%E5%85%A8%E9%80%89%E5%8F%96%E6%B6%88%E5%85%A8%E9%80%89%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[结构如下123456全选：&lt;input type="text" class="choiceAll"&gt;北京：&lt;input type="text" class="choiceSingle"&gt;上海：&lt;input type="text" class="choiceSingle"&gt;广州：&lt;input type="text" class="choiceSingle"&gt;深圳：&lt;input type="text" class="choiceSingle"&gt; 最初想到的解决办法：12345678910111213141516$(&apos;.choiceAll&apos;).on(&apos;click&apos;, function () &#123; if ($(this).is(&quot;:checked&quot;)) &#123; toChoiceAll(); &#125; else &#123; toCancelChoiceAll(); &#125;&#125;);// 全选var toChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).(&quot;checked&quot;, true);&#125;;// 取消全选var toCancelChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).(&quot;checked&quot;, false); // 或 $(&quot;.choiceSingle&quot;).removeAttr(&quot;checked&quot;);&#125;; 测试的时候我们会发现，第一次全选和取消全选是OK的，但是第二次后会出问题，观察dom，发现第二次全选之后，每个自己复选框的checked确实是移除了，但是页面却没有及时更新，这个时候我们需要遍历每一个然后再处理 正确的处理方法：1234567891011121314151617181920212223242526272829303132333435// 点击全选复选框$(&apos;.choiceAll&apos;).on(&apos;click&apos;, function () &#123; if ($(this).is(&quot;:checked&quot;)) &#123; toChoiceAll(); &#125; else &#123; toCancelChoiceAll(); &#125;&#125;);// 全选var toChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).each(function()&#123; $(this).prop(&quot;checked&quot;, true); &#125;);&#125;;// 取消全选var toCancelChoiceAll = function () &#123; $(&quot;.choiceSingle&quot;).each(function()&#123; $(this).prop(&quot;checked&quot;, false); &#125;);&#125;;// 点击批量退款按钮$(&apos;#refundBtn&apos;).on(&apos;click&apos;, function (event) &#123; // 下面增加了一个收集子级（其他页面结构）中的某个id值 var checkNode = $(&apos;.choiceSingle&apos;); var idNode = $(&apos;.refundId&apos;); var checkedList = []; for (var i = 0, len = idNode.length; i &lt; len; i++) &#123; if (checkNode.eq(i).is(&quot;:checked&quot;)) &#123; checkedList.push(idNode.eq(i).text()); &#125; &#125; if (checkedList.length === 0) return false; // 用checkedList发起请求 // ...&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发devtools]]></title>
    <url>%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91devtools.html</url>
    <content type="text"><![CDATA[来源：eruda CDN:https://cdn.bootcss.com/eruda/1.2.6/eruda.min.js 用法：1234567891011121314151617181920212223&lt;script src="https://cdn.bootcss.com/eruda/1.2.6/eruda.min.js"&gt;&lt;/script&gt;&lt;script&gt; window.eruda.init(); // 自定义显示面板，默认全显示 // window.eruda.init(&#123; // tool: ['console', 'element'] // &#125;);&lt;/script&gt;&lt;script&gt; // test console.log('11111'); var obj = &#123; a: '1', b: '2', c: '3' &#125;; console.log(obj); console.dir(obj); window.localStorage.setItem('a', '123');&lt;/script&gt; DEMO: 非常感谢liriliri提供的eruda工具，非常赞 相同功能的工具：Tencent vConsole]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断对象object中存在某个key]]></title>
    <url>%2Fjavascript%2F%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AAkey.html</url>
    <content type="text"><![CDATA[判断某个object中是否存在某个key，此处不作value真实值判断，key存在即可。 12345678910var obj = &#123; a: &quot;Jack&quot;, b: &quot;Mark&quot;, methodA: function () &#123; &#125;, methodB: function () &#123; &#125;&#125; 直接取key（返回vlaue/undefined） 1234567if (obj &amp;&amp; obj.a) &#123; // 存在的处理&#125;if (obj &amp;&amp; obj.methodA) &#123; // 存在的处理&#125; []取值（返回value/undefined） 1234567if (obj &amp;&amp; obj["a"]) &#123; // 存在的处理&#125;if (obj &amp;&amp; obj["methodA"]) &#123; // 存在的处理&#125; in 关键字（返回true/false） 1234567if (obj &amp;&amp; "a" in obj) &#123; // 存在的处理&#125;if (obj &amp;&amp; "methodA" in obj) &#123; // 存在的处理&#125; hasOwnProperty判断属性是否存在（返回true/false） 1234567if (obj &amp;&amp; obj.hasOwnProperty("a")) &#123; // 存在的处理&#125;if (obj &amp;&amp; obj.hasOwnProperty("methodA")) &#123; // 存在的处理&#125; 注：方法1和方法2通过取值的方式不够稳妥，假如改key的真实取值就是undefined，那么便会出问题，方法3和方法4比较靠谱。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery上传excel等文件]]></title>
    <url>%2Fjquery%2Fjquery%E4%B8%8A%E4%BC%A0excel%E7%AD%89%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[在实际应用中，有时我们需要将一个excel表上传给后端同学进行数据传递，那么怎么实现呢？ FormData对象法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .test-form&#123; display: inline-block; &#125; .show-name&#123; display: inline-block; width: 200px; height: 36px; line-height: 36px; padding: 0 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; border: 1px solid #ccc; vertical-align: middle; &#125; .submit-btn&#123; display: inline-block; width: 80px; height: 36px; border: none; outline: none; vertical-align: middle; font-size: 16px; &#125; .show-error&#123; display: inline-block; height: 36px; line-height: 36px; color: #f00; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;label&gt; &lt;input type="file" id="testInput" accept=".xls, .xlsx" style="left:-9999px;position:absolute;"&gt; &lt;span class="show-name" id="showName"&gt;请选择你要上传的文件&lt;/span&gt; &lt;/label&gt; &lt;button class="submit-btn" id="submitBtn"&gt;上传&lt;/button&gt; &lt;span class="show-error" id="showError"&gt;&lt;/span&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.2.3/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; _fileUpload(); $('#submitBtn').on('click', function (event) &#123; var fileInput = $("#testInput"); var errorText = $('#showError'); if (fileInput.val() === '') &#123; errorText.show().text('对不起，您还没有上传文件'); return false; &#125; var formData = new FormData(); // new FormData对象 var file = fileInput[0].files[0]; // 此处必须这样去到file对象 formData.append('importTeacher', file); $.ajax(&#123; url: "/test.vpage", type: "POST", data: formData, processData: false, // 此处必须设置processData contentType: false, // 此处必须设置contentType async: true, timeout: 5 * 60 * 1000, success: function (data) &#123; if (data.success) &#123; window.alert('上传成功'); &#125; else &#123; errorText.show().text(data.info); &#125; &#125; &#125;) &#125;); function _fileUpload () &#123; $(document).on("change", '#testInput', function () &#123; $('#showError').hide().text(''); var fileInput = $('#testInput').val(); fileInput = fileInput.substring(fileInput.lastIndexOf("\\") + 1); $('#showName').text(fileInput); &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 温馨提示：FormData()在IE8下会有兼容性 结果图例： 参考：web上传的几种方式]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取form表单的文件名]]></title>
    <url>%2Fjquery%2F%E8%8E%B7%E5%8F%96form%E8%A1%A8%E5%8D%95%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D.html</url>
    <content type="text"><![CDATA[正则法取文件名上传后input的value值为：”C:\fakepath\工作簿1.xlsx”这种格式 1$('#testInput').val().substring($('#testInput').val().lastIndexOf("\\") + 1) // 第一个表示转义符号]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等宽数字字体]]></title>
    <url>%2Fcss%2F%E7%AD%89%E5%AE%BD%E6%95%B0%E5%AD%97%E5%AD%97%E4%BD%93.html</url>
    <content type="text"><![CDATA[对于变化的数字来说，每个数字的宽度会直接影响视觉上是否有颤动的效果。 如在进行倒计时时，12:59:59 和 12:11:11 ，由于数字1的默认宽度会比数字5和9等要小，所以倒计时的时候数字的位置可能会时刻变化，对于有明显参照的背景来说，这种抖动的效果是不好的，所以设置等宽数字是有必要的。 设置下面这个字体即可解决1font-family: TrebuchetMS,Rotobo,&quot;Microsoft YaHei&quot;,sans-serif;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knockout使用script内嵌模板]]></title>
    <url>%2Fknockout%2Fknockout%E4%BD%BF%E7%94%A8script%E5%86%85%E5%B5%8C%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"></content>
      <tags>
        <tag>KnockOut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knockout模板绑定和控制语法]]></title>
    <url>%2Fknockout%2Fknockout%E6%A8%A1%E6%9D%BF%E7%BB%91%E5%AE%9A%E5%92%8C%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[常见方法text123name(&apos;哈哈&apos;);&lt;p data-bind=&quot;text: name&quot;&gt;&lt;/p&gt; html123errorText(&apos;第1行有name错误&lt;br&gt;第二行有id不匹配&apos;);&lt;p data-bind=&quot;html: errorText&quot;&gt;&lt;/p&gt; visible123isShow(true);&lt;div data-bind=&quot;visible: isShow&quot;&gt;哈哈，看见我了&lt;/div&gt; if1234567891011写法1：isShow(true);&lt;div data-bind=&quot;if: isShow&quot;&gt;哈哈，看见我了&lt;/div&gt;写法2：isShow(false);&lt;!-- ko if:isShow --&gt;&lt;div&gt;哈哈，看见我了&lt;/div&gt;&lt;!-- /ko --&gt; ifnot字面意思，if取反 if和visible的区别if不显示时dom不存在，visible存在 css(class)123profitWarning(-50);&lt;div data-bind=&quot;css: &#123;profitWarning: currentProfit() &lt; 0&#125;&quot;&gt;&lt;/div&gt; style123profitWarning(-50);&lt;div data-bind=&quot;style: &#123;color: currentProfit() &lt; 0 ? &apos;red&apos; : &apos;black&apos;, fontWeight: isSevere() ? &apos;bold&apos; : &apos;&apos;&#125;&quot;&gt;&lt;/div&gt; attr1234url(&apos;http://www.****&apos;);detail(&apos;我是title&apos;);&lt;a href=&quot;&quot; data-bind=&quot;attr: &#123;href: url, title: details&#125;&quot;&gt;&lt;/a&gt; foreachforeach遍历简单数组1234567891011&lt;ul data-bind=&quot;foreach: months&quot;&gt; &lt;li&gt; The current item is: &lt;b data-bind=&quot;text: $data&quot;&gt;&lt;/b&gt; &lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; months: [ &apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;etc&apos; ] &#125;);&lt;/script&gt; foreach遍历复杂数组123456789101112131415161718192021222324252627282930313233343536373839&lt;div data-bind=&quot;foreach: teacherList&quot;&gt; &lt;p&gt; 索引:&lt;span data-bind=&quot;text: $index&quot;&gt;&lt;/span&gt; teacherID:&lt;span data-bind=&quot;text: teacheId&quot;&gt;&lt;/span&gt; teacherName:&lt;span data-bind=&quot;text: teacheName&quot;&gt;&lt;/span&gt; &lt;button data-bind=&quot;click: $parent.removeMe&quot;&gt;删除&lt;/button&gt; &lt;/p&gt; &lt;button data-bind=&quot;click: addOne&quot;&gt;增加&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function AppViewModel() &#123; var self = this; self.teacherList([ &#123; teacheId: &apos;001&apos;, teacheName: &apos;哈哈&apos; &#125;, &#123; teacheId: &apos;002&apos;, teacheName: &apos;嘻嘻&apos; &#125;, &#123; teacheId: &apos;003&apos;, teacheName: &apos;呵呵&apos; &#125; ]); self.removeMe = function () &#123; self.teacherList.remove(this); &#125;; self.addOne = function () &#123; self.teacherList.push(&#123; teacheId: &apos;004&apos;, teacheName: &apos;喔喔&apos; &#125;) &#125; &#125; ko.applyBindings(new AppViewModel());&lt;/script&gt; foreach注释语法123456789101112&lt;ul&gt; &lt;li class=&quot;header&quot;&gt;Header item&lt;/li&gt; &lt;!-- ko foreach: myItems --&gt; &lt;li&gt;Item &lt;span data-bind=&quot;text: $data&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;!-- /ko --&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; myItems: [ &apos;A&apos;, &apos;B&apos;, &apos;C&apos; ] &#125;);&lt;/script&gt; with控制流wtih正常写法1234567891011121314151617当父级是ko对象，子级是非ko对象，在模板中我们不能直接查找子级a().b()，这样是不OK得，我们可以借助with语法实现这种情况的渲染，父级with:a()，然后就可以直接使用子级了&lt;h1 data-bind=&quot;text: city&quot;&gt; &lt;/h1&gt;&lt;p data-bind=&quot;with: coords&quot;&gt; Latitude: &lt;span data-bind=&quot;text: latitude&quot;&gt; &lt;/span&gt;, Longitude: &lt;span data-bind=&quot;text: longitude&quot;&gt; &lt;/span&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; city: &quot;London&quot;, coords: &#123; latitude: 51.5001524, longitude: -0.1262362 &#125; &#125;);&lt;/script&gt; with注释写法1234567891011121314151617181920&lt;ul&gt; &lt;li&gt;Header element&lt;/li&gt; &lt;!-- ko with: outboundFlight --&gt; &lt;div data-bind=&quot;text: outsize&quot;&gt;&lt;/div&gt; &lt;!-- /ko --&gt; &lt;!-- ko with: inboundFlight --&gt; &lt;div data-bind=&quot;text: insize&quot;&gt;&lt;/div&gt; &lt;!-- /ko --&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; ko.applyBindings(&#123; outboundFlight: &#123; outsize: 51.5001524 &#125;, inboundFlight: &#123; insize: 32.2323423 &#125; &#125;);&lt;/script&gt; form场景click123456789101112写法1：渲染时执行&lt;button data-bind=&quot;click: clickBtn&quot;&gt;&lt;/button&gt;写法2：带bind，不触发不执行&lt;button data-bind=&quot;click: clickBtn.bind($data)&quot;&gt;&lt;/button&gt;注意：点击方法前可能得加$root、$parent等前缀，示层级而定也可以将点击事件包装起来：写法3：&lt;button data-bind=&quot;click: function(data, event) &#123; myFunction(&apos;param1&apos;, &apos;param2&apos;, data, event) &#125;&quot;&gt;&lt;/button&gt; event表单事件123456789101112131415161718192021&lt;div&gt; &lt;div data-bind=&quot;event: &#123; mouseover: enableDetails, mouseout: disableDetails &#125;&quot;&gt; Mouse over me &lt;/div&gt; &lt;div data-bind=&quot;visible: detailsEnabled&quot;&gt; Details &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; detailsEnabled: ko.observable(false), enableDetails: function() &#123; this.detailsEnabled(true); &#125;, disableDetails: function() &#123; this.detailsEnabled(false); &#125; &#125;; ko.applyBindings(viewModel);&lt;/script&gt; submit表单提交123456789101112&lt;form data-bind=&quot;submit: doSomething&quot;&gt; ... form contents go here ... &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; doSomething : function(formElement) &#123; // ... now do something &#125; &#125;;&lt;/script&gt; enable or disable表单禁用123456789101112131415&lt;p&gt; &lt;input type=&apos;checkbox&apos; data-bind=&quot;checked: hasCellphone&quot; /&gt; I have a cellphone&lt;/p&gt;&lt;p&gt; Your cellphone number: &lt;input type=&apos;text&apos; data-bind=&quot;value: cellphoneNumber, enable: hasCellphone&quot; /&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; hasCellphone : ko.observable(false), cellphoneNumber: &quot;&quot; &#125;;&lt;/script&gt; value or textInput表单输入1234567891011textInput同value的性质是一致的，但是textInput是在view改变之后，model立即改变，达到即时更新。&lt;p&gt;Login name: &lt;input data-bind=&quot;value: userName&quot; /&gt;&lt;/p&gt;&lt;p&gt;Password: &lt;input type=&quot;password&quot; data-bind=&quot;value: userPassword&quot; /&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; userName: ko.observable(&quot;&quot;), // Initially blank userPassword: ko.observable(&quot;abc&quot;), // Prepopulate &#125;;&lt;/script&gt; hasFocus表单聚焦123456789101112131415判断表单是否激活，处理不同情况，可点击按钮手动触发激活输入框&lt;input data-bind=&quot;hasFocus: isSelected&quot; /&gt;&lt;button data-bind=&quot;click: setIsSelected&quot;&gt;Focus programmatically&lt;/button&gt;&lt;span data-bind=&quot;visible: isSelected&quot;&gt;The textbox has focus&lt;/span&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; isSelected: ko.observable(false), setIsSelected: function() &#123; this.isSelected(true) &#125; &#125;; ko.applyBindings(viewModel);&lt;/script&gt; checked单选框复选框被选中1234567891011根据变量来控制复选框的选中与否&lt;p&gt;Send me spam: &lt;input type=&quot;checkbox&quot; data-bind=&quot;checked: wantsSpam&quot; /&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; wantsSpam: ko.observable(true) // Initially checked &#125;; // ... then later ... viewModel.wantsSpam(false); // The checkbox becomes unchecked&lt;/script&gt; select option下拉框简单遍历-单选1234567891011121314&lt;p&gt; Destination country: &lt;select data-bind=&quot;options: availableCountries&quot;&gt;&lt;/select&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; // These are the initial options availableCountries: ko.observableArray([&apos;France&apos;, &apos;Germany&apos;, &apos;Spain&apos;]) &#125;; // ... then later ... viewModel.availableCountries.push(&apos;China&apos;); // Adds another option&lt;/script&gt; 简单遍历-多选12345678910&lt;p&gt; Choose some countries you would like to visit: &lt;select data-bind=&quot;options: availableCountries&quot; size=&quot;5&quot; multiple=&quot;true&quot;&gt;&lt;/select&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; availableCountries: ko.observableArray([&apos;France&apos;, &apos;Germany&apos;, &apos;Spain&apos;]) &#125;;&lt;/script&gt; 复杂遍历123456789101112131415161718192021222324252627282930313233343536373839options: 表示遍历的数组项，如果层级很深，可以在外层考虑绑定with，实现简化层级optionsText: 下拉框展示的文案，及数组中某一项的某个字段value: 当前文案optionsCaption: 默认显示的文案，改默认文案不对应任何值event-change: 下拉框触发改变&lt;p&gt; Your country: &lt;select data-bind=&quot;options: availableCountries, optionsText: &apos;countryName&apos;, value: selectedCountry, optionsCaption: &apos;Choose...&apos;, event: &#123;change: selectChange&#125;&quot;&gt;&lt;/select&gt;&lt;/p&gt; &lt;div data-bind=&quot;visible: selectedCountry&quot;&gt; &lt;!-- Appears when you select something --&gt; You have chosen a country with population &lt;span data-bind=&quot;text: selectedCountry() ? selectedCountry().countryPopulation : &apos;unknown&apos;&quot;&gt;&lt;/span&gt;.&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // Constructor for an object with two properties var Country = function(name, population) &#123; this.countryName = name; this.countryPopulation = population; &#125;; var viewModel = &#123; availableCountries : ko.observableArray([ new Country(&quot;UK&quot;, 65000000), new Country(&quot;USA&quot;, 320000000), new Country(&quot;Sweden&quot;, 29000000) ]), selectedCountry : ko.observable(), // Nothing selected by default selectChange: function () &#123; alert(&apos;下拉框变化了&apos;); &#125; &#125;;&lt;/script&gt; 多级下拉框123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131对于像三级城市列表那种的下拉框，每一个下拉框的改变都需要刷新下一个下拉框或页面的数据，select之间必须联动，此例我故意将城市数据层级设置城多级&lt;p data-bind=&quot;text: para()&quot;&gt;&lt;/p&gt;&lt;!-- ko with:bigData().smallData --&gt; &lt;select data-bind=&quot;options: provinces, optionsText: &apos;provinceName&apos;, value: $root.firstValue, optionsCaption: &apos;选择省份&apos;, event: &#123;change: firstSelectChange&#125;&quot;&gt;&lt;/select&gt;&lt;!-- /ko --&gt;&lt;!-- ko with: $root.firstValue --&gt; &lt;select data-bind=&quot;options: citys, optionsText: &apos;cityName&apos;, value: $root.secondValue, optionsCaption: &apos;选择城市&apos;, event: &#123;change: secondSelectChange&#125;&quot;&gt;&lt;/select&gt;&lt;!-- /ko --&gt; &lt;!-- ko with: $root.secondValue --&gt; &lt;select data-bind=&quot;options: countys, optionsText: &apos;countyName&apos;, value: $root.thirdValue, optionsCaption: &apos;选择地区&apos;, event: &#123;change: thirdSelectChange&#125;&quot;&gt;&lt;/select&gt;&lt;!-- /ko --&gt;&lt;button data-bind=&quot;click: commit&quot;&gt;提交&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; var viewModel = &#123; para: ko.observable(&apos;没错，我就是那个动态标题！&apos;), bigData: ko.observable(&#123; smallData: &#123; provinces: [ &#123; provinceId: &apos;010000&apos;, provinceName: &apos;北京&apos;, citys: [ &#123; cityId: &apos;010100&apos;, cityName: &apos;北京市&apos;, countys: [ &#123; countyId: &apos;010101&apos;, countyName: &apos;东城区&apos; &#125;, &#123; countyId: &apos;010102&apos;, countyName: &apos;西城区&apos; &#125; ] &#125; ] &#125;, &#123; provinceId: &apos;090000&apos;, provinceName: &apos;江西省&apos;, citys: [ &#123; cityId: &apos;090100&apos;, cityName: &apos;南昌市&apos;, countys: [ &#123; countyId: &apos;090101&apos;, countyName: &apos;东湖区&apos; &#125;, &#123; countyId: &apos;090102&apos;, countyName: &apos;西湖区&apos; &#125; ] &#125;, &#123; cityId: &apos;090200&apos;, cityName: &apos;九江市&apos;, countys: [ &#123; countyId: &apos;090201&apos;, countyName: &apos;浔阳区&apos; &#125; ] &#125;, &#123; cityId: &apos;090300&apos;, cityName: &apos;景德镇市&apos;, countys: [ &#123; countyId: &apos;090201&apos;, countyName: &apos;珠江区&apos; &#125; ] &#125; ] &#125; ] &#125; &#125;), firstValue: ko.observable(&apos;&apos;), secondValue: ko.observable(&apos;&apos;), thirdValue: ko.observable(&apos;&apos;) &#125;; var firstSelectChange = function () &#123; window.alert(&apos;点击了1号下拉框&apos;); &#125;; var secondSelectChange = function () &#123; window.alert(&apos;点击了2号下拉框&apos;); &#125;; var thirdSelectChange = function () &#123; window.alert(&apos;点击了3号下拉框&apos;); &#125;; var commit = function () &#123; window.alert(&apos;我选择了：&apos; + viewModel.firstValue().provinceName + &apos;--&apos; + viewModel.secondValue().cityName + &apos;--&apos; + viewModel.thirdValue().countyName); &#125;; // 初始化数据（如果不加初始化数据，默认只出现第一个下拉框，选择后出现第二个，再选择出现第三个） for (var i in viewModel.bigData().smallData.provinces) &#123; if (viewModel.bigData().smallData.provinces[i].provinceId === &apos;010000&apos;) &#123; viewModel.firstValue(viewModel.bigData().smallData.provinces[i]); // break; &#125; for (var j in viewModel.bigData().smallData.provinces[i].citys) &#123; if (viewModel.bigData().smallData.provinces[i].citys[j].cityId === &apos;010100&apos;) &#123; viewModel.secondValue(viewModel.bigData().smallData.provinces[i].citys[j]); // break; &#125; &#125; &#125; ko.applyBindings(viewModel);&lt;/script&gt;]]></content>
      <tags>
        <tag>KnockOut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[knockout初始化]]></title>
    <url>%2Fknockout%2Fknockout%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[KnockOut是一个优秀的MVVM JavaScript库，由微软提出。虽然语法相较于目前市面上的Vue、React稍稍落后，但是好在兼容性极好，兼容到IE6，是一些兼容性要求高的开发首选。 KnockOut官方文档：http://knockoutjs.com/index.htmlCDN:https://cdn.bootcss.com/knockout/3.4.2/knockout-min.js demo1(变量式绑定)12345&lt;h3&gt;1、变量式绑定&lt;/h3&gt;&lt;p&gt;First Name : &lt;span data-bind="text: firstName1"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;span data-bind="text: lastName1"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: firstName1" /&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: lastName1" /&gt;&lt;/p&gt; 123456789101112var viewmodel1 = &#123; // 单向绑定 // firstName: 'John1', // lastName: 'Pei1' // 双向绑定 firstName1: ko.observable('John1'), lastName1: ko.observable('Pei1')&#125;// 开始绑定ko.applyBindings(viewmodel1); demo2(函数式绑定)12345&lt;h3&gt;1、变量式绑定&lt;/h3&gt;&lt;p&gt;First Name : &lt;span data-bind="text: firstName2"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;span data-bind="text: lastName2"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: firstName2" /&gt;&lt;/p&gt;&lt;p&gt;Last Name : &lt;input data-bind="value: lastName2" /&gt;&lt;/p&gt; 12345678function viewModel2() &#123; // this.firstName2 = 'John2' // this.lastName2 = 'Pei2' this.firstName2 = ko.observable('John2'); this.lastName2 = ko.observable('Pei2');&#125;ko.applyBindings(viewModel2());]]></content>
      <tags>
        <tag>KnockOut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a标签同时使用target_blank和javascrip_void后造成的IE跳转空包页的bug]]></title>
    <url>%2Fhtml%2Fa%E6%A0%87%E7%AD%BE%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8target_blank%E5%92%8Cjavascrip_void%E5%90%8E%E9%80%A0%E6%88%90%E7%9A%84IE%E8%B7%B3%E8%BD%AC%E7%A9%BA%E7%99%BD%E9%A1%B5%E7%9A%84bug.html</url>
    <content type="text"><![CDATA[在项目中有个位置的点击a标签这里要加一个权限判断，但是之前使用的是js动态添加a标签，href的属性值是一个url，但是我要做权限判断之后，我的url就不能设置在href属性中了，这样的话我可以在a标签里面新增一个属性来放置url的值，然后把href属性改为“javascript:void(0)”，这样使得点击的时候不会有任何操作，但是我改了之后还是会打开一个空白页面，后来找了一下发现是后面的target=“_blank”这个没有去掉，把这个去掉之后问题就解决了。 原文：http://www.cnblogs.com/wgl1995/p/6392991.html]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取不定key的对象的key值和value值]]></title>
    <url>%2Fjavascript%2Fjs%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%AE%9Akey%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84key%E5%80%BC%E5%92%8Cvalue%E5%80%BC.html</url>
    <content type="text"><![CDATA[对于已经固定key的对象，我们很容易可以去到它对应的value值，但有时候拿到的是不定key的对象，这个时候该怎么取 如：123456var array=[ &#123;&apos;50026460&apos;: &apos;童装&apos;&#125;, &#123;&apos;50022517&apos;: &apos;男装&apos;&#125;, &#123;&apos;50022620&apos;: &apos;女装&apos;&#125;, &#123;&apos;50022740&apos;: &apos;孕妇装&apos;&#125;]; 可以使用Object.keys方法来处理 获取key值：12345for(var i=0;i&lt;array.length;i++)&#123; var item=array[i]; var key=Object.keys(item); console.log(key);&#125; 获取value值：12345for(var i=0;i&lt;array.length;i++)&#123; var item=array[i]; var key=Object.keys(item); console.log(item[key]);&#125; 最后吐槽一下，这种数据结构有些不太合理，实际应用中应当减少使用这种数据结构。 理想的数据结构应该是这种：123456var array=[ &#123;id: &apos;50026460&apos;, name: &apos;童装&apos;&#125;, &#123;id: &apos;50022517&apos;, name: &apos;男装&apos;&#125;, &#123;id: &apos;50022620&apos;, name: &apos;女装&apos;&#125;, &#123;id: &apos;50022740&apos;, name: &apos;孕妇装&apos;&#125;];]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取select的值]]></title>
    <url>%2Fjquery%2Fjquery%E8%8E%B7%E5%8F%96select%E7%9A%84%E5%80%BC.html</url>
    <content type="text"><![CDATA[js方法获取：1234var obj = document.getElementById(&quot;testSelect&quot;); //定位idvar index = obj.selectedIndex; // 选中索引var text = obj.options[index].text; // 选中文本var value = obj.options[index].value; // 选中值 jquery方法获取：123456$(&apos;#testSelect option:selected&apos;).text();//选中的文本$(&apos;#testSelect option:selected&apos;) .val();//选中的值$(&quot;#testSelect&quot;).get(0).selectedIndex;//索引$(&apos;#testSelect&apos;).text();//选中的文本$(&apos;#testSelect&apos;).find(&apos;option:selected&apos;).val();//选中的值]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js转换UTC时间戳]]></title>
    <url>%2Fjavascript%2Fjs%E8%BD%AC%E6%8D%A2UTC%E6%97%B6%E9%97%B4%E6%88%B3.html</url>
    <content type="text"><![CDATA[有时候前端会收到后端返回的时间格式是UTC时间戳格式的，但是他们又不愿意修改，将工作丢给前端，累觉不爱。 我们可以引入一个moment.js插件来快速处理时间格式，但是有时候我们不太方便去引入一个脚本，我们可以使用js来解析它： 转换成年月日12345678// UTC时间戳转换成年月日(2017-08-01)function resolveUTCDate (utcData) &#123; var myDate = new Date(utcData); var year = myDate.getYear(); var month = (&apos;0&apos; + (myDate.getMonth() + 1)).slice(-2); var day = (&apos;0&apos; + myDate.getDate()).slice(-2); return year + &apos;-&apos; + month + &apos;-&apos; + day;&#125; 转换成时分秒12345678// UTC时间戳转换成时分秒(08:08:08)function resolveUTCTime(utcTime) &#123; var myDate = new Date(utcTime); var hours = (&apos;0&apos; + myDate.getHours()).slice(-2); var minutes = (&apos;0&apos; + myDate.getMinutes()).slice(-2); var seconds = (&apos;0&apos; + myDate.getSeconds()).slice(-2); return hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历数据根据条件删除数组元素]]></title>
    <url>%2Fjavascript%2Fjs%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0.html</url>
    <content type="text"><![CDATA[有时，我们会有这样一个需求，当我们从后端取到一个list数组时，我们需要进行二次处理，处理成我们需要的数据，如： 1234567891011121314151617181920212223242526272829var arr = [ &#123; status:0 &#125;, &#123; status:1 &#125;, &#123; status:0 &#125;, &#123; status:0 &#125;, &#123; status:3 &#125;, &#123; status:0 &#125;, &#123; status:7 &#125;, &#123; status:0 &#125;, &#123; status:2 &#125;]; 遍历上面的数组，删除status=0的项，我们很容易想到，先for循环（或forEach、map等）遍历，然后使用array的splice方法删除指定索引未知的项。 但在操作之后，我们发现，当我们删除一个之后索引值会变化，这就造成只能删除第一个。我们发现，for循环遍历时，遍历一次，i加1，那我们可以这样当执行splice删除的时候，我们不让i+1，否则才递增。该如何实现呢？ 123456789for(var i=0, flag=true, len=arr.length; i&lt;len; flag ? i++ : i)&#123; if( arr[i] &amp;&amp; arr[i].status==0 )&#123; arr.splice(i, 1); flag = false; &#125; else &#123; flag = true; &#125;&#125;console.log(arr); 这种做法效率非常高，值得推荐。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决checkbox复选框点击label会触发两次的bug]]></title>
    <url>%2Fjavascript%2F%E8%A7%A3%E5%86%B3checkbox%E5%A4%8D%E9%80%89%E6%A1%86%E7%82%B9%E5%87%BBlabel%E8%A7%A6%E5%8F%91%E4%B8%A4%E6%AC%A1bug.html</url>
    <content type="text"><![CDATA[通常我们使用checkbox的时候都会增加一个label帮助点击，如1234&lt;div id=&quot;box&quot; @click=&quot;selectCheckbox($event)&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;label for=&quot;&quot;&gt;click checkbox&lt;/label&gt;&lt;/div&gt; 点击当我们需要js去处理相应的点击事件时，我们会发现点击checkbox复选框本身并无问题，但是点击label时会发生事件冒泡触发两次的bug，解决办法： 1、去除label，呵呵，没意思 2、点击div的时候，判断事件源，忽略label事件源12345678910111213141516171819selectCheckbox: function selectCheckbox (event) &#123; // 根据事件源阻止label事件会触发两次的bug var ev = event || window.event; var eTarget = ev.target || ev.srcElement; if (!$(eTarget).is('input')) return false; // 正常处理 // 判断是否选中 var isSelect = $('#box').find('input').is(":checked"); // var isSelect = $('#box').find('input').prop("checked"); if (isSelect) &#123; // 如果是勾选 console.log('勾选'); // request &#125; else &#123; // 如果是去除 console.log('去除'); // request &#125;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webview页面js与客户端进行交互]]></title>
    <url>%2Fjavascript%2Fwebview%E9%A1%B5%E9%9D%A2js%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92.html</url>
    <content type="text"><![CDATA[有时我们需要开发一些页面放在爱啪啪内，我们称之为webview页面，既然是在爱啪啪内，就有可能与客户端进行一些常见的交互，如调用客户端的一些方法 我们可以做： 新建jsbridge.js，这样做的理由是将所有的jsbridge放置在此文件中，便于后期维护 下面是一些常用的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const ua = window.navigator.userAgentconst isIOS = /iphone/i.test(ua)const TAG = 'jlhb'// ios bridgefunction connectBridge (callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(window.WebViewJavascriptBridge) &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback) &#125; window.WVJBCallbacks = [callback] var WVJBIframe = document.createElement('iframe') WVJBIframe.style.display = 'none' WVJBIframe.src = 'https://__bridge_loaded__' document.documentElement.appendChild(WVJBIframe) setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;// 下载图片,type: 0/相册function downloadImage (imgUrl, type) &#123; isIOS ? connectBridge(bridge =&gt; &#123; bridge.callHandler('downloadImage', imgUrl, type) &#125;) : window.HyhbInteraction.downloadImage(imgUrl, type)&#125;// 分享图片function shareImage (imgUrl) &#123; isIOS ? connectBridge(bridge =&gt; &#123; bridge.callHandler('shareImage', imgUrl) &#125;) : window.HyhbInteraction.shareImage(imgUrl)&#125;// 我的战绩function goRecord (numId) &#123; isIOS ? connectBridge(bridge =&gt; &#123; bridge.callHandler('goRecord', numId) &#125;) : window.HyhbInteraction.goRecord(numId)&#125;// push dataif (isIOS) &#123; // iOS connectBridge(bridge =&gt; &#123; bridge.callHandler('setJpushTags', TAG, (response) =&gt; &#123; &#125;) bridge.registerHandler('pushData', (data) =&gt; &#123; window.pushData(data) &#125;) bridge.registerHandler('setLuckbean', (data) =&gt; &#123; window.setLuckbean(data) // ios在回调中调用index.html下的setLuckbean()方法，安卓会自动查找并调用 &#125;) &#125;)&#125; else &#123; // 安卓 window.HyhbInteraction.setJpushTags(TAG)&#125;export &#123; downloadImage, shareImage, goRecord&#125; 注：HyhbInteraction 是安卓端设置的app的interaction名称]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断安卓版本号]]></title>
    <url>%2Fjavascript%2Fjs%E5%88%A4%E6%96%AD%E5%AE%89%E5%8D%93%E7%89%88%E6%9C%AC%E5%8F%B7.html</url>
    <content type="text"><![CDATA[123var ua = window.navigator.userAgent.toLowerCase();ua.substr(ua.indexOf(&apos;android&apos;) + 8, 3)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现微信语音扬声器播放效果动画]]></title>
    <url>%2Fcss%2F%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%AF%AD%E9%9F%B3%E6%89%AC%E5%A3%B0%E5%99%A8%E6%92%AD%E6%94%BE%E6%95%88%E6%9E%9C%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[效果图如下： 思路：利用一张雪碧图背景图来切换实现动画效果，通过变化图片的background-position来实现背景图的切换，不要使用3张img图片，因为img只能控制图片显示隐藏，动画效果不明显。 雪碧图如下： 具体实现如下：1div.audio-anibox 12345678910111213141516171819202122.audio-anibox&#123; width: r(23); height: r(29); background: url('../assets/audio_ani.png') no-repeat; background-size: r(23) r(87); background-position: 0 r(-58); /* 默认显示第三张 */&#125;.audio-animation &#123; animation: voiceplay 2s infinite step-start;&#125; @keyframes voiceplay&#123; 0%, 100%&#123; background-position: 0 r(-58); &#125; 33.333%&#123; background-position: 0 0; &#125; 66.666%&#123; background-position: 0 r(-29); &#125;&#125; 通过追加class实现效果 参考：http://blog.csdn.net/wowkk/article/details/53582339]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现手机号输入框中间空格效果]]></title>
    <url>%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%85%A5%E6%A1%86%E6%89%8B%E6%9C%BA%E5%8F%B7%E4%B8%AD%E9%97%B4%E7%A9%BA%E6%A0%BC%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[效果如下： 具体实现如下：1&lt;input type="tel" class="phone" v-model="phoneText" @keydown="keyDown" @keyup.delete="keyUp" maxlength="13"&gt; 123456789keyDown (e) &#123; // 按下时判断在指定位置添加空格 if (e.keyCode !== 8 &amp;&amp; (this.phoneText.length === 3 || this.phoneText.length === 8)) &#123; this.phoneText += ' ' &#125;&#125;,keyUp () &#123; // 删除键抬起后清楚结尾空格 // 非vue写法 if (e.keyCode === 8) &#123;&#125; this.phoneText = this.phoneText.replace(/\s*$/g, '')&#125; 如果想要初始化赋值：123this.phoneText = this.phoneText .replace(this.phoneText.substr(2, 1), this.phoneText.substr(2, 1) + &apos; &apos;) .replace(this.phoneText.substr(6, 1), this.phoneText.substr(6, 1) + &apos; &apos;)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Chrome常用快捷键]]></title>
    <url>%2Ftools%2Fwindows-chrome%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[Ctrl + T : 打开新的标签页Ctrl + Shift + T : 打开上一次关闭的标签页Ctrl + W : 关闭当前标签页Ctrl + Shift + W : 关闭所有标签页（关闭浏览器）Ctrl + PgUp : 向左切换标签Ctrl + PgDn : 向右切换标签Ctrl + - : 缩小窗口Ctrl + + : 放大窗口Ctrl + 0 : 回到默认窗口大小Ctrl + R : 刷新页面（F5）Ctrl + U : 查看源码Ctrl + O : 打开文件Ctrl + Shift + O : 打开书签管理器Ctrl + P : 打开打印设备Ctrl + S : 保存网页Ctrl + F/G : 打开搜索Ctrl + H : 打开历史记录Ctrl + J : 当前窗口打开下载中心Ctrl + Shift + T : 新窗口打开下载中心Ctrl + N : 打开新窗口Ctrl + 1 : 打开1号标签，依次类推Ctrl + Shift + I/C : 打开开发者工具（F12）Ctrl + Shift + B : 显示书签/隐藏书签]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Sublime编辑器常用快捷键]]></title>
    <url>%2Ftools%2Fwindows-sublime%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[查找快捷键Ctrl+F: 搜索查找F3: 查找下一个Shift+F3: 查找上一个Ctrl+F3: 快速查找出光标定位的某个元素，连续可查找一个Alt+F3: 快速查找出光标定位的所有元素，查找所有Ctrl+Shift+F: 查找并替换Ctrl+H: 替换Ctrl+G: 跳转到第几行Ctrl+M: 选择当前匹配的括号 关闭快捷键Ctrl+W: 关闭当前打开文件Ctrl+Shift+W: 关闭所有打开文件 注释快捷键Ctrl+/ /: 注释HTMLCtrl+/: 注释当前行Ctrl+Shift+/: 注释段落 选择快捷键Ctrl+D: 选中光标定位的单词，连续可选中下一个Ctrl+L: 选中当前行，连续可选中下一行Ctrl+Enter: 在该行下面增加一行Ctrl+Shift+Enter: 在该行上面增加一行Ctrl+X: 删除当前行Shift+up: 从光标前面开始选择行，连续可选中上一行Shift+down: 从光标后面开始选择行，连续可选中下一行Shift+left: 从光标处连续选择左边的文本Shift+right: 从光标处连续选择右边的文本Ctrl+Shift+up: 选择本行，并向上移动一行Ctrl+Shift+down: 选择本行，并向下移动一行Ctrl+Shift+left: 从光标处连续选择左边的单位Ctrl+Shift+right: 从光标处连续选择右边的单位Ctrl+Alt+up: 向上添加多个光标，可同时输入Ctrl+Alt+down: 向下添加多个贯标，可同时输入 切换标签快捷键Ctrl+PageUp: 向左切换标签页Ctrl+PageDown: 向右切换标签页 插件快捷键代码快速编写(Emmet)： Tab/Ctrl+E语法提示框架(SublimeLinter)：右键菜单增强(SideBarEnhancements)：JS格式化工具(JSFormat)： Ctrl+Alt+FHTML格式化工具(TAG)： Ctrl+Alt+F全局格式化工具(HTML+CSS+JS Prettify): Ctrl+Shift+H颜色选择器(ColorPicker)： Ctrl+Shift+C代码高亮显示(SublimeHighlight)： Edit–Highlight–Convert to HTML（写博客时使用）代码提示工具(BracketHighlighter)： 光标左侧出现提示（提示匹配的括号、引号和标签）代码提示工具(TrailingSpacer)： 光标左侧出现提示（提示多余空格和Tab） Sublime Text3设置F12打开默认浏览器：1.安装SlideBar插件2.用户操作设置123&#123; "default_browser": "chrome"&#125; 3.用户按键设置123456789[&#123; "keys": ["f12"], "command": "side_bar_open_in_browser", "args": &#123; "paths": [], "type": "testing", "browser": "" &#125;&#125;]]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Chrome常用快捷键]]></title>
    <url>%2Ftools%2Fmac-chrome%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[标签页和窗口页Command + N : 新开窗口Command + Shift + N : 隐身模式打开新开窗口Command + Shift + W : 关闭窗口Command + T : 新开标签页Command + W : 关闭标签页Command + Shift + T ： 重新打开上一次关闭的页面（最多10个）Command + Option + Left : 切换到上一个标签页Command + Optionn + Right : 切换到下一个标签页Command + [ 或 Command + Left :切换到上一个历史记录Command + ] : 切换到下一个历史记录Command + O : 打开文件Command + 点击链接 ： 新标签打开链接（仍然在本标签页）Command + Shift + 点击链接 : 新标签打开链接（同时切换到新标签页）Shift + 点击链接 : 新窗口打开链接Command + M : 最小化窗口Command + H : 隐藏当前窗口Command + Option + H : 隐藏所有窗口Command + Q : 关闭浏览器 功能快捷键Command + Shift + B : 显示或关闭书签栏Command + Option + B : 打开书签管理器Command + , : 打开偏好设置Command + Y ： 打开历史记录Command + Shift + J : 打开下载内容Command + Shift + Delete : 打开清楚浏览器数据弹窗 地址栏Option + L : 选中地址栏 网页快捷键Command + P : 打印当前网页Command + R : 刷新页面Command + F : 开启查找功能Command + G 或 Enter : 查找下一个Command + Shift + G 或 Shift + Enter : 查找上一个Command + E : 查找选中的文字Command + Option + J : 打开“JavaScript”控制台Command + Option + U : 打开源码Option + 点击链接 ： 下载链接目标Option + D : 保存书签Command + 加减 ： 放大或缩小网页Command + 0 : 恢复成默认大小的网页空格键 : 滚动网页]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Sublime常用快捷键]]></title>
    <url>%2Ftools%2Fmac-sublime%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[Command + F ：搜索选中的文字Command + D : 连续搜索选中的文字Command + G ：搜索下一个Command + Shift + G : 搜索上一个Command + Shift + F : 全局查找或替换 Command + Shift + D : 复制并粘贴当前行Command + Control + Up/Down : 上下移动代码Command + Enter : 在当前行下方增加一行Command + Shift + Enter ：在当前行上方增加一行 Command + Left/Right : 光标移动当前行的左侧或右侧Command + Shift + Left/Right : 选中光标所在当前行的左边或右边部分代码Command + Up/Down : 快速移到顶部或底部Command + Shift + Up/Down : 选中光标左上或右下部分代码Command + L : 选中当前一行，连续可选中下一行选中后Command + Shift + L : 在每行尾部产生一个光标，可操控多行 Command + W : 关闭当前窗口Command + Shift + W : 关闭所有窗口，同时关闭sublimeCommand + Option + Left/Right : 左右切换窗口 Command + + / - : 放大或缩小文字Command + Option + Num : 分割几块窗口]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Tmux常用快捷键]]></title>
    <url>%2Ftools%2Fmac-tmux%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[已经把ctrl-b修改成ctrl-a，横向切割和纵向切割也修改成功|和- 修改： vim ~/.tmux.conf修改生效：ctrl-a : source-file ~/.tmux.conf tmux : 启动tmuxctrl-a d : 退出tmux会话 tmux a -t 0 : 启动之前的tmux窗口 ctrl-a , : 重命名窗口名ctrl-a c : 新开窗口(对应的窗口数字：0, 1, 2, 3, …)ctrl-a &amp; : 关闭当前整个窗口ctrl-a num : 切换到指定的窗口(0, 1, 2, 3, …)ctrl-a p : 切换到上一个窗口(循环)ctrl-a n : 切换到下一个窗口(循环)ctrl-a w : 以菜单形式显示所有窗口，再切换窗口 ctrl-a | : 横向切割ctrl-a - : 纵向切割ctrl-a o : 切换到下一个分割窗口(循环)ctrl-a direaction : 上下左右切换分割窗口ctrl-a x : 询问是否关闭当前的分割窗口ctrl-d : 直接关闭当前分割窗口ctrl-a ! : 关闭所有的分割窗口ctrl-a z : 最大化/最小化 当前分割窗口 ctrl-a ? : 显示帮助ctrl-a t : 显示时钟 ctrl-a [ : 开始滚屏，按方向键滚动，q 退出]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 常用快捷键]]></title>
    <url>%2Ftools%2Fmac%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    <content type="text"><![CDATA[基本操作Command-X 剪切（剪切文字）Command-C、Command-Option-V 剪切 粘贴（文件）Command-C 拷贝（相当于windows的复制，MacOS的复制为先拷贝再粘贴两部操作） Command-V 粘贴Command-Option-V 粘贴（删除源文件） Command-Z 撤销Command-Shift-Z 撤销的逆向操作Command-A 全选 Command-S 保存（Save) Command-F 查找（Find）Command-Shift-A 打开当前文件所有的文件夹 截图Command-Shift-3 截取全部屏幕到一个文件（桌面）Command-Shift-4 截取所选屏幕区域到一个文件（桌面）Command-Shift-4,出现相机后按空格，将相机移到需要的窗口上 截取指定的窗口 Command-Shift-Control-3 截取全部屏幕到剪贴板Command-Shift-Control-4 截取所选屏幕区域到剪贴板Command-Shift-Control-4,出现相机后按空格，将相机移到需要的窗口上 截取指定的窗口到剪切板 在应用程序中Command-Option-Esc 打开强制退出窗口 Command-H 隐藏当前正在运行的应用程序窗口 Command-Option-H 隐藏其他应用程序窗口 Command-Q 退出最前面的应用程序 Command-Shift-Z 重做，也就是撤销的逆向操作Command-Tab 在打开的应用程序列表中转到下一个最近使用的应用程 文本处理Command-B 切换所选文字粗体（Bold）显示 fn-Delete 相当于PC全尺寸键盘上的Delete，也就是向后删除fn-Up 向上滚动一页fn-Down 向下滚动一页fn-Left 滚动至文稿开头fn-Right 滚动至文稿末尾 Command-Left 将光标移至当前行的行首 Command-Right 将光标移至当前行的行尾Command-Up 将光标移至文稿开头Command-Down 将光标移至文稿末尾 Option-Left 将光标移至上一个单词的开头Option-Right 将光标移至下一个单词的末尾 Control-A 移至行或段落的开头 在Finder中：Command-Shift-N 新建文件夹 Command-Shift-G 调出窗口，可输入绝对路径直达文件夹（Go） return 点击文件，按下可重命名文件 Command-O 打开所选项 Command-Up 打开包含当前文件夹的文件夹，相当于Windows里的“向上” Command-Delete 将文件移至废纸篓 Command-Shift-Delete 清倒废纸篓 空格键 快速查看选中的文件，也就是预览功能]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础面试题]]></title>
    <url>%2Fother%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[请输入密码：提交 htmlmeta keywords description 含义123&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; description是对网站的描述keywords是一些网站的关键字两者都是便于搜索引擎搜索 移动端meta12345&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5, minimum-scale=0.5,maximum-scale=0.5,user-scalable=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.3333333333333333, minimum-scale=0.3333333333333333,maximum-scale=0.3333333333333333,user-scalable=no&quot;&gt; 在移动端开发时，我们会发现手机的dpr可能都不一致，有些是1，chrome预览器就是1，有些手机是2，有些手机是3，这和手机的retina屏有关，所以我们不能单纯将scale值写死，应该根据dpr的值来设置，即用1.0 / dpr的值。 123456789// 设置viewport属性，安卓4.5以下均设置为1.0，其余通过计算取得var ua = window.navigator.userAgent.toLowerCase();var dpr = window.devicePixelRatio;var scaleValue = 1.0 / dpr;var metaEl = document.createElement(&apos;meta&apos;);metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);if (ua.substr(ua.indexOf(&apos;android&apos;) + 8, 3) &lt; 4.5) metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&apos;);else metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scaleValue + &apos;, maximum-scale=&apos; + scaleValue + &apos;, minimum-scale=&apos; + scaleValue + &apos;, user-scalable=no&apos;);document.getElementsByTagName(&apos;head&apos;)[0].appendChild(metaEl); title和alt的区别title是鼠标hover时显示的提示性文字alt是当图片不显示时显示的文字（alt只给图片使用） csscss权重值!important &gt; 内嵌样式 &gt; id &gt; class &gt; 标签样式 &gt; * css隐藏的方法 display: none;隐藏，脱离文档流，不占据任何位置 visiblity: hidden;隐藏，不脱离文档流，看不见，摸得着，但没有任何事件属性（事件触发） opacity: 0;隐藏，不脱离文档流，看不见，摸得着，有时间属性（事件触发） 盒模型 box-sizing: content-box;默认的盒模型，即指content宽，实际宽度 = connent宽 + padding宽 + border宽 + margin宽 box-sizing: padding-box;即是connent宽 + padding宽，实际宽度 = connent宽 + border宽 + margin宽 box-sizing: border-box;最常用盒模型，即connent宽 + padding宽 + border宽，实际宽度 = connent宽 + margin宽 实际开发中，我们都使用个第三种盒模型，给html设置html{ box-sizing: border-box; }, 其余设置*{ box-sizing: inherit; } 水平垂直居中 postion方法 123456789.outer-div&#123; position: relative;&#125;.inner-div&#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; flex布局方法 123display: flex;justify-content; center;align-items: center; javascriptjs数据类型number、string、boolean、object、function、underfined 常用刷新页面的方法 window.location.href = window.location.href跳转后可返回 widnow.location.repalce()跳转后不能返回，即删除了历史记录 history.go()前进或后退几个页面 localStorage和sessionStorage的区别相同点：都使用setItem(‘abc’, ‘***’)设置数据和getItem(‘abc’)读取数据，且都只能存储字符串，不能直接存储对象不同的：localStorage的有效期是永久，除非用户手动关闭，sessionStorage的有效期是关闭浏览器之前 数组方法 push: 尾部添加 pop: 尾部删除 unshift: 头部添加 shift: 头部删除 splice: 删除或添加 split和join方法 split: 将字符串拆分成数组 join: 将数组组合成字符串 事件冒泡、事件委托 事件冒泡：子级 触发 父级e.stopPropagation() / return false 事件委托：父级 触发 子级$(‘’).click(‘ul’, ‘li’, function () {}) 事件默认行为preventDefault() / return false 数组去重123456789101112131415var myArray = [0, 1, 6, 9, 0, 2, 4, 5, 4];function aaa()&#123; var newArray = []; //一个新的临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 //如果当前数组的第i项已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (newArray.indexOf(myArray[i]) == -1)&#123; //在新数组中查找原数组的每一项是否存在 newArray.push(myArray[i]); //如果不存在就加到新数组中 &#125; &#125; // return newArray; alert("新的数组：" + newArray);&#125;aaa();]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js脚本实现复制剪切效果]]></title>
    <url>%2Fjavascript%2Fjs%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%89%AA%E5%88%87.html</url>
    <content type="text"><![CDATA[参考：https://github.com/cpm828/clipboard.jsCDN:http://cdn.bootcss.com/clipboard.js/1.5.12/clipboard.min.js 1234567data-clipboard-action: 操作行为，默认为copy，剪切为cutdata-clipboard-target: 操作目标，通过标签、id或class号指向data-clipboard-text: 具体文本e.action: 操作名称e.text: 操作的文本e.trigger: dom节点 常用方法： 复制 1234567891011121314151617&lt;p class="para"&gt;123456789&lt;/p&gt;&lt;button class="btn1" data-clipboard-target=".para"&gt;复制&lt;/button&gt;&lt;script&gt;var clipboard1 = new Clipboard('.btn1');clipboard1.on('success', function(e) &#123; console.info('Action:', e.action); // 操作名称 console.info('Text:', e.text); // 操作的文本 console.info('Trigger:', e.trigger); // dom节点 e.clearSelection(); // 取消选中&#125;);clipboard1.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger);&#125;);&lt;/script&gt; 剪切 1234567891011121314151617&lt;input type="text" class="input" value="我就是那个input"&gt;&lt;button class="btn2" data-clipboard-action="cut" data-clipboard-target=".input"&gt;剪切&lt;/button&gt;&lt;script&gt;var clipboard2 = new Clipboard('.btn2');clipboard2.on('success', function(e) &#123; console.info('Action:', e.action); // 操作名称 console.info('Text:', e.text); // 操作的文本 console.info('Trigger:', e.trigger); // dom节点 e.clearSelection(); // 取消选中&#125;);clipboard2.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger);&#125;);&lt;/script&gt; 复制固定文本 123456789101112131415&lt;button class="btn3" data-clipboard-text="我就是那个隐藏的文字"&gt;复制固定数据&lt;/button&gt;&lt;script&gt;var clipboard3 = new Clipboard('.btn3');clipboard3.on('success', function(e) &#123; console.info('Action:', e.action); // 操作名称 console.info('Text:', e.text); // 操作的文本 console.info('Trigger:', e.trigger); // dom节点 e.clearSelection(); // 取消选中&#125;);clipboard3.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger);&#125;);&lt;/script&gt; 动态将目标指向下一个节点 123456789&lt;button class="btn4"&gt;看我如下操作下一个节点&lt;/button&gt;&lt;script&gt;new Clipboard('.btn4', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; // 动态指向下一个节点，及操作下一个节点 &#125;&#125;);&lt;/script&gt; 动态操作属性值 123456789&lt;button class="btn5" aria-label="我用了自己的属性"&gt;看我如何复制我的属性值&lt;/button&gt;&lt;script&gt;new Clipboard('.btn5', &#123; text: function(trigger) &#123; return trigger.getAttribute('aria-label'); // 操作属性值 &#125;&#125;)&lt;/script&gt; 在vue项目中，使用如上方法，ios会有bug，可以安装vue-cliboards组件 参考：https://github.com/cpm828/vue-clipboards 1、安装vue-clipboards1npm install vue-clipboards 2、导入（可放在组件中也可放在main.js中）123import Vue from &apos;vue&apos;import VueClipboards from &apos;vue-clipboards&apos;Vue.user(VueClipboards) 3、使用1234567891011121314151617&lt;button v-clipboard=&quot;copyData&quot; @success=&quot;handleSuccess&quot; @error=&quot;handleError&quot;&gt;Copy&lt;/button&gt;new Vue(&#123; data() &#123; return &#123; copyData: &apos;copy data&apos; &#125; &#125;, methods: &#123; handleSuccess(e) &#123; console.log(e); &#125;, handleError(e) &#123; console.log(e); &#125; &#125;&#125;); 4、说明该组件默认只能绑定一个 解决办法： 4.1 增加:key=”1” 12&lt;button v-clipboard=&quot;copyData1&quot; :key=&quot;1&quot; @success=&quot;handleSuccess&quot; @error=&quot;handleError&quot;&gt;Copy&lt;/button&gt;&lt;button v-clipboard=&quot;copyData2&quot; :key=&quot;2&quot; @success=&quot;handleSuccess&quot; @error=&quot;handleError&quot;&gt;Copy&lt;/button&gt; 具体见：https://github.com/zhuowenli/vue-clipboards/blob/master/example/App.vue#L8 4.2 可以考虑设置一个真实复制的按钮，其他按钮trigger click给这个按钮]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call方法实现跨对象调用方法]]></title>
    <url>%2Fvue%2Fcall%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[在vue的项目开发中，我们知道，在一个组件中，this指向的是当前的组件对象，但是当我们在处理一个大型的项目，而且要调用一些公共的方法或函数，且在函数中又要继续调用下一个函数，例如：组件A中：123456789101112131415161718mounted () &#123; this.funcA&#125;,methods: &#123; funcA () &#123; this.funcB(b) &#125;, funcB (B) &#123; // 一些公共的函数，如支付或js bridge等 this.funcC(c) &#125;, funcC (C) &#123; // 一些公共的函数，如支付或js bridge等 this.funcD(d) &#125;, funcD (D) &#123; &#125;&#125; 在上面的示例中，我们在调用组件A的方法funcA()之后需要连续调用两个外部支持的函数，且之前有参数传递，最后又要调用组件A的方法funcD()，当funcB()和funcC()方法在组件B中也需要调用时，我们如果在组件B中再重复写一套就很麻烦了，所有有些时候，我们需要将一定的方法剥离出去。 可以这样做:组件A中：123456789101112import &#123;funcB, funcC&#125; from '../tools/bridge.js'mounted () &#123; this.funcA&#125;,methods: &#123; funcA () &#123; funcB.call(this, b) // 此处将this对象通过call方法传递给外部函数funcB &#125;, funcD (D) &#123; &#125;&#125; 公共方法bridge.js中：123456789101112funcB (B) &#123; let self = this // 一些公共的函数，如支付或js bridge等 funcC.call(self, c)&#125;funcC (C) &#123; // 一些公共的函数，如支付或js bridge等 self.funcD(d) // 此处通过self指向组件中的funcD&#125;export &#123; funcB, funcC &#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 array方法]]></title>
    <url>%2Fes6%2Fes6-array%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一峰 ES6 Array方法 Array.from()：将两类对象（类似数组的对象和可遍历的对象）转为真正的数组 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法：var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法：let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] Array.of()：将一组值转换成数组 123456789Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1Array.of() // []Array.of(undefined) // [undefined] copyWithin()：将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 Array.prototype.copyWithin(target, start = 0, end = this.length) target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。正从0开始，负从-1开始。 这三个参数都应该是数值，如果不是，会自动转为数值。 1234567891011121314151617181920[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]// 从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2[1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3) // &#123;0: 1, 3: 1, length: 5&#125;// 将3号位复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]); i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5]// 将2号位到数组结束，复制到0号位// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法:[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5] find()：用于找出第一个符合条件的数组成员 1234567[1, 4, -5, 10, -1].find((n) =&gt; n &lt; 0) // -5// 找出数组中第一个小于0的成员，-1布什第一个，不返回。[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10// 找出大于9的，15不是第一个，不返回 findIndex()：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 1234567[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2[NaN].indexOf(NaN) // -1[NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 fill()：使用给定值，填充一个数组 第二个参数（可选）表示替换起始位置，第三个参数（可选），表示结束位置 12345['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] includes()：是否包含指定元素，es7语法，babel转换器已支持 第二个参数可选，表示指定搜索起始位置，从起始位置到结尾，默认为0，负数表示倒数；当大于数组长度，会重置为从0开始 12345678910111213141516171819202122232425262728[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, 3].includes(2, 0); // true[1, 2, 3].includes(2, 1); // true[1, 2, 3].includes(2, 2); // false[1, 2, 3].includes(2, 3); // false[1, 2, 3].includes(2, -1); // false[1, 2, 3].includes(2, -2); // true[1, 2, 3].includes(2, -3); // true[1, 2, 3].includes(2, -4); // true]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ios在增加overflow_hidden时的滑动不流畅问题]]></title>
    <url>%2Fcss%2F%E8%A7%A3%E5%86%B3ios%E5%9C%A8%E5%A2%9E%E5%8A%A0overflow_hidden%E6%97%B6%E7%9A%84%E6%BB%91%E5%8A%A8%E4%B8%8D%E6%B5%81%E7%95%85%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[在移动端html中有时需要使用横向或纵向滑动，我们会增加over:scroll; 但是在ios中，滚动速度会变慢，不流畅，在安卓上没有这种感觉 解决办法：1-webkit-overflow-scrolling : touch; 据说会多消耗内存 但是有了流畅的感觉，who care the memory ^_^]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 string方法]]></title>
    <url>%2Fes6%2Fes6-string%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一峰 ES6 字符串方法 at(): 返回给定字符的位置 12var s = 'Hello world!';s.at(0) // H includes(): 是否包含指定字符串，第二个参数可选，表示起始查找位置 startsWith(): 参数是否在头部，第二个参数可选，表示起始查找位置、 endsWith(): 参数是否在尾部，第二个参数可选，表示起始查找位置 123456789var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // truevar s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false repeat(): 返回重复多次后的字符串 12345678var s = 'Hello's.repeat(3) // HelloHelloHellos.repeat(2.9) // HelloHello，参数为小数时为取整次数s.repeat(Infinity) // 报错s.repeat(-1) // 报错s.repeat(-0.8) // ""，-1~0取整后为0s.repeat("2") // HelloHell0，字符串先转换成数字再取整s.repeat("world") // "" padStart(): 头部补全，第一参数表示字符串长度，第二参数可选，表示替补的字符串，如无，以空格替补 padEnd(): 尾部补全，第一参数表示字符串长度，第二参数可选，表示替补的字符串，如无，以空格替补 123456789101112131415161718var s = 'x's.padStart(5, 'ab') // 'ababx's.padStart(4, 'ab') // 'abax's.padStart(4, 'abcdefg') // 'abcx' ，多余的会被去掉s.padEnd(5, 'ab') // 'xabab's.padEnd(4, 'ab') // 'xaba' s.padEnd(4, 'abcdefg') // 'xabc' ，多余的会被去掉var s = 'xxxx's.padStart(2, 'ab') // 'xxxx'，当设置的字符串长度小于原本长度，返回原字符串s.padEnd(4, 'ab') // 'xxxx' ，当设置的字符串长度小于原本长度，返回原字符串var s = 'x's.padStart(3) // ' x's.padEnd(4) // 'x '常用来补全位数：'10'.padStart(10, '0') // "0000000010" 模板字符串 1234567891011121314传统输出模板：$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); es6输出模板：$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`);]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 number方法]]></title>
    <url>%2Fes6%2Fes6-number%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一锋 ES6 Number方法 进制表示法 二进制：前缀0b（或0B） 1Number('0b111') // 7 八进制：前缀0o（或0O） 1Number('0o10') // 8 Number.isInfinte()：检查一个数值是否为有限的 12345678910111213Number.isFinite(15); // trueNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(NaN); // false，任何非数值都是无限的Number.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false Number.isNan()：检查一个值是否为NaN 12345678910111213Number.isNaN(NaN) // trueNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // false Number.parseInt()：es6保持不变，转换成整型Number.parseFloat()：es6保持不变，转换成浮点型 1234567891011// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 Number.isInteger()：判断一个值是否为整数，js中3和3.0被视为同一个值 123456789Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger("15") // falseNumber.isInteger(true) // false Number.EPSILON()：极小的常量 123Number.EPSILON // 2.220446049250313e-16Number.EPSILON.toFixed(20) // '0.00000000000000022204' 因浮点数运算存在误差，引入一个这么小的常量目的在于为浮点数计算设置一个误差范围 es5中： 123450.1 + 0.2 // 0.300000000000000040.1 + 0.2 - 0.3 // 5.551115123125783e-175.551115123125783e-17.toFixed(20) // '0.00000000000000005551' es6中： 15.551115123125783e-17 &lt; Number.EPSILON // true 1234567function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;withinErrorMargin(0.1 + 0.2, 0.3) // truewithinErrorMargin(0.2 + 0.2, 0.3) // false Number.isSafeInteger()：判断一个整数是否落在这个范围之内这个范围：123456789101112JavaScript能够准确表示的整数范围再-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示es5:```jsMath.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1 // true es6:ES6引入了12345678```jsNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // trueNumber.MAX_SAFE_INTEGER === 9007199254740991 // trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // trueNumber.MIN_SAFE_INTEGER === -9007199254740991 // true 应用： 12345678910111213141516171819202122232425Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见的面试题]]></title>
    <url>%2Fother%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[请输入密码：提交 移动端meta12345&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5, minimum-scale=0.5,maximum-scale=0.5,user-scalable=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.3333333333333333, minimum-scale=0.3333333333333333,maximum-scale=0.3333333333333333,user-scalable=no&quot;&gt; 在移动端开发时，我们会发现手机的dpr可能都不一致，有些是1，chrome预览器就是1，有些手机是2，有些手机是3，这和手机的retina屏有关，所以我们不能单纯将scale值写死，应该根据dpr的值来设置，即用1.0 / dpr的值。 123456789// 设置viewport属性，安卓4.5以下均设置为1.0，其余通过计算取得var ua = window.navigator.userAgent.toLowerCase();var dpr = window.devicePixelRatio;var scaleValue = 1.0 / dpr;var metaEl = document.createElement(&apos;meta&apos;);metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);if (ua.substr(ua.indexOf(&apos;android&apos;) + 8, 3) &lt; 4.5) metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&apos;);else metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scaleValue + &apos;, maximum-scale=&apos; + scaleValue + &apos;, minimum-scale=&apos; + scaleValue + &apos;, user-scalable=no&apos;);document.getElementsByTagName(&apos;head&apos;)[0].appendChild(metaEl); rem单位使用 head区脚本（最重要） 12345678910&lt;script&gt; var html = window.document.documentElement; var sw = html.clientWidth; var sh = html.clientHeight; var rfs = sw * (32 / 640) + 'px'; html.dataset.sw = sw; html.dataset.sh = sh; html.style.fontSize = rfs;&lt;/script&gt; 应用 在css中设置font-size: 设计稿标注字号 / 32 + rem;font-size: 设计稿标注字号 / (设计稿宽 * 0.05) + rem; 在scss中设置 1234@function r($px) &#123; @return $px / 32 + rem; // 32是针对640的设计稿 @return $px / (设计稿宽 * 0.05) + rem; // 其他&#125; 12345div&#123; font-size: r(30); width: r(200); height: r(60);&#125; 移动端单位使用详见 数组去重方法 原数组 1var myArray = [0, 1, 6, 9, 0, 2, 4, 5, 4]; 方法1 12345678910111213function aaa()&#123; var newArray = []; //一个新的临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 //如果当前数组的第i项已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (newArray.indexOf(myArray[i]) == -1)&#123; //在新数组中查找原数组的每一项是否存在 newArray.push(myArray[i]); //如果不存在就加到新数组中 &#125; &#125; // return newArray; alert("新的数组：" + newArray);&#125;aaa(); 方法2 123456789101112function bbb()&#123; var n = &#123;&#125;,r=[]; //n为hash表，r为临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 if (!n[myArray[i]])&#123; //如果hash表中没有当前项 n[myArray[i]] = true; //存入hash表 r.push(myArray[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; // return r; alert("新的数组：" + r);&#125;bbb(); 方法3 12345678910111213function ccc()&#123; var n = [myArray[0]]; //结果数组 for(var i = 1; i &lt; myArray.length; i++)&#123; //从第二项开始遍历 //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (myArray.indexOf(myArray[i]) == i)&#123; n.push(myArray[i]); &#125; &#125; // return n; alert("新的数组：" + n);&#125;ccc(); 方法4（同时排序） 123456789101112function ddd()&#123; myArray.sort(); //数组排序 var re = [myArray[0]]; //先提取最小的 for(var i = 1; i &lt; myArray.length; i++)&#123; if( myArray[i] !== re[re.length-1])&#123; //将不等于的放在新数组的后面，等于的跳过 re.push(myArray[i]); &#125; &#125; // return re; alert(&quot;新的数组：&quot; + re);&#125;ddd(); 数组乱序函数123456789function shuffle(array) &#123; for (var i = array.length - 1; i &gt; 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; return array;&#125; 数组常见操作（push、pop、shift、unshift）push:向数组的末尾添加一个或多个元素，并返回新的长度pop:把数组的最后一个元素从其中删除，并返回最后一个元素的值shift:把数组的第一个元素从其中删除，并返回第一个元素的值unshift:向数组的开头添加一个或更多元素，并返回新的长度 ajax请求 原生js 12345678910111213141516if(window.XMLHttpRequest)&#123; var ajax = new XMLHttpRequest();&#125;else&#123; var ajax = new ActiveXObject(“Microsoft.XMLHttp”);&#125;ajax.open(‘GET’,’***’,true);ajax.send();ajax.onreadystatechange = function()&#123; if(ajax.readyState == 4)&#123; if(ajax.status == 200)&#123; alert(ajax.responseText); &#125; else &#123; alert(“失败！”); &#125; &#125;&#125; jquery 123456789101112131415161718192021222324252627282930313233$.ajax(&#123; url: 'api.php', type: 'GET', dataType: 'json', timeout: 3000, data: &#123; num1: num1, num2: num2 &#125;, beforeSend: function(xhr, settings) &#123; // 发送请求前 console.log('beforeSend', xhr, settings); &#125;, success: function(data, status, xhr) &#123; // 请求成功 console.log('success', data, status, xhr); if (data.code === 0) &#123; console.log('处理成功'); $('#result').val(data.result); &#125; else &#123; console.log('处理失败'); &#125; &#125;, error: function(xhr, errorType, error) &#123; // 请求失败 console.log('error', xhr, errorType, error); alert('请求失败'); &#125;, complete: function(xhr, status) &#123; // 请求成功或失败都执行 console.log('complete', xhr, status); &#125;&#125;); HTML5特性简单易记的语言标签简单易记的编码类型不需要标签闭合标签名不区分大小写语义化的新增标签表单增强视频和音频canvas绘画 其他专业技能事件冒泡、委托等见web前端/常用资料/前端面试html5 + css3常见居中方法（定宽高和不定宽高）cavas、svg使用什么框架，喜欢它的哪些优点同步工具：svn / git （svn是集中式管理系统、git是分布式管理系统）公司使用：linux + node + git + jade + scss + es6 + vuevue特点：mvvmjquery：高效、快速处理一些简单的事情、很难处理麻烦的，比如渲染不固定数量的数组列表… 其他（思想、生活）专业、居住地是否单身、期望薪资等对未来的想法、构思业余活动对待加班的看法对待大企业和创业公司的看法如果公司需要你去使用一些你之前未有过的技能或知识，你该怎么办释放压力的方法 github面试题https://github.com/cpm828/Front-end-Developer-Interview-Questions]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重方法]]></title>
    <url>%2Fjavascript%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[原数组1var myArray = [0, 1, 6, 9, 0, 2, 4, 5, 4]; 方法112345678910111213function aaa()&#123; var newArray = []; //一个新的临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 //如果当前数组的第i项已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (newArray.indexOf(myArray[i]) == -1)&#123; //在新数组中查找原数组的每一项是否存在 newArray.push(myArray[i]); //如果不存在就加到新数组中 &#125; &#125; // return newArray; alert("新的数组：" + newArray);&#125;aaa(); 方法2123456789101112function bbb()&#123; var n = &#123;&#125;,r=[]; //n为hash表，r为临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 if (!n[myArray[i]])&#123; //如果hash表中没有当前项 n[myArray[i]] = true; //存入hash表 r.push(myArray[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; // return r; alert("新的数组：" + r);&#125;bbb(); 方法312345678910111213function ccc()&#123; var n = [myArray[0]]; //结果数组 for(var i = 1; i &lt; myArray.length; i++)&#123; //从第二项开始遍历 //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (myArray.indexOf(myArray[i]) == i)&#123; n.push(myArray[i]); &#125; &#125; // return n; alert("新的数组：" + n);&#125;ccc(); 方法4（同时排序）123456789101112function ddd()&#123; myArray.sort(); //数组排序 var re = [myArray[0]]; //先提取最小的 for(var i = 1; i &lt; myArray.length; i++)&#123; if( myArray[i] !== re[re.length-1])&#123; //将不等于的放在新数组的后面，等于的跳过 re.push(myArray[i]); &#125; &#125; // return re; alert("新的数组：" + re);&#125;ddd(); 相关常见数组方法 http://web.jobbole.com/83518/]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见正则表达式及获取某些字段的方法]]></title>
    <url>%2Fjavascript%2F%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%8E%B7%E5%8F%96%E6%9F%90%E4%BA%9B%E5%AD%97%E6%AE%B5%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[正则替换（replace）注：常规replace方法只会替换一次，需使用正则才能全部替换1str.replace(new RegExp(&apos;abc&apos;, &apos;gi&apos;), &apos;def&apos;) // 将abc字符串全部替换从def字符串，g表示从头到尾扫描，i表示不区分替换字符串的大小写 从字符串中截取数字： 1str.replace(/[^0-9]/ig, '') 去除所有空格 1str.replace(/\s+/g, '') 去掉左空格 1str.replace(/^\s*/, '') 去掉右空格 1str.replace(/\s*$/g, '') 去掉左右空格 1str.replace(/(^\s*)|(\s*$)/g, '') 正则判断（test）说明：对于正则判断手机号，有很多通过号段来判断，个人认为这样不是很严谨，号段可能会增加，所以只需判断首位为1且11位即可 首位是1且11位的手机号 1/^1\d&#123;10&#125;$/.test(phone) // 返回true 或 false 首位是1且11位的手机号（去除空格） 1/^1\d&#123;10&#125;$/.test(phone.replace(/(^\s*)|(\s*$)/g, '')) // 返回true 或 false 中国姓名(中文包括·或•) 1/^[\u2E80-\uFE4F]+([·•][\u2E80-\uFE4F]+)*$/.test(str) // 返回true 或 false email 1/^(\w-*\.*)+@(\w-?)+(\.\w&#123;2,&#125;)+$/.test(email) // 返回true 或 false 身份证号 1/^(^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$)|(^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[Xx])$)$/.test(id) // 返回true 或 false URL 1/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&amp;?[a-zA-Z0-9_-](\?)?)*)*$/i.test(url) // 返回true 或 false 邮编 1/^[1-9]\d&#123;5&#125;(?!\d)$/.test(postcode) // 返回true 或 false 输入的为纯数字 1/^\d+$/.test(number) // 返回true 或 false 输入n个纯数字 1/^\d&#123;n&#125;$/.test(number) // 返回true 或 false 输入m到n的纯数字 1/^\d&#123;m,n&#125;$/.test(number) // 返回true 或 false 纯英文字母 1/^[a-z]+$/i.test(enCode) // 返回true 或 false 大写应为字母 1/^[A-Z]+$/.test(enCode) // 返回true 或 false 英文字母或数字组成 1/^[a-z0-9]+$/i.test(code) // 返回true 或 false 英文字母和数字组合，区分大小写，6~16位 1/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,16&#125;$/i.test(code) // 返回true 或 false 英文字母、数字和下划线组成 1/^\w+$/.test(code) // 返回true 或 false 数字和.组成的浮点数 1/^(([1-9][0-9]*\.[0-9][0-9]*)|([0]\.[0-9][0-9]*)|([1-9][0-9]*)|([0]&#123;1&#125;))$/.test(str) 可用来检测金额，只能包含数字和.，且不能是00.123这种格式 从UA判断是否为IE浏览器 1/msie (\d+\.\d+)/i.test(ua) // 返回true 或 false 从UA判断是否为webkit内核 1/webkit/i.test(ua) // 返回true 或 false 从UA判断是否为chrome内核 1/chrome\/(\d+\.\d+)/i.test(ua) // 返回true 或 false 从UA判断是否为firefox内核 1/firefox\/(\d+\.\d+)/i.test(ua) // 返回true 或 false 从UA判断是否为safari浏览器 1/(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(ua) // 返回true 或 false 从UA判断是否是微信浏览器 1ua.indexOf('micromessenger') &gt; -1 从UA判断是否是QQ浏览器 1ua.indexOf('qq') &gt; -1 正则判断是否是微信浏览器 1/(micromessenger)\//.test(ua) 正则判断是否是QQ浏览器 1/(qq)\//.test(ua) 正则判断微信浏览器或QQ浏览器 1/(micromessenger|qq)\//.test(ua) 从UA判断是否为iPhone 1/iphone/i.test(ua) // 返回true 或 false 从UA判断是否为iPad 1/ipad/i.test(ua) // 返回true 或 false 从UA判断是否为安卓 1/android/i.test(ua) // 返回true 或 false 从UA判断安卓版本号 1ua.substr(ua.indexOf('android') + 8, 3) 从appVersion判断iOS版本 1parseInt(((navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/))[1], 10) 从UA判断是否为移动端 1/(nokia|iphone|android|ipad|motorola|^mot\-|softbank|foma|docomo|kddi|up\.browser|up\.link|htc|dopod|blazer|netfront|helio|hosin|huawei|novarra|CoolPad|webos|techfaith|palmsource|blackberry|alcatel|amoi|ktouch|nexian|samsung|^sam\-|s[cg]h|^lge|ericsson|philips|sagem|wellcom|bunjalloo|maui|symbian|smartphone|midp|wap|phone|windows ce|iemobile|^spice|^bird|^zte\-|longcos|pantech|gionee|^sie\-|portalmmm|jig\s browser|hiptop|^ucweb|^benq|haier|^lct|opera\s*mobi|opera\*mini|320x320|240x320|176x220)/i]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css伪类选择器]]></title>
    <url>%2Fcss%2F%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[选择器n的起始值是1 第一个子节点： 1:first-child&#123;&#125; 中间任意子节点： 1:nth-child(n) 奇数（1、3、5…）序号的子节点 1:nth-child(2n-1) 偶数（2、4、6…）序号的子节点 1:nth-child(2n) 第3、6、9…个子节点： 1:nth-child(3n) 中间第2个子节点开始： 1:nth-child(n+1) 第4、7、10…个子节点： 1:nth-child(3n+1) 最后一个子节点： 1:last-chid&#123;&#125; 不是第一个子节点 1&amp;:not(:first-child)&#123;&#125; 不是最后一个子节点 1&amp;:not(:last-child)&#123;&#125; 匹配父元素只有一个子节点的元素（设置在子节点上） 1:only-child&#123;&#125; 选择空元素（包括没有子节点和文本节点）的节点 1:empty&#123;&#125; 选择非*的元素 1:not(p)&#123;&#125; 选择首字母 1:first-letter&#123;&#125; 选择首行 1:first-line&#123;&#125; 在前面插入 123:before&#123; content: '***'&#125; 在后面插入 123:after&#123; content: '***'&#125; 链接按照L-V-H-A的顺序设置 未访问的链接 1a:link &#123;color: #FF0000&#125; 已访问的链接 1a:visited &#123;color: #00FF00&#125; 鼠标移动到链接上 1a:hover &#123;color: #FF00FF&#125; 选定的链接 1a:active &#123;color: #0000FF&#125; 表单 获取获得焦点的元素（链接、输入框等） 1:focus&#123;&#125; 可用的元素 1:enabled&#123;&#125; 不可用的元素 1:disabled&#123;&#125; 被选中的元素 1:checked&#123;&#125; 只读的元素 1:read-only&#123;&#125; 非只读（可读可写）的元素 1:read-write&#123;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象]]></title>
    <url>%2Fes6%2Fes6-Promise%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[摘自：阮一峰 ECMAScript 6 入门 介绍Promise是异步编程的一种解决方案 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，它是一个对象，从它可以获取异步操作的消息。 对象的状态不受外界影响，Promise对象代表这一个异步操作，有三个状态：如下，只有异步操作的结果才可以决定当前是哪一种状态 Pending（进行中） Resolved（已完成，又称Fulled） Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果，Promised对象的状态改变，只有两种，如下：，只要这两种情况发生，状态就凝固了，不会再变了。会一直保持这个结果。 从Pending变为Resolved 从Pending变为Rejected 基本用法 Promise对象是一个构造函数，用来生成Promise对象 1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功时 */) &#123; resolve(value) &#125; else &#123; reject(error) &#125;&#125;) resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（从Pending变为Resolved），在异步操作成功的时候调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（从Pending变为Rejected），在异步操作失败的时候调用，并将异步操作返回的错误，作为参数传递出去。 Promise实例生成之后，可以用then方法指定Resolved和Reject状态的回调函数，两个参数，一个成功回调，一个失败回调，第二个参数失败回调可选 12345promise.then(function (value) &#123; // success&#125;, function (error) &#123; // error&#125;) 例如下例： 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上例中：timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 Promise新建后就会立即执行 例如下例： 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('Resolved.');&#125;);console.log('Hi!');// Promise// Hi!// Resolved 上例中：Promise实例新建后立即执行，先输出“Promise”，然后then方法指定回调，当时回调会在当前脚本的同步方法之后才会执行，所以其次是输出“Hi！”，最后才会输出回调里面的“Resolved” 下面是异步加载图片的例子： 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 下面是用Promise对象实现Ajax操作的例子 1234567891011121314151617181920212223242526272829var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); resolve函数参数除了可能是正常的值以外也可能是另一个Promise实例，即回调里面是请求，如下例： 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上例中：p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即p1的状态决定了p2的状态。如果p1是Pending，那么p2就必须要等待。如果p1是Resolved或Rejected，那么p2的回调函数将会立即执行。 123456789101112var p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)var p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面代码中：p1是一个Promise，3s后变为rejected。p2的状态在1s之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2s，p1变为rejected，导致出发catch方法指定的回调函数。 Promise.prototype.then()then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调。前面说过，then方法的第一个参数是Resolved成功后的回调，第二个参数（可选）是Rejected失败后的回调。 then方法返回的是一个新的Promise实例，因此可以采用链式写法，及then方法后再调用一个then方法 12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码中，使用then方法一次指定了两个回调，第一个回调完成以后，会将返回的结果作为参数，传入第二个回调。 这种链式的then可以指定一组按照次序调用的回调。这时，前一个回调有可能还是一个Promise实例，这时后一个就必须等待。如下例： 1234567getJSON("/post/1.json").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log("Resolved: ", comments);&#125;, function funcB(err)&#123; console.log("Rejected: ", err);&#125;); 上例中：第一个then方法指定的回调是一个Promise实例。这时，第二个then方法指定的回调，就会等待这个新的Promise对象状态先发生变化。如果变为Resolved，就调用funcA，如果变为Rejected，就调用funcB。 采用箭头函数： 123456getJSON("/post/1.json").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log("Resolved: ", comments), err =&gt; console.log("Rejected: ", err)); Promise.prototype.catch()Promise.ptototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上例中：如果该对象状态变为Resolved，会调用then方法指定的回调，如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调。另外，如果运行中抛出错误，也会被catch捕获。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 如下例： 1234567var promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test promise抛出一个错误，就会被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 12345678910111213141516171819// 写法一var promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二var promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 上述也说明，reject方法的作用，等同于抛出错误。 如果Promise状态已经变成Resolved，再抛出错误是无效的。 12345678var promise = new Promise(function(resolve, reject) &#123; resolve('ok'); throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok 上面代码中：Promise在resolve语句后面，再抛出错误，不会被捕获，等同于没有抛出。因为Promise的状态一旦改变，就永久保持该状态，不会再改变了。 一般来说，不要在then方法里面定义Rejected失败状态的回调，应该使用catch语句 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 因为，Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获。错误总可以被catch语句捕获。 then catch语句更容易捕获错误，而且接近同步的写法（try/catch）语句。 Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.all([p1, p2, p3]); Promise.all的参数可以不是数组，但必须具有接口，且返回的每个成员都是Promise实例 p的状态有p1、p2、p3决定，分成两种情况 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled。此时p1、p2、p3的返回值组成一个数组，传递给p的回调 只要p1、p2、p3的状态有一个被rejected，p的状态就会变成rejected，此时，第一个被rejected的实例的返回值，会传递给p的回调 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1, p2, p3]); Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用 1var jsPromise = Promise.resolve($.ajax('/whatever.json')); Promise.resolve等价于下面的写法 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.reject()Promise.reject方法也会返回一个新的Promise实例，状态未rejected 12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 应用将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用数组方法]]></title>
    <url>%2Fjavascript%2F%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[尾部添加push1arrayObject.push(newelement1,newelement2,....,newelementX) // 可添加多个， 返回新的长度 尾部删除pop1arrayObject.pop() // 删除最后一个元素，返回最后一个元素 头部添加unshift1arrayObject.unshift(newelement1,newelement2,....,newelementX) // 可添加多个， 返回新的长度 头部删除shift1arrayObject.shift() // 删除第一个元素，返回第一个元素 任意位置删除添加splice1234arrayObject.splice(index,howmany,item1,.....,itemX)// 从某个索引位置开始，删除几个，再添加// 删除可以为空// 添加可以为空 数组截取slice1arrayObject.slice(start,end) // 从某个位置开始至某个位置结束 截取数组 数组排序sort12arrayObject.sort(sortby) // 默认按升序排序// return arrayObject.sort((val1, val2) =&gt; val1._sortBy - val2._sortBy) 在没有合适字段的情况下可自行添加字段 数组倒序reverse12arrayObject.reverse() //数组倒序，按字符编码顺序// return arrayObject.sort((val1, val2) =&gt; val1._sortBy - val2._sortBy) 在没有合适字段的情况下可自行添加字段 数组乱序123456789function shuffle(array) &#123; for (var i = array.length - 1; i &gt; 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; return array;&#125; 其他见lodash]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let 和 const]]></title>
    <url>%2Fes6%2Fes6-let%E5%92%8Cconst%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[let 只在代码块内有效 不存在变量提升（只能先声明后使用）（变量提升指变量在声明之前使用，值为ReferenceError） 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区（声明之前变量不可用）（暂时性死区简称“TDZ”）例1： 1234567var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 例2： 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 例3： 12typeof x; // ReferenceErrorlet x; 不允许重复申明（不允许在相同作用域内重复声明同一个变量）例1： 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 例2： 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; let新增块级作用域 ES5只有全局作用域和函数作用域 ES5函数只能在顶层作用域和函数作用域内声明，不能在块级作用域内声明 12345678910111213141516// ES5 情况一：非法if (true) &#123; function f () &#123;&#125;&#125;// ES5 情况二：非法try &#123; function f () &#123;&#125;&#125; catch (e) &#123; // ...&#125;// ES6if (true) &#123; function f () &#123;&#125;&#125; 在块级作用域内，函数声明语句的行为类似于let，在块级作用域之外不可引用，对作用域之外并不会影响 123456789// 对于本例：function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 12345678// ES5实际运行代码：结果为：I am inside!function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); 12345// ES6实际运行代码：结果为：I am outside!function f() &#123; console.log('I am outside!'); &#125;(function () &#123; f();&#125;()); const声明常量，不可变指的是该常量指向的地址，而不是常量本身 const声明一个只读的常量，一旦声明，常量的值就不能改变 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const一旦声明变量，就必须立即初始化，不能等到以后赋值 12const foo;// SyntaxError: Missing initializer in const declaration 只在声明所在的块级作用域内有效 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const声明的常量也不存在变量提升 存在暂时性死区 只能先声明后使用 不可重复声明 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。即const命令只是保证变量名指向的地址不变，而不是保证数据不变，所以使用const声明为常量必须小心。12345const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: "foo" is read-only 上例中：常量foo存储的是一个地址，这个地址指向一个对象。所谓不可变的是这个地址，不能把foo指向另一个地址，但是该对象本身是可变的，可以为这个对象添加新属性等1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上例中：常量a是一个数组，这个数组本身是可写的，但是将另一个数组赋给a，就会报错，因为改变了a指向的地址 ES6其他声明变量的方法共6中声明变量的方法: ES5两种：var 和 function ES6新增的：let 和 const ES6其他：import 和 class]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网穿透]]></title>
    <url>%2Ftools%2F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html</url>
    <content type="text"><![CDATA[为什么要内网穿透 分享网页作为一个 Web 开发者，我们有时候会需要临时地将一个本地的 Web 网站部署到外网，以供它人体验评价或协助调试等等，通常我们会这么做：找到一台运行于外网的 Web 服务器 服务器上有网站所需要的环境，否则自行搭建 将网站部署到服务器上 调试结束后，再将网站从服务器上删除只不过是想向朋友展示一下网站而已，要不要这么麻烦，累感不爱╰（｀□′）╯ 微信调试在微信开发的时候，需要填写与微信服务器相连接的 URL，这个 URL 必须是外网域名，也就是说我们需要在这个外网域名对应的 IP 服务器上做开发，而没办法本地开发调试 Localtunnel 安装 Node 安装 Localtunnel 1npm install -g localtunnel 申请 Tunnel 12lt --port 8000lt --port 8000 --subdomain xxx Ngrok 下载客户端1http://pan.baidu.com/s/1bnwROLL 创建配置文件ngrok.cfg 12server_addr: "tunnel.phpor.me:4443"trust_host_root_certs: false 运行 1./ngrok -config ngrok.cfg -subdomain xxx 8080]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 math方法]]></title>
    <url>%2Fes6%2Fes6-math%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考：阮一峰 ES6 Math对象扩展 Math.trunc()：用于去除一个数的小数部分，返回整数部分 1234567891011121314151617Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc('123.456') // 123，数值字符串会先经过Number()方法转换成数值Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaN Math.sign()：判断一个输是正数、负数还是零 参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN 12345678910111213Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign('foo'); // NaNMath.sign(); // NaN Math.cbrt()：计算一个数的立方根 1234567891011Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 Math.cbrt('8') // 2，数值字符串会先经过Number转换Math.cbrt('hello') // NaN]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型]]></title>
    <url>%2Fcss%2Fcss%E7%9B%92%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[content-box（默认）box-sizing: content-box; 只算内容，表示padding、border、margin不计算在设置的width和height中即 盒模型宽度 = content + padding + border + margin padding-box（不常用）box-sizing: padding-box; 从padding开始算，表示padding计算在设置的width和height中即 盒模型宽度 = content + border + margin border-box（特殊盒模型、开发常用）box-sizing: border-box; 表示padding、border计算在设置的width和height中即 盒模型宽度 = content + margin 开发时常在根元素设置：box-sizing: border-box; 其余元素，设置box-sizing: inherit;继承根部的]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue编译后的文件目录结构]]></title>
    <url>%2Fvue%2Fvue%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[当我们使用vue-cli脚手架时，执行npm run build之后会在根目录生成一个dist文件，如下图 对应的配置文件，根目录下config/index.js中，如下图 但是当我我们将编译后的文件放在后端的目录下时，目录结构并不一定还是这样，所以我们需要根据实际情况来设置编译的文件目录结构 比如我们需要将静态文件进行一层嵌套，我的配置为： 对应的编译后的目录为：]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发完成之后拷贝文件给后端]]></title>
    <url>%2Fvue%2Fvue%E5%BC%80%E5%8F%91%E5%AE%8C%E5%90%8E%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E8%87%B3%E5%90%8E%E7%AB%AF%E7%9B%AE%E5%BD%95%E4%B8%8B.html</url>
    <content type="text"><![CDATA[vue项目开发完成之后，需要将文件拷贝至后端目录下 可利用系统的复制命令（目录依后端目录结构而定）进行 1234rm -rf ../../mall/coupon/templates/mall/*&amp;&amp; rm -rf ../../mall/coupon/static/mall/*&amp;&amp; cp dist/index.html ../../mall/coupon/templates/mall&amp;&amp; cp -R dist/static/* ../../mall/coupon/static/mall 将其放在package.json下的script的copy中即可 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;copy&quot;: &quot;&quot;&#125;, 执行命令：npm run copy即可复制]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue渲染后端带标签或换行符的字符]]></title>
    <url>%2Fvue%2Fvue%E6%B8%B2%E6%9F%93%E5%90%8E%E7%AB%AF%E4%BC%A0%E9%80%92%E7%9A%84%E5%B8%A6%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[有的时候我们需要在后端配置一些提示语，再动态的显示在页面上，后端一般是用类似于textarea这样的多行输入框 那么此时如何将多行的文字渲染在前端页面上呢？ 标签法在后台输入框中我们可以带上标签进行编辑，如：123&lt;h3&gt;我是个小标题&lt;/h3&gt;&lt;p&gt;我是正文&lt;/p&gt;&lt;hr&gt; js渲染我们可以使用jquery的html()方法进行渲染 vue渲染 vue1.0：三括号表示法{&amp;nbsp;{&amp;nbsp;{ string }&amp;nbsp;}&amp;nbsp;} vue2.0：v-html=”” 注意：在设置传递的标签的样式时注意vue css scoped的影响，需去除。 非标签直接回车换行法如果在后台编辑的时候不适用标签的话，而是直接输入文本，进行换行。我们可以这样解决，找到文本换行符号，如django的\r\n表示换行，我们可以使用replace方法将其替换成&lt;br&gt;换行符，再进行渲染。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现放射圆提示点击的效果]]></title>
    <url>%2Fcss%2F%E5%AE%9E%E7%8E%B0%E6%94%BE%E5%B0%84%E5%9C%86%E6%8F%90%E7%A4%BA%E7%82%B9%E5%87%BB%E7%9A%84%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[效果图如下： html:123&lt;div class="shadow shadow1 cicle-ani1"&gt;&lt;/div&gt;&lt;div class="shadow shadow2 cicle-ani2"&gt;&lt;/div&gt;&lt;div class="shadow shadow3 cicle-ani3"&gt;&lt;/div&gt; css:12345678910111213141516171819.cicle-ani1&#123; animation: circleAni 3s linear 0s infinite;&#125;.cicle-ani2&#123; animation: circleAni 3s linear 1s infinite;&#125;.cicle-ani3&#123; animation: circleAni 3s linear 2s infinite;&#125;@keyframes circleAni&#123; 0%&#123; transform: scale(1); opacity: 1; &#125; 100%&#123; transform: scale(1.6); opacity: 0; &#125;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现点击页面出现心形动效]]></title>
    <url>%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E5%BF%83%E5%BD%A2%E5%8A%A8%E6%95%88.html</url>
    <content type="text"><![CDATA[原生js实现点击页面出现心形动效的效果，点击页面即可查看效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(function(window,document,undefined)&#123; var hearts = []; window.requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback)&#123; setTimeout(callback,1000/60); &#125; &#125;)(); init(); function init()&#123; css(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"); attachEvent(); gameloop(); &#125; function gameloop()&#123; for(var i=0;i&lt;hearts.length;i++)&#123; if(hearts[i].alpha &lt;=0)&#123; document.body.removeChild(hearts[i].el); hearts.splice(i,1); continue; &#125; hearts[i].y--; hearts[i].scale += 0.004; hearts[i].alpha -= 0.013; hearts[i].el.style.cssText = "left:"+hearts[i].x+"px;top:"+hearts[i].y+"px;opacity:"+hearts[i].alpha+";transform:scale("+hearts[i].scale+","+hearts[i].scale+") rotate(45deg);background:"+hearts[i].color+";z-index:99999"; &#125; requestAnimationFrame(gameloop); &#125; function attachEvent()&#123; var old = typeof window.onclick==="function" &amp;&amp; window.onclick; window.onclick = function(event)&#123; old &amp;&amp; old(); createHeart(event); &#125; &#125; function createHeart(event)&#123; var d = document.createElement("div"); d.className = "heart"; hearts.push(&#123; el : d, x : event.clientX - 5, y : event.clientY - 5, scale : 1, alpha : 1, color : randomColor() &#125;); document.body.appendChild(d); &#125; function css(css)&#123; var style = document.createElement("style"); style.type="text/css"; try&#123; style.appendChild(document.createTextNode(css)); &#125;catch(ex)&#123; style.styleSheet.cssText = css; &#125; document.getElementsByTagName('head')[0].appendChild(style); &#125; function randomColor()&#123; return "rgb("+(~~(Math.random()*255))+","+(~~(Math.random()*255))+","+(~~(Math.random()*255))+")"; &#125;&#125;)(window,document); 来源：A-Ten’s Blog源码研究]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js操作数值]]></title>
    <url>%2Fjavascript%2Fjs%E6%93%8D%E4%BD%9C%E6%95%B0%E5%80%BC.html</url>
    <content type="text"><![CDATA[经常需要用到js来操作数值，如取整、精确小数点后面的位数等等 取浮点数1234567parseFloat('123.45') = 123.45parseFloat('123.45abc') = 123.45parseFloat('abc 123.45') = NaNparseFloat(true) = NaN 对象转换成数字123456789Number(true) = 1Number(false) = 0Number(new Date()) = 1491972682647Number('999') = 999Number('999 888') = NaN 取整 将字符串或浮点数开头的整数提取出来 123456789101112131415parseInt(123) = 123parseInt(123.45) = 123parseInt(123.45abc) = 123 // error:Invalid or unexpected tokenparseInt('123') = 123parseInt('123.45') = 123parseInt('123,,45') = 123parseInt('123.45abc') = 123parseInt(true) = NaN 四舍五入 12345// 四舍Math.round(5 / 4) = 1// 五入Math.round(5 / 2) = 3 向上取整（有小数就+1） 1Math.ceil(5 / 2) = 3 丢弃小数 1Math.floor(5 / 2) = 2 精确到小数点后两位 四舍五入型 1234567891011// 四舍var a = 123.451789(a / 100).toFixed(2) = '123.45'// 五入var a = 123.456789(a / 100).toFixed(2) = '123.46'// 建议增加零判断（00.00 = 0）：var a = 123.456789parseFloat(a / 100).toFixed(2) == 0 ? 0 : (a / 100).toFixed(2) 全舍型 123var a = 123.456789Math.floor(a * 100) / 100// 无需增加零判断 全入型 123var a = 123.456789Math.ceil(a * 100) / 100// 无需增加零判断]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现上拉加载]]></title>
    <url>%2Fjavascript%2Fjs%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD.html</url>
    <content type="text"><![CDATA[前端加载列表的时候，当列表过多时，需要考虑使用上拉加载，每次只加载其中的几条数据，这种情况一般都是通过触发scroll事件或是全局绑定scroll事件 整页上拉加载123456789101112131415161718192021222324window.addEventListener('scroll', function () &#123; this.scrollLoader()&#125;.bind(this))scrollLoader () &#123; var screenHeight = window.innerHeight // 页面内容高度 var pageHeight = window.document.documentElement.scrollHeight // 页面高度（包括滚动条） var scrollHeight = window.scrollY // 已经滚动的高度 if (pageHeight - screenHeight - scrollHeight &gt; 100) return; this.requestData()&#125;requestData () &#123; $.ajax(&#123; url: '', data: &#123; page: '', // 请求第几页，全局变量，请求成功+1 num: '' // 请求几条数据 &#125; &#125;) // 结合返回的left值（还剩余几条数据）来决定到底后是否继续请求&#125; 弹窗（部分）上拉加载1234567891011121314151617181920212223ul(@scroll="scrollLoader()") liscrollLoader () &#123; var operateDom = document.querySelector('.awardlist-ul'); // alert var viewHeight = operateDom.offsetHeight; // 可见高度 var contentHeight = operateDom.scrollHeight; // 内容高度 var scrollTop = operateDom.scrollTop; // 滚动条高度 if (contentHeight - viewHeight - scrollTop &gt; 100) return; this.requestData();&#125;requestData() &#123; $.ajax(&#123; url: '', data: &#123; page: '', // 请求第几页，全局变量，请求成功+1 num: '' // 请求几条数据 &#125; &#125;)&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态添加样式表]]></title>
    <url>%2Fjavascript%2Fjs%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8.html</url>
    <content type="text"><![CDATA[有时候我们需要在js中动态的插入一段样式表，比如我们在封装某个库的时候，下面的函数就可以实现这个功能 12345678910111213141516171819202122232425// 动态添加样式function addCSS(cssText)&#123; var style = document.createElement('style'); //创建一个style元素 var head = document.head || document.getElementsByTagName('head')[0]; //获取head元素 style.type = 'text/css'; //这里必须显示设置style元素的type属性为text/css，否则在ie中不起作用 if(style.styleSheet)&#123; //IE var func = function()&#123; try&#123; //防止IE中stylesheet数量超过限制而发生错误 style.styleSheet.cssText = cssText; &#125;catch(e)&#123; &#125; &#125; //如果当前styleSheet还不能用，则放到异步中则行 if(style.styleSheet.disabled)&#123; setTimeout(func, 10); &#125;else&#123; func(); &#125; &#125;else&#123; //w3c //w3c浏览器中只要创建文本节点插入到style元素中就行了 var textNode = document.createTextNode(cssText); style.appendChild(textNode); &#125; head.appendChild(style); //把创建的style元素插入到head中&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js遍历查找点击的字节点的索引]]></title>
    <url>%2Fjavascript%2F%E5%8E%9F%E7%94%9Fjs%E9%81%8D%E5%8E%86%E6%9F%A5%E6%89%BE%E7%82%B9%E5%87%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%82%B9%E7%9A%84%E7%B4%A2%E5%BC%95.html</url>
    <content type="text"><![CDATA[1234567var indexLis = document.getElementsByClassName('index-li');for(var i = 0; i &lt; indexLis.length; i++) &#123; indexLis[i].setAttribute("index", i); indexLis[i].onclick = function () &#123; alert('我是第' + this.getAttribute("index") + '个li'; &#125;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js禁止复制]]></title>
    <url>%2Fjavascript%2Fjs%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6.html</url>
    <content type="text"><![CDATA[在做移动端开发的时候，用户禁止会误触页面上的文字，然后会提示复制等操作，体验非常不好，所以我们需要将它禁用掉 禁止复制js部分：控制键盘、选中、右键，可在html head区域或js中 1234567891011121314151617&lt;script&gt;document.oncontextmenu=stop;document.ondragstart=stop;document.onselectstart=stop;document.onkeydown = function (e) &#123; var ev = window.event || e; var code = ev.keyCode || ev.which; if (code == 116) &#123; ev.keyCode ? ev.keyCode = 0 : ev.which = 0; cancelBubble = true; return false; &#125;&#125;function stop()&#123; return false;&#125;&lt;/script&gt; css部分：可以放入 header，但是我建议 header 放一份，并将里面的内容往 CSS 文件里再放置一份，这样一来当 F12 去除了其中一个，另外一个再寻找起来会麻烦且花时间（位于 CSS 文件中的代码 对方需要在开发模式中清理 CSS 内容，而且这样可以导致整个无法直视）：1234567&lt;style type="text/css"&gt;html &#123; -ms-user-select: none; -moz-user-select: none; -webkit-user-select: none;&#125;&lt;/style&gt; ps：Ctrl + P能调起浏览器的打印机制，在里面可以进行拷贝，如需要禁止，可以增加以下css进行保险123@media print&#123; html &#123;display:none; &#125;&#125; 部分开启复制全页禁止复制后在部分区域开启复制功能，如博客中的代码等12345678910111213141516171819202122// code editfunction clrs_code() &#123; var controls = document.getElementsByTagName('pre'); for(var i=0; i&lt;controls.length; i++)&#123; controls[i].spellcheck = false; controls[i].setAttribute("contenteditable","true") &#125;; var controls = document.getElementsByTagName('code'); for(var i=0; i&lt;controls.length; i++)&#123; controls[i].spellcheck = false; controls[i].setAttribute("contenteditable","true"); &#125;; var controls = document.getElementsByClassName('crayon-pre'); for(var i=0; i&lt;controls.length; i++)&#123; controls[i].spellcheck = false; controls[i].setAttribute("contenteditable","true"); &#125;;&#125;;window.onload = clrs_code;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决zepto和jquery的冲突]]></title>
    <url>%2Fjquery%2F%E8%A7%A3%E5%86%B3zepto%E5%92%8Cjquery%E7%9A%84%E5%86%B2%E7%AA%81.html</url>
    <content type="text"><![CDATA[引入顺序：123&lt;script type="text/javascript" src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$.noConflict();&lt;/script&gt;&lt;script type="text/javascript" src="js/zepto.min.js"&gt;&lt;/script&gt; 中间增加：1&lt;script&gt;$.noConflict();&lt;/script&gt; 之后jQuery使用jQuery，Zepto使用Zepto，不再使用$]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-qrcode生成二维码]]></title>
    <url>%2Fjquery%2Fjquery-qrcode%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html</url>
    <content type="text"><![CDATA[有时候，我们需要在页面上生成一个二维码给用户查看，二维码的信息可以是个链接，也可以是别的。 但是需要可能只是给用户看一下，用户可以选择保存下来，过后并不需要再次打开找到二维码，也就是说生成的二维码是一次性的。 这个时候，我们也就没必要让后端同学生成后返回给我们一个二维码地址，前端可以自己吃用插件生成一个二维码。 资料 用法：http://tt4it.com/exchange/blog/discuss/115/ demo：https://larsjung.de/jquery-qrcode/latest/demo/ 官网：https://larsjung.de/jquery-qrcode/ github：https://github.com/lrsjng/jquery-qrcode CDN：12&lt;script src="http://cdn.bootcss.com/jquery/2.2.4/jquery.js"&gt;&lt;/script&gt;&lt;script src="http://cdn.bootcss.com/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"&gt;&lt;/script&gt; 配置12&lt;img src="" id="qr_logo"&gt; &lt;!-- 中间logo，可选 --&gt;&lt;div id="qrcode"&gt;&lt;/div&gt; 12345678$("#qr_code").empty().qrcode(&#123; render: 'image', // 模式，canvas、image、div，注明只有image图片模式才支持长按保存 mode: 0, // 中间的logo, 0表示默认无，1表示满行文字，2表示一定宽的文字，3表示满行方形图片，4表示一定宽的方形图片 image: $("#qr_logo")[0], // 中间的logo minVersion: 8, // 二维码缩放等级 size: 800, // 单位:px，生成的尺寸，注意生成后的清晰度 text: 'no text' // 跳转链接，或显示的文本&#125;); 样式1234#qrcode， #qrcode img&#123; display: block; width: 500px;&#125; 特殊情况当需要在二维码中间插入logo时， 如果是用本地地址，在img中直接使用即可。 如果是用网络地址，二维码中间会出现空白，这是因为初始化的时候网络地址还没加载出来，二维码就已经生成了。可以考虑将网络图片提前使用，使用过一次后图片会被缓存，下次使用会直接用而不会加载。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[locationStorage用法及扩展]]></title>
    <url>%2Fjavascript%2FlocationStorage%E7%94%A8%E6%B3%95%E5%8F%8A%E6%89%A9%E5%B1%95.html</url>
    <content type="text"><![CDATA[localStorage 和 sessionStorage localStorage为永久性保存 sessionStorage为暂时保存，关闭浏览器后失效 存储单个字符串 12window.localStorage.setItem('name', 'Jack')window.localStorage.getItem('name') 一次存储多个字符串 localStorage只能存储字符串，对于一次性需要存储大量的数据，建议存储为json对象，但使用localStorage必须先经过JSON.stringify()转换成字符串和JSON.parse()解析字符串方可成功，故封装了一个函数local.js，如下： 12345678910111213141516171819const &#123;localStorage, JSON&#125; = window;const storage = &#123; set (key, val = &#123;&#125;) &#123; let _value = JSON.stringify(val); localStorage.setItem(key, _value); &#125;, get (key) &#123; const _value = localStorage.getItem(key); return _value === null ? &#123;&#125; : JSON.parse(_value); // 存空对象和没有存都返回空对象 &#125;, remove (...keys) &#123; keys.forEach(key =&gt; localStorage.removeItem(key)); &#125;, clear () &#123; localStorage.clear(); &#125;&#125;;export default storage; 使用如下： 123456789101112import local from './local.js'let obj = &#123; today: '周五', tommorow: '周六'&#125;local.set('obj', obj); // 存local.get('obj'); // 取local.get('obj').today; // 取local.remove('obj', 'abc'); // 删出俩个local.clear(); // 清空 sessionStorage与之类似， 只是把所有的localStorage换成sessionStorage就行了]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的css辅助库]]></title>
    <url>%2Fcss%2Fcss%E8%BE%85%E5%8A%A9%E5%BA%93.html</url>
    <content type="text"><![CDATA[pure库（布局）CDN：http://yui.yahooapis.com/pure/0.5.0/pure-min.css meta：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 具体操作：http://www.purecss.org/ Font Awesome库（图标）CDN：http://netdna.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css 具体操作：http://fontawesome.dashgame.com/ animate.css（动画）具体操作：https://daneden.github.io/animate.css/ flex.css（布局）Github：https://github.com/lzxb/flex.css/blob/master/docs/zh-ch.md 具体操作:http://lzxb.name/flex.css/]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局的兼容写法]]></title>
    <url>%2Fcss%2Fflex%E5%B8%83%E5%B1%80%E5%85%BC%E5%AE%B9.html</url>
    <content type="text"><![CDATA[阮一峰 Flex 布局教程：语法篇阮一峰 Flex 布局教程：实例篇 flex布局在PC端兼容到IE10，移动端兼容也不是很好，使用flex时需增加一些兼容代码，注意先后顺序实际应用中，可通过添加类class实现 兼容写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172display: flex; // 弹性布局====&gt;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;flex-direction: row; // 从左到右排列====&gt;-webkit-box-direction: normal;-webkit-box-orient: horizontal;-moz-flex-direction: row;-webkit-flex-direction: row;flex-direction: row;flex-direction: row-reverse; // 从右到左排列====&gt;-webkit-box-pack: end;-webkit-box-direction: reverse;-webkit-box-orient: horizontal;-moz-flex-direction: row-reverse;-webkit-flex-direction: row-reverse;flex-direction: row-reverse;flex-direction:cloumn; // 从上到下排列====&gt;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;flex-direction:cloumn; // 从上到下排列====&gt;-webkit-box-pack: end;-webkit-box-direction: reverse;-webkit-box-orient: vertical;-moz-flex-direction: column-reverse;-webkit-flex-direction: column-reverse;flex-direction: column-reverse;align-items:center; // 水平居中====&gt;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;jusify-content: center; // 垂直居中====&gt;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;justify-content: space-between; // 两端对齐====&gt;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;justify-content: space-around; // 各个子级两端对齐====&gt;因旧版本flex不支持此属性，所以暂时不能兼容 flex有6个属性 flex-direction：主轴排列方向 row：默认水平，起点在左→ row-reverse：水平，起点在右← cloumn：垂直，起点在上 ↓ cloumn-reverse：垂直，起点在下↑ flex-warp：换行 now-wrap：默认不换行12345678 wrap：换行，第一行在上12345678 wrap-reverse：换行，第一行在下67812345 flex-flow：flex-direction和flex-warp的简写row nowrap：默认水平且不换行_ || _ :其他写法 jusitfy-content：主轴的对齐方式 flex-start：默认左对齐，往左靠 flex-end：右对齐，往右靠 center：居中对齐，往中间靠 space-between：两端对其，各个子级间隔相等 space-around：各个子级两端相等 align-items：交叉轴的对齐方式 flex-start：默认，顶对齐，往上靠 flex-end：底对齐，往下靠 center：垂直居中对齐，往中间靠 baseline：以第一行文字的基线对齐 stretch：若未设置高度或auto，将占满整个高度 align-content：多根轴线的对齐方式,一根轴线不起作用 flex-start：与交叉轴起点对齐 flex-end：与交叉轴终点对齐 center：与交叉轴中点对齐 space-between：与交叉轴两端对齐 space-around：每根轴线两端间隔相等 stretch：轴线占满整个交叉轴 使用flex.css兼容 https://github.com/lzxb/flex.css/blob/master/docs/zh-ch.mdhttp://lzxb.name/flex.css/]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局意外]]></title>
    <url>%2Fcss%2Fcss%E5%B8%83%E5%B1%80%E6%84%8F%E5%A4%96.html</url>
    <content type="text"><![CDATA[css布局的时候经常会有一些意想不到的表现 img下面白条解决办法 1vertical-align: middle /top / bottom; inline-block div导致部分下沉解决办法： 1vertical-align:top;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-ajax请求一个时间内只发一次]]></title>
    <url>%2Fjquery%2Fjquery-ajax%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E5%86%85%E5%8F%AA%E5%8F%91%E4%B8%80%E6%AC%A1.html</url>
    <content type="text"><![CDATA[问题解决解决这种问题有两种方式： 当连续进行多个请求，并且请求的url地址相同时。放弃前面的所有请求，只执行最后一次请求。 当连续进行多个请求，并且请求的url地址相同时。放弃后面的所有请求，只执行第一次请求。 解决方案 将ajax请求的async设置为false 123456789$.ajax(&#123; async: false, type : "POST", url : defaultPostData.url, dataType : 'json', success : function(data) &#123; &#125;&#125;); async:类型：Boolean默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 利用jquery ajaxPrefilter中断请求 由于第一种方案只是一种曲线救国的方式，其实没能真正的解决上面的问题。所以，建议使用这种方式。 12345678910111213141516171819var pendingRequests = &#123;&#125;;$.ajaxPrefilter(function( options, originalOptions, jqXHR ) &#123; var key = options.url; console.log(key); if (!pendingRequests[key]) &#123; pendingRequests[key] = jqXHR; &#125;else&#123; //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 &#125; var complete = options.complete; options.complete = function(jqXHR, textStatus) &#123; pendingRequests[key] = null; if ($.isFunction(complete)) &#123; complete.apply(this, arguments); &#125; &#125;;&#125;); Prefilters是一个预过滤器，在每个请求之前被发送和$.ajax()处理它们前处理。 options 是请求的选项 originalOptions 值作为提供给Ajax方法未经修改的选项，因此，没有ajaxSettings设置中的默认值 jqXHR 是请求的jqXHR对象 以上内容的核心思想是维护一个队列，发送请求时，将请求加入队列，请求响应后，从队列中清除，这就保证了在任一时刻只能有一个同样的请求发送. 局限性：仅仅是前台防止jquery的ajax请求。对于非jquery的ajax请求，不起作用。因为使用的是jquery的ajaxPreFilter函数，仅仅对jquery的ajax请求有作用。 调用abort后jquery会执行error的方法，抛出abort的异常信息。可以使用以下方式区分出该类型的异常。 12345678var ajax = $.ajax(&#123; 'error':function(jqXHR, textStatus, errorThrown)&#123; if(errorThrown != 'abort')&#123; //ajax被调用abort后执行的方法 alert('您的ajax方法被停止了'); &#125; &#125;&#125;) Demo按钮每次点击都会向后端发送请求，下面的demo实现了多次点击按钮之后，只保证最后一次点击的请求能够成功。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;button id="button1"&gt;button1&lt;/button&gt;&lt;button id="button2"&gt;button2&lt;/button&gt;&lt;button id="button3"&gt;button3&lt;/button&gt; &lt;script&gt; var pendingRequests = &#123;&#125;; jQuery.ajaxPrefilter(function( options, originalOptions, jqXHR ) &#123; var key = options.url; console.log(key); if (!pendingRequests[key]) &#123; pendingRequests[key] = jqXHR; &#125;else&#123; //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 &#125; var complete = options.complete; options.complete = function(jqXHR, textStatus) &#123; pendingRequests[key] = null; if (jQuery.isFunction(complete)) &#123; complete.apply(this, arguments); &#125; &#125;; &#125;); &lt;!-- 异步加载应用列表开始 --&gt; $("#button1").live("click", function() &#123; $.ajax('config/ajax/appinfoListFetcher.json', &#123; type:'POST', data: &#123;param1:value1, param2:value2, &#125;, success: function(res)&#123; //后端数据回写到页面中 &#125;, error:function(jqXHR, textStatus, errorThrown)&#123; if(errorThrown != 'abort')&#123; //ajax被调用abort后执行的方法 alert('应用加载失败！'); &#125; &#125; &#125;); &lt;!-- 异步加载应用列表结束 --&gt; &#125;);&lt;/script&gt;]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css伪类实现定制单选框样式]]></title>
    <url>%2Fcss%2Fcss%E4%BC%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%AE%9A%E5%88%B6%E5%8D%95%E9%80%89%E6%A1%86%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[原生单选框的样式实在太丑，UI肯定是不会用的啦，他们一般都会重新设计一种单选框，比如下面这种 设计原理使用span模拟一个大圆，再利用::before伪类画一个小圆，实际上是一样大的圆，只是小圆的边框很大，占据一定的位置 1234# HTMLli.pay-source input(type="radio", name="pay-source") span.replace-input 1234567891011121314151617span&#123; display: block; width: 30px; height: 30px; border: 1px solid #ccc; border-radius: 50%;&#125;span::before&#123; display: block; content: ''; width:100%; height: 100%; border: 8px solid #fff; background: #f00; box-sizing: border-box; border-radius: 50%;&#125; 扩展demo123456789101112131415161718192021222324input[type=radio] &#123; //原始input-radio保留但隐藏 position: absolute; visibility: hidden;&#125;input[type=radio] + .replace-input &#123; //input的兄弟接待 假span display: inline-block; width: r(36); height: r(36); border: $border-width solid $color-divider; border-radius: 50%;&#125;input[type=radio]:checked + .replace-input &#123; //被选中的情况下的兄弟节点 假span 的before伪类 &amp;:before &#123; display: block; content: ""; width: 100%; height: 100%; background-color: $red; border-radius: 50%; border: r(7) solid $white; &#125;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[img或div在设置正圆时不圆的处理]]></title>
    <url>%2Fcss%2Fimg%E6%88%96div%E5%9C%A8%E8%AE%BE%E7%BD%AE%E6%AD%A3%E5%9C%86%E6%97%B6%E4%B8%8D%E5%9C%86%E7%9A%84%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[img 问题：img设置border-radius: 50%时，当img宽高比较小时，在一些手机上的圆角加边框时，img留有空白 解决办法：在img外面套一个div，div设置box-sizing: content-box或padding-box即可，当box-sizing设置为border-box时，不能实现 div 问题：在一些低版本手机上，如安卓4.2, 设置border-radius:50%,背景会超出，仍然显示一个矩形 解决办法：给div设置background-clip: content-box或padding-box即可，将多余的背景裁掉]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端fixed浮层下面的页面仍能滚动]]></title>
    <url>%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFfixed%E6%B5%AE%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BB%8D%E8%83%BD%E6%BB%9A%E5%8A%A8.html</url>
    <content type="text"><![CDATA[在弹窗弹出的时候：12345document.body.style.overflow = 'hidden';// 或：$('body').css('overflow', 'hidden'); 在弹窗隐藏的时候：12345document.body.style.overflow = 'initial';// 或：$('body').css('overflow', 'initial'); // 或改为auto 对于多个fixed弹窗，可以写个遍历函数，遍历当某个fixed元素显示的时候将body的滚动禁止 参考资料：https://segmentfault.com/q/1010000002942948]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的js辅助库]]></title>
    <url>%2Fjavascript%2Fjs%E8%BE%85%E5%8A%A9%E5%BA%93.html</url>
    <content type="text"><![CDATA[微信公号开发CDN:https://dn-falcon.qbox.me/jweixin-1.0.0.js微信分享参考:https://github.com/sdkwe/jswe fastclick（解决300ms延迟）参考链接：https://github.com/ftlabs/fastclickCDN:https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js用法：123456// 使用fastclick解决300ms延迟if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false);&#125; underscore（JavaScript实用库）链接：http://www.css88.com/doc/underscore/ lodash（JavaScript实用库）链接：http://lodashjs.com/ moment.js（处理时间）链接：http://momentjs.cn/ DateTimePicker（处理日历）链接：http://www.jq22.com/yanshi332 dropload（加载）链接：https://github.com/ximan/dropload swiper（轮播图）链接：http://www.swiper.com.cn/ jquery插件库（插件）链接：http://www.jq22.com/ velocity.js（动画插件）链接：http://julian.com/research/velocity/ vivus（svg动画）链接：https://github.com/maxwellito/vivus snap（svg动画）链接：https://github.com/adobe-webplatform/Snap.svg jFlip（翻书插件）链接：http://www.jquery.info/scripts/jFlip/demo.html math.js（处理数学方法）链接：http://mathjs.org/docs/ SUI Mobile（UI库）链接：http://m.sui.taobao.org/ light7（UI库）链接：http://www.light7.cn/ chart.js（图标）链接：http://www.bootcss.com/p/chart.js/docs/]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于css定位]]></title>
    <url>%2Fcss%2F%E5%85%B3%E4%BA%8Ecss%E5%AE%9A%E4%BD%8D.html</url>
    <content type="text"><![CDATA[position 属性值的含义： static:默认值没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 relative:生成相对定位的元素相对定位写法：position：relative;通过top,bottom,left,right的设置相对于其正常位置进行定位。可通过z-index进行层次分级。他原本所占的空间扔保留 absolute:生成绝对定位的元素绝对定位写法：position：absolute;相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 fixed:生成固定定位的元素固定定位写法：position:fixed;相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 实例参考网站故事版本的介绍实例参考网站]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于居中布局]]></title>
    <url>%2Fcss%2F%E5%85%B3%E4%BA%8E%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[《盘点8种CSS实现垂直居中水平居中的绝对定位居中技术》译文：http://blog.csdn.net/freshlover/article/details/11579669原文：http://www.tuicool.com/articles/i6z6Bb 《CSS实现垂直居中的5种方法》http://www.qianduan.net/css-to-achieve-the-vertical-center-of-the-five-kinds-of-methods/ 《CSS布局奇淫技巧之-各种居中》http://www.cnblogs.com/2050/p/3392803.html 《CSS布局奇淫技巧之-宽度自适应》http://www.cnblogs.com/2050/archive/2012/07/30/2614852.html 《CSS布局奇淫技巧之-高度自适应》http://www.cnblogs.com/2050/archive/2012/07/30/2615260.html 《CSS布局奇淫技巧之-多列等高》http://www.cnblogs.com/2050/archive/2012/07/31/2616460.html]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决input-type-number后面的小按钮]]></title>
    <url>%2Fcss%2F%E8%A7%A3%E5%86%B3input-type-number%E5%90%8E%E9%9D%A2%E7%9A%84%E5%B0%8F%E6%8C%89%E9%92%AE.html</url>
    <content type="text"><![CDATA[在使用input type为number时，在输入框的后面会有上下加减按钮，好难看，(v_v)，想去掉，怎么搞？ 增加样式： https://www.zhihu.com/question/26476738/answer/32918388 1234input::-webkit-outer-spin-button,input::-webkit-inner-spin-button &#123; -webkit-appearance: none; &#125; 更换类型使用tel类型代替]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment操作时间]]></title>
    <url>%2Fjavascript%2Fmoment%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E6%97%B6%E9%97%B4%E5%92%8C%E5%80%92%E8%AE%A1%E6%97%B6.html</url>
    <content type="text"><![CDATA[moment.js:http://momentjs.cn/ 转换时间js转换时间12345var date = new Date(value)const [years, month, day, hours, minutes, seconds] = [date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()]var format = `$&#123;years&#125;年$&#123;('0' + month).slice(-2)&#125;月$&#123;('0' + day).slice(-2)&#125;日 $&#123;('0' + hours).slice(-2)&#125;时$&#123;('0' + minutes).slice(-2)&#125;分$&#123;('0' + seconds).slice(-2)&#125;秒` moment转换时间1moment(new Date(value)).format('YYYYMMDDHHmmss'); 比较时间123456// 使用diff来比较时间const startedAt = moment(user.started_at) // 开始时间const expiredAt = moment(user.expired_at) // 过期时间const serverAt = moment(this.model.timer.server_time) // 服务器时间const started = serverAt.diff(startedAt) &gt; 0 // 服务器时间大于开始时间const expired = serverAt.diff(expiredAt) &gt; 0 // 服务器时间大于过期时间 倒计时js倒计时js倒计时方法1123456789101112131415161718192021function formatSeconds(value) &#123; var theTime = parseInt(value);// 秒 var theTime1 = 0;// 分 var theTime2 = 0;// 小时 if(theTime &gt; 60) &#123; theTime1 = parseInt(theTime/60); theTime = parseInt(theTime%60); if(theTime1 &gt; 60) &#123; theTime2 = parseInt(theTime1/60); theTime1 = parseInt(theTime1%60); &#125; &#125; var result = "" + parseInt(theTime) + "秒"; if(theTime1 &gt; 0) &#123; result = "" + parseInt(theTime1) + "分" + result; &#125; if(theTime2 &gt; 0) &#123; result = "" + parseInt(theTime2) + "小时" + result; &#125; return result;&#125; js倒计时方法2123456789101112131415161718192021const diffSeconds = 7280// 耗时控制if (diffSeconds &lt; 60) &#123; // 0 ~ 60s this.redpacket.seconds = moment('0秒', 's秒').add(diffSeconds, 's').format('s秒') console.log('1')&#125; else if ((diffSeconds &gt; 60) &amp;&amp; (diffSeconds &lt; 3600) &amp;&amp; (diffSeconds % 60 !== 0)) &#123; // 60s ~ 3600s 但 不整除分钟 this.redpacket.seconds = moment('0分0秒', 'm分s秒').add(diffSeconds, 's').format('m分s秒') console.log('2')&#125; else if ((diffSeconds &gt; 3600) &amp;&amp; (diffSeconds % 60 !== 0)) &#123; // &gt;3600s 但 不整除小时 this.redpacket.seconds = moment('0时0分0秒', 'H小时m分s秒').add(diffSeconds, 's').format('H小时m分s秒') console.log('3')&#125; else if ((diffSeconds &lt; 3600) &amp;&amp; (diffSeconds % 60 === 0) &amp;&amp; (diffSeconds % 3600 !== 0)) &#123; // 60s ~ 3600s,整除分钟 但 不整除小时 this.redpacket.seconds = moment('0分', 'm分').add(diffSeconds, 's').format('m分') console.log('4')&#125; else if ((diffSeconds &gt; 3600) &amp;&amp; (diffSeconds % 60 === 0) &amp;&amp; (diffSeconds % 3600 !== 0)) &#123; // &gt;3600s,整除分钟 但 不整除小时 this.redpacket.seconds = moment('0时0分', 'H小时m分').add(diffSeconds, 's').format('H小时m分') console.log('5')&#125; else if (diffSeconds % 3600 === 0) &#123; // 整除小时 this.redpacket.seconds = moment('0时', 'H小时').add(diffSeconds, 's').format('H小时') console.log('6')&#125; moment倒计时js:1234567891011121314151617181920212223this.countTime(360000) // 不超过3600 00（100h）// 将秒转换成时分秒（此处因实际需求将时分秒拆开显示）exchangeTime (seconds) &#123; const surplusDay = parseInt(seconds / 86400) // 天数取整 const countH = moment('00:00:00', 'HH:mm:ss').add(seconds, 's').format('HH') this.countHH = surplusDay === 0 ? countH : (surplusDay * 24 + parseInt(countH)) this.countmm = moment('00:00:00', 'HH:mm:ss').add(seconds, 's').format('mm') this.countss = moment('00:00:00', 'HH:mm:ss').add(seconds, 's').format('ss')&#125;,// 秒 倒计时countTime (seconds) &#123; const timmerHandler = setInterval(() =&gt; &#123; if (seconds &gt; 0) &#123; seconds-- this.exchangeTime(seconds) &#125; else &#123; seconds = 0 clearInterval(timmerHandler) &#125; &#125;, 1000)&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常用]]></title>
    <url>%2Fvue%2Fvue%E5%B8%B8%E7%94%A8.html</url>
    <content type="text"><![CDATA[动态class:12345// 通过变量控制class:（列表和单个时有不同）:class="&#123; 'redpacket-para-margin' : model.redpackets.logo_url &#125;":class=" model.redpackets.logo_url ? 'redpacket-para-margin' : '' ":class=" !model.redpackets.logo_url || 'redpacket-para-margin' ":class=" model.redpackets.logo_url &amp;&amp; 'redpacket-para-margin' " 动态src:1234567// 对于template里面动态图片:src需要使用默认的图片,需将该本地图片资源从assets移动外一级static中,使用./static/*.png即可// 有则使用，无则使用默认:src="model.redpackets.background_url || '/static/img/auto-bg.png'"// 有则使用，无则隐藏:src="model.redpackets.watermark_url" v-show="model.redpackets.watermark_url" 输入框有则禁止输入1document.querySelector('.phone').readOnly = !!this.model.phone 写法除date、ready是()外，其余均带：12345678910export default &#123; data () &#123; return Object.assign(&#123;&#125;, &#123; &#125;) &#125;, components: &#123;&#125;， ready () &#123;&#125;, computed : &#123;&#125;, methods : &#123;&#125; &#125; 拼接链接12345678linkHref () &#123; // 跳转地址 return [ '/secret_reward?token=' + (this.model.token || ''), 'packet_id=' + (this.model.packet_id || ''), 'receiver_account_id=' + (this.model.receiver_account_id || ''), 'grant=' + (this.grant || '') ].join('&amp;')&#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiper轮播图实现]]></title>
    <url>%2Fjavascript%2Fswiper%E8%BD%AE%E6%92%AD%E5%9B%BE.html</url>
    <content type="text"><![CDATA[移动端wap页HTML:1234567891011div.swiper-container div.swiper-wrapper div.swiper-slide div.swiper-slide div.swiper-slide div.swiper-slide //- 分页器 div.swiper-pagination //- 按钮 div.swiper-button-next CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445.swiper-container,.swiper-wrapper,.swiper-slide&#123; width: 100%; height: 100%;&#125;.swiper-pagination&#123; right: 10px; top: 50%; transform: translate(-50%, 0); display: none;&#125;.swiper-button-next&#123; width: r(60); height: r(60); border-radius: 50%; background: url('../img/scroll-btn.png') no-repeat; background-size: 100% 100%; left: 50%; top: 100%; margin-top: r(-90); transform: translate(-50%, 0);&#125;.swiper-button-ani&#123; animation: swiper-btn-ani 1s linear infinite;&#125;@keyframes swiper-btn-ani&#123; 0%, 100%&#123; transform: translate(-50%, 0); &#125; 50%&#123; transform: translate(-50%, r(10)); &#125;&#125;.slidebox1,.slidebox2,.slidebox3,.slidebox4&#123; width: 100%; height: 100%; background: url('../img/bg1.png') no-repeat center center; background-size: cover; overflow: hidden;&#125; JS：1234567891011121314151617181920212223// 轮播图var mySwiper = new Swiper ('.swiper-container', &#123; initialSlide: 0, // 初始页数 direction: 'vertical', // 控制水平或垂直 // autoplay: 3000, // 3s自动切换 apeed: 300, // 划过的速度 // loop: true, onlyExternal: false, /*不能拖动*/ autoplayDisableOnInteraction: false, // 用户操作后不禁用自动播放 // pagination: '.swiper-pagination', // 底部分页按钮 // paginationClickable: true, // 分页按钮可点击 // prevButton: '.swiper-button-prev'， // 左按钮 nextButton: '.swiper-button-next', // 右按钮 onInit: function (swiper) &#123; // swiper初始化 $('.swiper-button-next').addClass('swiper-button-ani'); &#125;, onReachEnd: function (swiper) &#123; // 到达最后一页的事件操作 $('.swiper-button-next').removeClass('swiper-button-ani').hide(); &#125;, onSlidePrevEnd: function (swiper) &#123; //从最后往左切换的事件操作 $('.swiper-button-next').addClass('swiper-button-ani').show(); &#125;&#125;); PC端banner轮播图HTML:123456789101112131415161718192021&lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt; &lt;a href="" target="blank" class="swiper-link"&gt;&lt;img src="" alt="" class="swiper-img"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt; &lt;a href="" target="blank" class="swiper-link"&gt;&lt;img src="" alt="" class="swiper-img"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt; &lt;a href="" target="blank" class="swiper-link"&gt;&lt;img src="" alt="" class="swiper-img"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 底部分页器 --&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;div class="operate-box"&gt; &lt;!-- 左右按钮 --&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; django:12345678910111213141516171819202122232425&lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &#123;% for banner in banners %&#125; &lt;div class="swiper-slide"&gt; &#123;% if banner.url %&#125; &lt;a href="&#123;&#123; banner.url &#125;&#125;" target="blank" class="swiper-link"&gt; &lt;img src="&#123;&#123; banner.banner_img_url &#125;&#125;" alt="" class="swiper-img"&gt; &lt;/a&gt; &#123;% else %&#125; &lt;a href="javascript:void(0)" class="swiper-link"&gt; &lt;img src="&#123;&#123; banner.banner_img_url &#125;&#125;" alt="" class="swiper-img"&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;!-- 底部分页器 --&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;div class="operate-box"&gt; &lt;!-- 左右按钮 --&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990.swiper-container&#123; /*width: auto;*/ /*宽度由js给出*/ width: 100%; height: 700px; /*position: absolute; left: 50%; top: 0; -webkit-transform: translate(-50%, 0); transform: translate(-50%, 0);*/&#125;.swiper-wrapper&#123; width: 100%; height: 700px;&#125;.swiper-slide&#123; width: 100%; height: 700px;&#125;/*link 和 img由开发者另行创建*/.swiper-link&#123; display: inline-block; width: 100%; height: 700px; position: relative;&#125;.swiper-img&#123; height: 700px;&#125;.swiper-slide-active .swiper-img&#123; max-width: none; height: 700px; position: absolute; left: 50%; top: 0; -webkit-transform: translate(-50%, 0); transform: translate(-50%, 0);&#125;/* 1、对于banner图使用常用长图页*//* 由于宽度的不确定性，故增加左右按钮的父级div，方便定位 *//* 但当父级div高度太大时会影响图片的点击效果 *//* 故将父级div设置再banner图外，再配合margin-top手动将左右按钮设置到所需位置 *//* 2、对于banner使用中间图片加左右填充色 *//* 正常定位即可 */.operate-box&#123; width: 960px; height: 40px; position: absolute; left: 50%; top: -40px; -webkit-transform: translate(-50%, 0); transform: translate(-50%, 0); z-index: 50;&#125;.swiper-pagination&#123; z-index: 500;&#125;.swiper-container-horizontal &gt; .swiper-pagination-bullets&#123; bottom: 20px;&#125;.swiper-pagination .swiper-pagination-bullet&#123; width: 8px; height: 8px; border-radius: 50%; opacity: 1; background: #ffffff;&#125;.swiper-pagination .swiper-pagination-bullet-active&#123; width: 20px; height: 8px; background: #ffffff; border-radius: 4px;&#125;.swiper-button-prev&#123; width: 40px; height: 40px; left: 0; background: url('../img/left-btn.png'); z-index: 500; margin-top: 370px;&#125;.swiper-button-next&#123; width: 40px; height: 40px; right: 0; background: url('../img/right-btn.png'); z-index: 500; margin-top: 370px;&#125; JS:12345678910111213141516171819&lt;script src="http://cdn.bootcss.com/Swiper/3.3.1/js/swiper.min.js"&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123; // 轮播图 var mySwiper = new Swiper ('.swiper-container', &#123; // width: window.innerWidth, direction: 'horizontal', // 控制水平或垂直 autoplay: 3000, // 3s自动切换 apeed: 300, // 划过的速度 loop: true, onlyExternal: false, /*不能拖动*/ autoplayDisableOnInteraction: false, // 用户操作后不禁用自动播放 pagination: '.swiper-pagination', // 底部分页按钮 paginationClickable: true, // 分页按钮可点击 nextButton: '.swiper-button-next', // 左按钮 prevButton: '.swiper-button-prev' // 右按钮 &#125;);&#125;);&lt;/script&gt;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发调试]]></title>
    <url>%2Fvue%2Fvue%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95.html</url>
    <content type="text"><![CDATA[1、最初开发时：12cnpm run build# 使用localhost:8080即可开发页面 2、前端本地起服务（测试接口）12345678# 本地起服务：python manage runserver 0.0.0.0:8080# 将3中的target换成127.0.0.1:8080，全部注释也可以vue index.js中将port换成8082cnpm run dev打开页面：localhost:8082/*****接口会默认代理到127.0.0.1:8080 3、后端电脑IP起服务时（测试接口）：123456789101112131415161718192021222324在config/index.js 配置代理proxyTable：dev: &#123; env: require('./dev.env'), port: 8081, assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: &#123; '/api': &#123; target: 'http://127.0.0.1:8080', // target: 'http://192.168.21.164:8000', changeOrigin: true, pathRewrite: &#123; '^/api': '/api' &#125; &#125; &#125;, // CSS Sourcemaps off by default because relative paths are "buggy" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false &#125;// proxyTable中使用后端电脑的IP，使用127.0.0.1:8081来打开页面，这样打开页面仍然时打开前端的代码，默认接口都会代理到IP上 4、测试render:123# 将代码copy到后端的目录下python manage runserver 0.0.0.0:8080localhost:8080/guessgame/guess_index?uid=***** # 此时打开的就是前端build之后且拷贝到后端目录里面的代码 注明：index.js中设置代理知识在开发模式下生效，测试环境和线上环境不会读取]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css自定义滚动条]]></title>
    <url>%2Fcss%2Fcss%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1.html</url>
    <content type="text"><![CDATA[http://www.xuanfengge.com/css3-webkit-scrollbar.html CSS3自定义滚动条样式 -webkit-scrollbar1234567891011121314151617181920/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123; width: 0.8rem; height: 0.8rem; background-color: #eee;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 0.4rem rgba(0,0,0,0.3); border-radius: 0.8rem; background-color: #eee;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123; border-radius: 0.8rem; -webkit-box-shadow: inset 0 0 0.4rem rgba(0,0,0,.3); background-color: #ccc;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锚链接平滑滚动]]></title>
    <url>%2Fjquery%2F%E9%94%9A%E9%93%BE%E6%8E%A5%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8.html</url>
    <content type="text"><![CDATA[12345678910111213141516$(function()&#123; $('a[href*=#],area[href*=#]').click(function() &#123; if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') &amp;&amp; location.hostname == this.hostname) &#123; var $target = $(this.hash); $target = $target.length &amp;&amp; $target || $('[name=' + this.hash.slice(1) + ']'); if ($target.length) &#123; var targetOffset = $target.offset().top; $('html,body').animate(&#123; scrollTop: targetOffset &#125;, 1000); return false; &#125; &#125; &#125;);&#125;)]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax请求...进度]]></title>
    <url>%2Fjquery%2Fajax%E8%AF%B7%E6%B1%82...%E8%BF%9B%E5%BA%A6.html</url>
    <content type="text"><![CDATA[效果图： 实现原理:HTML：1&lt;a href="javascript:" id="submit" class="grebtn"&gt;提交订单&lt;/a&gt; CSS：123456789101112131415161718.dotting &#123; display: inline-block; width: 10px; min-height: 2px; padding-right: 2px; border-left: 2px solid currentColor; border-right: 2px solid currentColor; background-color: currentColor; background-clip: content-box; box-sizing: border-box; -webkit-animation: dot 4s infinite step-start both; *zoom: expression(this.innerHTML = '...'); /* IE7 */&#125;.dotting:before &#123; content: '...'; &#125; /* IE8 */.dotting::before &#123; content: ''; &#125;:root .dotting &#123; margin-left: 2px; padding-left: 2px; &#125; /* IE9+ */@-webkit-keyframes dot &#123; 25% &#123; border-color: transparent; background-color: transparent; &#125; /* 0个点 */ 50% &#123; border-right-color: transparent; background-color: transparent; &#125; /* 1个点 */ 75% &#123; border-right-color: transparent; &#125; /* 2个点 */&#125; JS：12345678910$("#submit").bind("click", function() &#123; if (!this.ajaxing) &#123; this.ajaxing = true; this.innerHTML = '提交订单中&lt;span class="ani_dot"&gt;...&lt;/span&gt;'; setTimeout( function() &#123; this.ajaxing = false; this.innerHTML = "提交超时"; &#125;.bind(this), 30000); &#125;&#125;); 说明：同样是4秒动画，每秒钟显示1个点； IE7/IE8实现原理跟上面box-shadow方法一致，都是内容生成，如果无需兼容IE7/IE8, 可以按照第一个例子CSS代码注释说明删除一些CSS； currentColor关键字可以让图形字符化，必不可少； 最大功臣是CSS3 background-clip属性，可以让IE9+浏览器下左右padding没有背景色，于是形成了等分打点效果。CSS3 Background博大精深，有兴趣可参考一篇很赞的文章CSS3 Backgrounds相关介绍，很多图，移动端非wifi慎点； box-sizing是让现代浏览器和IE7/IE8占据宽度完全一样的功臣：IE7/IE8实际宽度是width+padding-right为12像素，其他现代浏览器为width+margin-left也是12像素；这里CSS代码主要用来展示原理，故没有显示-webkit-animation以及@-webkit-keyframes私有前缀，实际目前还是需要的； 优势所在 CSS生成的点没有虚化，效果更好； 占据的尺寸各个浏览器完全一致，都是12像素宽度； 颜色继承； 天然字符化显示，与文字浑然天成；]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除链接点击后的虚线框]]></title>
    <url>%2Fcss%2F%E5%8E%BB%E9%99%A4PC%E7%AB%AF%E9%93%BE%E6%8E%A5%E7%82%B9%E5%87%BB%E7%9A%84%E8%99%9A%E7%BA%BF%E6%A1%86.html</url>
    <content type="text"><![CDATA[使用for循环遍历所有的链接，聚焦的时候同时失去焦点12345for(var i = 0; i &lt; document.links.length; i++) &#123; document.links[i].onfocus = function () &#123; this.blur() &#125;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测用户输入的信息是否为空]]></title>
    <url>%2Fjavascript%2F%E6%A3%80%E6%B5%8B%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html</url>
    <content type="text"><![CDATA[点击触发12345$('.info-submit').on('click', function()&#123; //点击触发开始检测 if(checkEmptyInput())&#123; //信息全部正确，继续执行 &#125;&#125;); 逐个报错123456789101112131415161718function checkEmptyInput() &#123; //检测上传信息 var name = $(&apos;.name&apos;).val(); var phone = $(&apos;.phone&apos;).val(); var address = $(&apos;.address&apos;).val(); if ($.trim(name).length === 0) &#123; console.log(&apos;请输入姓名&apos;); return false; &#125; if ($.trim(phone).length === 0) &#123; console.log(&apos;请输入手机号&apos;); return false; &#125; if ($.trim(address).length === 0) &#123; console.log(&apos;请输入地址&apos;); return false; &#125; return true;&#125; 一起报错(表单常用报错方式)123456789101112131415161718192021222324252627function checkEmptyInput() &#123; //检测输入信息 var hasError = false; var nameValue= $(&apos;.name&apos;).val(); var ageValue = $(&apos;.age&apos;). val(); var phoneValue = $(&apos;.phone&apos;). val(); if (nameValue.length === 0) &#123; $(&apos;.p2-name-error&apos;).css(&#123;&apos;opacity&apos;: &apos;1&apos;&#125;); hasError = true; &#125; if (ageValue.length === 0) &#123; $(&apos;.p2-age-error&apos;).css(&#123;&apos;opacity&apos;: &apos;1&apos;&#125;); hasError = true; &#125; if (phoneValue.length === 0) &#123; $(&apos;.p2-tel-error&apos;).css(&#123;&apos;opacity&apos;: &apos;1&apos;&#125;); hasError = true; &#125; if((nameValue.length !== 0) &amp;&amp; (ageValue.length !== 0) &amp;&amp; (phoneValue.length !== 0))&#123; //所有信息正确 hasError = false; &#125; if(hasError) &#123; return false; &#125; else &#123; return true; &#125;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单h5开发的适配代码]]></title>
    <url>%2Fcss%2Fh5%E5%BC%80%E5%8F%91%E6%97%B6%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%BB%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123; html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123; html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123; html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123; html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123; html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123; html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123; html&#123;font-size:25px&#125;&#125; 这种做法只适用于单屏显示的h5，一般的移动端开发，我会选择这种做法]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式和语句的简单区分]]></title>
    <url>%2Fhtml%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[表达式：有返回值1234A ? B : C //返回B或CA //返回true或falsea === b //返回true或falsea = function () &#123; &#125; //返回函数返回值 语句：没有返回值123A &amp;&amp; Ba = ba - b]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当锚点遇上顶部header占位的解决办法]]></title>
    <url>%2Fhtml%2F%E5%BD%93%E9%94%9A%E7%82%B9%E9%81%87%E4%B8%8A%E9%A1%B6%E9%83%A8header%E5%8D%A0%E4%BD%8D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[http://www.ydcss.com/archives/209 背景：在开发PC网站时，有时我们会遇到需要增加锚链接的情况，但是PC网站一般都设有header区域，正常的锚链接跳转会定位到顶部，便会挡住一部分，所以需要考虑解决它，让用户的体验更好 原理：给“锚点内容”加上12padding-top:80px; // 80为header的高度margin-top:-80px; 即解决我们的问题]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮点数运算导致精度丢失]]></title>
    <url>%2Fjavascript%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%AF%BC%E8%87%B4%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1.html</url>
    <content type="text"><![CDATA[资料地址：https://segmentfault.com/a/1190000000324193 解决一：使用math.js库解决二：使用函数加法运算（0.1 + 0.2）1234567891011121314151617181920212223242526272829303132function accAdd(arg1, arg2) &#123; var r1, r2, m, c; try &#123; r1 = arg1.toString().split(".")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(".")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; c = Math.abs(r1 - r2); m = Math.pow(10, Math.max(r1, r2)); if (c &gt; 0) &#123; var cm = Math.pow(10, c); if (r1 &gt; r2) &#123; arg1 = Number(arg1.toString().replace(".", "")); arg2 = Number(arg2.toString().replace(".", "")) * cm; &#125; else &#123; arg1 = Number(arg1.toString().replace(".", "")) * cm; arg2 = Number(arg2.toString().replace(".", "")); &#125; &#125; else &#123; arg1 = Number(arg1.toString().replace(".", "")); arg2 = Number(arg2.toString().replace(".", "")); &#125; return (arg1 + arg2) / m;&#125;//给Number类型增加一个add方法，调用起来更加方便。Number.prototype.add = function (arg) &#123; return accAdd(arg, this);&#125;; 减法运算（0.3 - 0.1）123456789101112131415161718function accSub(arg1, arg2) &#123; var r1, r2, m, n; try &#123; r1 = arg1.toString().split(".")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(".")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度 n = (r1 &gt;= r2) ? r1 : r2; return ((arg1 * m - arg2 * m) / m).toFixed(n);&#125;// 给Number类型增加一个mul方法，调用起来更加方便。Number.prototype.sub = function (arg) &#123; return accMul(arg, this);&#125;; 乘法运算（1.1 * 100）12345678910111213141516function accMul(arg1, arg2) &#123; var m = 0, s1 = arg1.toString(), s2 = arg2.toString(); try &#123; m += s1.split(".")[1].length; &#125; catch (e) &#123; &#125; try &#123; m += s2.split(".")[1].length; &#125; catch (e) &#123; &#125; return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);&#125;// 给Number类型增加一个mul方法，调用起来更加方便。Number.prototype.mul = function (arg) &#123; return accMul(arg, this);&#125;; 除法运算（111 / 1.11）123456789101112131415161718function accDiv(arg1, arg2) &#123; var t1 = 0, t2 = 0, r1, r2; try &#123; t1 = arg1.toString().split(".")[1].length; &#125; catch (e) &#123; &#125; try &#123; t2 = arg2.toString().split(".")[1].length; &#125; catch (e) &#123; &#125; r1 = Number(arg1.toString().replace(".", "")); r2 = Number(arg2.toString().replace(".", "")); return (r1 / r2) * Math.pow(10, t2 - t1);&#125;//给Number类型增加一个div方法，调用起来更加方便。Number.prototype.div = function (arg) &#123; return accDiv(this, arg);&#125;;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入框实时检测输入情况]]></title>
    <url>%2Fjquery%2F%E8%BE%93%E5%85%A5%E6%A1%86%E5%AE%9E%E6%97%B6%E6%A3%80%E6%B5%8B.html</url>
    <content type="text"><![CDATA[通用版12345678$('.p6-text').on('input',function()&#123;//输入框内容改变时发生的事件 var v = $('.p6-text').val(); //v是实时获取输入框的内容 if ($.trim(v) == '') &#123;//如果输入框内容为空发生的事件 $('.submit-before').show(); &#125;else&#123;//如果输入框内容不为空发生的事件 $('.submit-before').hide(); &#125;;&#125;); IE版12345678$('.p6-text').on('propertychange',function()&#123;//输入框内容改变时发生的事件 var v = $('.p6-text').val(); //v是实时获取输入框的内容 if ($.trim(v) == '') &#123;//如果输入框内容为空发生的事件 $('.submit-before').show(); &#125;else&#123;//如果输入框内容不为空发生的事件 $('.submit-before').hide(); &#125;;&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端横屏提示]]></title>
    <url>%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E6%A8%AA%E5%B1%8F%E6%8F%90%E7%A4%BA.html</url>
    <content type="text"><![CDATA[做移动端开发的时候需要对横屏做处理，否则用户体验很不好 css和js均有检测横屏的机制，但是想要把一个竖屏的网页在横屏上显示出来，各种方法都不太合适 除非制作的是横屏的游戏，否则一律在用户横屏的时候提示用户需竖屏访问 所以增加一段js代码，提示横屏 效果如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859(function() &#123; var landscapeTip; function createLandscapeTip() &#123; if (!landscapeTip) &#123; landscapeTip = document.createElement('div'); landscapeTip.style.background = 'black'; landscapeTip.style.position = 'fixed'; landscapeTip.style.width = '100%'; landscapeTip.style.height = '100%'; landscapeTip.style.left = 0; landscapeTip.style.top = 0; landscapeTip.style.textAlign = 'center'; landscapeTip.style.zIndex = 99999999999; landscapeTip.style.overflow = 'hidden'; landscapeTip.innerHTML = '&lt;div style="position: absolute; top: 50%; left: 50%; -webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)"&gt;&lt;img style="height:150px" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAADSBAMAAADJZwRlAAAAD1BMVEUAAAD7+/v+/v7////9/f2XbP5GAAAABXRSTlMA/mwzs0Mc0mcAAAlcSURBVHja7V1RdpswEFQlDlAwB5BMDiBsDmBC73+mNsVkjcdiLOtJ5r129dGXEprpanZYjUSsXg5jV6PDoW5H6TDTj0O1jEaG/hqtDLOMSZUN3bIMqtWoGlU0tPeRd/iTKhnuEn3L6FXB0PE/rWAGjTevZOOsCsVHXdcv1KSpC82xq/9E6x9Po9de23nAxaMqErr+G83ja5f+Z3/oD18aqd4Urg4j1K3XNpjBU5EpNuMVYDwNnVUFoqq/404Kh6+vTzL8ezLY1xJ2feXylV9/HVbyVTZGwQelvIcMzjUsCHfHwaFeBWtRymfQ1es4qH3FIjIS0766haqGsLvioKsxpu+2+XgzTqsx87cAB8caoz3Pi456Hn4eixzOoyf9bSaRWf7kGeztF4FVzkCROdoFb7MbDro7CawiSjkzB1FkDrcppRTTJMsZKHicJKdcbExmgNjJtLq5nfXW74GD44qCXqb9OYQfCDDfDAvrzIL4/VO8EhmvpzvczduLZC0yVXMPfCrJQS4yxkPx2PcC1OEehouN+VTZo1/3+qbD5La+EAd5J+NnDgLCsD2YfYr1XZtq7KOrTRkOcpFB/NuLlNwWNXYyqwxysdGByc8lMsMdB3kpdznbLRQZZ6WKEWFxDqLIQPfOxMZ0GVp+TM80SKkaG0b4Bg7qOTX6WgfAQRCbAhzEGm2uCPwXncy0sbA/FOEgzvAMoEE6cbHJwEFkl1XuJj1+Uy5tWQ7qK/evONXJw+N/G6Hp8tpv/Q0F2/m5r5GDIDZZOYhpsUupYDK42PisGTTXlDjS2YPYFOLgUrxzbrza5OBjR8RMWTPo5oWmvuZl5uCBt2aXrBxEkekXkWHJkFLOz0EUmaju0edfk6DIzF4kTPGm2JhPZqKnU1BEhnIQHRHkYD6RQS+Siw3elEtkkIJcbHJzcMncUiqUgyI2UsoGWqBsIrPQSXLCxSYvB5cmdcYZRScpZXZT+nLJishAcLFJNjD5RLXjuiSh3dou5YwcNLi3iRzkpQwczLPBaQUgtPykbyAmeupz7oO4a8+Ucp64Fq+B1SRwkPcNCcFobhcxlCmumthSTuKg+dwUmcsiMgLQ+Ogys0lMu0SJjESM2CQxrXlWZGSlG983JDHNPiEyhINcbFKeFg21BVe9p7EFxcYEb4Yt7FQH2Sf0A03M7lJkBnXLt215W2QDFIR/GgxMHj6+lBFGQ/Ye1hzssosNwrABkYEKNNEc7MDc5IEwPonIpHBwoXpIbE4fv/7E0W9LiSciE8VBNNGDYmM+JEl+S0oOW6co7jj4yingcCmfTwvG1m7NoycUjOAgmujgiATSaDeO3E1MZCR8HAd5KctVi2kSHFxkxMAkASY63bbVwncsBJzJUGrFRI/kIN+2rfCiu83fr1+WPOdePdC7ZJD1DQ5q4XQ8Hh3OIooMD85BglC6igNrFlBk0jgoJvpmKQsFPMw8gECRSecgQygXJwIQRSaBg2Cig9hgChsOsIcZTgjdkEUK1KbF72/DAn5RyMEnG2w00ZnYOCwT/QjgGBAZYqITDmIp8znmANuUA714EzlbqrGOzaPvHQkFEzhISnmE3JpH2uMCFEQTnQea6HyhcUCAlvex3MDkHJSZFIRMVMYHifoBFEzmYIDkE5IQGysEqONeaok/6D2CSIQZ5x4BGZGCYGAmcNBAIw9VQrqFXgDm4GAFrspGvoZQt4CZ5SY6P4mOjWi4jFGpkYVtFg6O0A9DvojOgK2XwEHdbJ+J/am2ewMjtCS2nhiYiRwc4P08mNAQLfkTk5voHKBbAWzY0xjLmDe/CbsI8AphS4RQxDuAELGbLomDVb0FMNguWGLrvc5BD/0gAESlJiSE5peb6JyDAgE4iAARRpuwh0CXnTgvxFa7KDLHIDYpBiZQEBwX0rw4TDWWcoKJLo86+WkSngOsBANBSE10zkEzQo0QgLCiD5RyioluCAUJQDFFKMJ0Drrtt6i9W8y2XxOksCEHpFNM9OB7yuHyaRDDtP22gU0w0XGGEUW1Ud5OEBKxec1Eh+kAFJhdD3UCCLGUE0x0IjKQwkMAg91E+KKJPngmMnjVhpqg9vN49sFSTjEwucgMm87z6Rtit/E2hn7ZRJd6k7hgluQKxvn4JzpPxCaFgyNQMJRCn3DQ6WUTHUUGvhnm/hWEr3CQiQxqLgkqNvEmOn/OSQqbpPOEbbSByUQGm4W8B53QRPdEZPDcLETWg07OgsiEm3hEnv+g0+CJyNCzWvGlHMdBLjISTi6kIPQxHDSSfqQgpvCSCDBebJzlIiNxTDJbhvMLpTx4IjIksoqNaUgnkxzcEeEmOulk0gJN9Ogf4exCwXaM71fi/XCPYsNvMtekyz5YzoC+gXNwWEC53BRUesK3OLlQu4UTOtsBejEweSmjsT1+026E5KcHmugaSplUluTbZacg9g3cRO8F1CC35QnTQXfOOehWAInIJHMQ+gZqopt6BTDPDIuJHrtIcbaSmpeWNHuYZ0rZTPe/RngkvEjHZWP6Bt3e7c+YMZfIiIGJixRiop9u/iMVpWA6B2PFxo1S8WbMKzKGL1JQlKRXPZ5GXvjpHCR9A3DQkOVSJg4ysRH7rS/UTIOJ/mwpj2S5lJODHGGHyyWv8obfXKQgB3VBCqoBTHTyNobpgIKTyhhoonOxceUoiKeAudh0BUUGOcjFRjdVQZGBjRxeyqajtmBODnKEZUUGOcjF5pSVgunmpq4LigxykCM0dTEK4kl0LjYIsFV5Y/CRez3Vrn5d/oNSLioy/CS6hjwVFBk8BczFpmwngxzkpTyAyLw9xBEp0MlgGFk10VIuJDLoh1eN6lbj7jMDvhGe/FBCZNAPt6aV8f25C+Myjgua0eJyqUyscgcZ/K6MdqxBZPYRMrPFOxlno0q5tMggQNI3EAqWDeNBbEqKDF9J9asJ1IUpiFOMBgJppYktmAEgbIf0l3Up705k+sv6y90sl9Q8vRCulMjwdqufAn1DcZFxdiuDJw8IS4uM2ZZnew98N8ulkO9QcZEpwsFqCt7ARaYEB6tD+I6yImMCf+1FBwHhHhoFpc5BgGYsqdLDJVjA2m5s236qnIGKjPHh5RKAP7/9KfwVZhco7nRmJx+2lvoR1UUL2JjYH9cZVTSqRtvlw5SN1ewD04+6dBtobP+zv1zHz+VD5+WD5/V61L5TpUP7dQb1ZgbV//gf/+Nfjd9F2SbMsc4MggAAAABJRU5ErkJggg=="/&gt;&lt;br&gt;&lt;div style="height: 1.6rem; color: white; font-size: 18px; text-align: center;"&gt;竖屏浏览,体验更佳&lt;/div&gt;&lt;/div&gt;'; document.body.appendChild(landscapeTip); &#125; &#125; function showLandscapeTip() &#123; if (landscapeTip) &#123; landscapeTip.style.display = 'block'; &#125; &#125; function hideLandscpeTip() &#123; if (landscapeTip) &#123; landscapeTip.style.display = 'none'; &#125; &#125; function updateOrientation() &#123; var orientation = window.orientation; switch (orientation) &#123; case 90: case -90: orientation = 'landscape'; showLandscapeTip(); break; default: orientation = 'portrait'; hideLandscpeTip(); break; &#125; &#125; function initOrientationChange() &#123; createLandscapeTip(); window.addEventListener('orientationchange', updateOrientation, false); landscapeTip.addEventListener('touchstart', function(e) &#123; e.preventDefault(); &#125;, false); updateOrientation(); // showLandscapeTip(); // debug &#125; initOrientationChange();&#125;)();]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toast实现]]></title>
    <url>%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFtoast%E6%8F%90%E7%A4%BA.html</url>
    <content type="text"><![CDATA[手动写入前端经常需要写toast提示，每做个项目都得写一些，还是存在来，需要的时候拷贝过去。 JS:1234567891011121314151617181920212223242526272829function toast(message='', ms='1500') &#123; // js写法 var outerDiv = document.createElement('div'); outerDiv.id = "outer-div"; outerDiv.className = "toast-box"; var innerDiv = document.createElement('div'); innerDiv.id = "inner-div"; innerDiv.className = "toast-para"; innerDiv.innerText = message; outerDiv.appendChild(innerDiv); document.body.appendChild(outerDiv); setTimeout(function()&#123; outerDiv.remove() &#125;, ms) // jquery写法 const $toast = "&lt;div class='toast-box'&gt;&lt;p class='toast-para'&gt;" + message + "&lt;/p&gt;&lt;/div&gt;"; jQuery(document.body).append($toast); setTimeout(function()&#123; jQuery('.toast-box').remove() &#125;, ms) // es6写法 const $toast = jQuery(`&lt;div class="toast-box"&gt;&lt;div class="toast-para"&gt;$&#123;message&#125;&lt;/div&gt;&lt;/div&gt;`); jQuery(document.body).append($toast); setTimeout(() =&gt; $toast.remove(), ms);&#125;export default toast 使用：1import toast from 'toast' CSS:12345678910111213141516171819/*toast只占一行，这样分两个标签的原因是为了兼容低版本浏览器*/.toast&#123; width: 100%; position: absolute; left: 0; top: 50%; transform: translate(0, -50%); text-align: center;&#125;.toast-content&#123; height: 1.875rem; line-height: 1.875rem; background: rgba(51,51,51,.8); border-radius: 0.3125rem; word-wrap: break-word; word-break: break-all; padding: 0 0.3125rem; color: #ffffff;&#125; 自动化toast为了更好的更快的开发，我将整个的toast进行了封装，实际应用中只需要引入下面的脚本即可123456789101112131415161718192021222324252627282930313233343536373839404142434445// toast函数function toast (message = '', ms = '1500') &#123; // js写法 var outerDiv = document.createElement('div') outerDiv.id = 'outer-div' outerDiv.className = 'toast-box' var innerDiv = document.createElement('div') innerDiv.id = 'inner-div' innerDiv.className = 'toast-para' addCSS('.toast-box&#123; width:100%; position: fixed; left: 0; top: 50%; margin-top: -1rem; text-align: center; z-index: 999999999; &#125;.toast-para &#123; max-width: 12.5rem; display: inline-block; line-height: 1.5em; margin: auto; font-size: 0.75rem; color: white; background: rgba(0,0,0,.8); border-radius: 0.3125rem; word-wrap: break-word; word-break: break-all; padding: 0.4rem; &#125;') innerDiv.innerText = message outerDiv.appendChild(innerDiv) document.body.appendChild(outerDiv) setTimeout(function () &#123; outerDiv.remove() &#125;, ms)&#125;// 动态添加样式function addCSS (cssText) &#123; var style = document.createElement('style') // 创建一个style元素 var head = document.head || document.getElementsByTagName('head')[0] // 获取head元素 style.type = 'text/css' // 这里必须显示设置style元素的type属性为text/css，否则在ie中不起作用 if (style.styleSheet) &#123; // IE var func = function () &#123; try &#123; // 防止IE中stylesheet数量超过限制而发生错误 style.styleSheet.cssText = cssText &#125; catch (e) &#123; &#125; &#125; // 如果当前styleSheet还不能用，则放到异步中则行 if (style.styleSheet.disabled) &#123; setTimeout(func, 10) &#125; else &#123; func() &#125; &#125; else &#123; // w3c // w3c浏览器中只要创建文本节点插入到style元素中就行了 var textNode = document.createTextNode(cssText) style.appendChild(textNode) &#125; head.appendChild(style) // 把创建的style元素插入到head中&#125;export default toast 使用：1import toast from 'toast' 附加：常用的flex布局、tranform:translateX(-50%)在安卓webview低版本有兼容性 要想使用flex布局，建议参考：https://github.com/cpm828/flex.css]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站IE低版本不兼容提示]]></title>
    <url>%2Fhtml%2F%E7%BD%91%E7%AB%99IE%E4%BD%8E%E7%89%88%E6%9C%AC%E6%8F%90%E7%A4%BA.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738&lt;!--[if lt IE 9]&gt; &lt;div class="ie-disclaimer"&gt; &lt;h2 class="text-20 text-dark text-center ie-disclaimer-title"&gt;不支持的浏览器&lt;/h2&gt; &lt;p class="text-center ie-disclaimer-para"&gt;*** 提醒您，微软正式停止对 Internet Explorer 8、9 和 10 的支持。旧版 IE 将不会再获得安全更新，因此我们不支持这些浏览器。请您更换 IE 11、Chrome、Firefox 或其他现代浏览器访问本站。&lt;/p&gt; &lt;a href="mailto:" class="contactus-btn"&gt;联系我们&lt;/a&gt; &lt;p class="text-ceter"&gt;***客服帮助：***-****-****&lt;/p&gt; &lt;/div&gt;&lt;![endif]--&gt;```css/*IF IE 6、7、8、9*/.ie-disclaimer&#123; width: 500px; max-width: 500px; margin: 2em auto 0; padding: 5em; text-align: center;&#125;.ie-disclaimer-title&#123; font-size: 30px; font-weight: lighter; margin: 100px 0 20px;&#125;.ie-disclaimer-para&#123; line-height: 1.5em;&#125;.contactus-btn&#123; display: block; width: 120px; height: 40px; line-height: 40px; text-align: center; background: #eeeeee; margin: 20px auto;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发的单位处理方法]]></title>
    <url>%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91rem%E5%8D%95%E4%BD%8D%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[引言在PC端开发的时候我们可以直接根据设计稿上的尺寸，直接使用px像素单位即可，但是由于移动端各个设备的宽度不一致，渲染也不一样，所以在移动端开发时不能直接px单位，常用的是使用rem单位。 设置html的基准字号font-size(hmltFontSize) 121rem = 1 * hmltFontSize2rem = 2 * hmltFontSize 故而只需要在不同的手机设置不同的html的基准字号就可以使程序在不同的设备上显示出来的尺寸不一样 如何实现呢？ css+js设置法123456html&#123; visibility: hidden; /* 初始化设置隐藏，但会渲染 */&#125;body&#123; width: 6.4rem; /* body设置rem单位，因为后面脚本需要利用它来充值基准字号 */&#125; head脚本：1234567891011121314// 默认定义基准字号为100px，对应设计稿为640px。如设计稿尺寸有变，则修改下面的计算方式即可。// 在样式中，使用rem单位的值均为设计稿的0.01倍，如设计稿标320px，则设置3.2rem即可。// 设置根字号window.document.documentElement.style.fontSize = window.document.documentElement.clientWidth / 20 + 'px';// 设置viewport属性，安卓4.5以下均设置为1.0，其余通过计算取得var ua = window.navigator.userAgent.toLowerCase();var dpr = window.devicePixelRatio;var scaleValue = 1.0 / dpr;var metaEl = document.createElement('meta');metaEl.setAttribute('name', 'viewport');if (ua.substr(ua.indexOf('android') + 8, 3) &lt; 4.5) metaEl.setAttribute('content', 'initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no');else metaEl.setAttribute('content', 'initial-scale=' + scaleValue + ', maximum-scale=' + scaleValue + ', minimum-scale=' + scaleValue + ', user-scalable=no');document.getElementsByTagName('head')[0].appendChild(metaEl); body脚本（放在dom之后）：12345678// 重置脚本，配合html初始化设置隐藏，脚本加载完之后显示（防止重置时出现颤抖效果）// 重置原因：rem布局在部分安卓手机webview（魅族、华为）表现异常（会超出屏幕）var html = window.document.documentElement;var body = window.document.body;var htmlWidth = html.clientWidth; // 屏幕宽度var bodyWidth = body.offsetWidth; // 设置满屏rem之后的宽度var ratio = bodyWidth / htmlWidth;html.style.fontSize = (ratio &gt; 0 ? (html.style.fontSize.slice(0, -2) / ratio) : (html.style.fontSize.slice(0, -2) * ratio)) + 'px'; // 重置基准字号 scss+js设置法html中初始化iphone4是320px宽的尺寸，在4上16px的字号表现最合适，故而以此来换算，根据各个手机的宽度，来设置不同的基准字号，如下：12345&lt;script&gt; var html = window.document.documentElement; var sw = html.clientWidth; html.style.fontSize = sw * (16 / 320) + 'px';&lt;/script&gt; 设置了html的基准字号之后，在css里面设置尺寸时就可以使用rem了，乘以html后的值就是设计稿的值。 假设设计稿是640宽的，我们可以拿设计稿的尺寸除以32，得到的就是我们需要设置的rem的值。如一个按钮在640的设计稿上的宽高是200*60，那么css里面设置的就是200/32 rem和60/32 rem了。 假设设计稿是W宽，就是拿设计稿的尺寸除以W * (16 / 320)，也即是除以0.05W。 我们总不能每次都用计算器来算rem的值吧！这样效率会很低，研发时间会很长，不值得。 我们又想，如果CSS能够计算就好了，别说还真有，less、sass或stylus等预处理语言都可以在样式里面写运算表达式了，但是既然是预处理语言，就必须编译成普通的css文件才能被浏览器正常读取。具体变异过程见gulp 以sass为例： 我们可以定义一个函数表达式，如下：1234@function r($px) &#123; @return $px / 32 + rem;&#125;/* 32是根据设计来设定的，设计稿的尺寸*0.05 */ 这样我们在scss的样式就可以使用r(设计稿的尺寸)来表示了，最后编译成css文件就可以被浏览器读取了。 但是，你以为这样就好了吗？ NO! rem布局bug解决在web前端开发的过程中，我们最恨谁，当然是浏览器厂商了，就是不按照一个标准来开发浏览器，各式各样的内核，唉！ 经过测试发现，华为、魅族等手机有一些机型会出现使用rem布局超过一屏出现滚动的情况，真是的 v_v 该怎么解决呢？我是这样做的12345678910let html = window.document.documentElementlet sw = html.clientWidthlet sh = html.clientHeightfunction initRem (dom = 'app') &#123; let operateDom = document.getElementById(dom) let operateDomWidth = operateDom.offsetWidth // 最外层盒子使用rem设置，不能使用% let sRatio = sw / operateDomWidth // 计算比例 html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio + 'px' // 重置基准字号&#125; 如果谁有更好的解决方案，欢迎告知！ rem布局bug + 单页应用解决办法上面这种都是针对非一屏的页面，you know!作为一名前端开发工程师，最讨厌的除了低版本的兼容外就是开发一屏的页面了，国内手机厂商太黑心，屏幕宽高比层出不穷，一屏的适配真是难倒一片开发人员，但有时一些活动页又必须是一屏的，该怎么做呢？ 最大的难题就是那些宽大高小（对比设计图）的手机，例如iPhone4，我咧个去，几十年的老机子了，还有人在用，阻挡社会的前进啊！有木有。 我们想，只要在手机上面找到设计图的内容就可以了，如图： 但是这种单页的情况下，又得考虑单页 + rembug的情况，开发的时候就是没注意，就被坑惨了 最终代码代码如下：1234567891011121314151617181920let html = window.document.documentElementlet sw = html.clientWidthlet sh = html.clientHeight// 单页面设置内容宽度基准字号（适配）function initSingleRem (dom1 = 'app', dom2 = 'app') &#123; let operateDom1 = document.getElementById(dom1) let operateDom2 = document.getElementById(dom2) let operateDomWidth1 = operateDom1.offsetWidth let operateDomWidth2 = operateDom2.offsetWidth let sRatio1 = ((750 / 1205) * sh) / sw // 设计稿和屏幕的比例 let sRatio2 = sw / operateDomWidth1 // 屏幕和最外层div的比例 if (sh / sw &lt; 1205 / 750) &#123; // 高小宽大的手机 operateDom2.style.width = operateDomWidth2 * sRatio1 * sRatio2 + 'px' // 设置里层div的宽 &#125; html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio1 * sRatio2 + 'px' // 重置基准字号 operateDom1.style.width = sw + 'px' // 最后将最外层div设为满屏&#125; 这样，所有的内容就在中间黑色的区域内了，就可以达到一屏适配了 终极代码封装成一个库，引用即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 重新设置基准字号（为了兼容部分安卓手机）// 使用initRem()时：最外层div宽必须设置r(750)，不能设置100%）// initSingleRem()时：最外层div和第二层div宽必须设置r(750)，不能设置100%）let html = window.document.documentElementlet sw = html.clientWidthlet sh = html.clientHeight// 非单页设置宽度及基准字号function initRem (dom = 'app') &#123; let operateDom = document.getElementById(dom) let operateDomWidth = operateDom.offsetWidth // 最外层盒子使用rem设置，不能使用% let sRatio = sw / operateDomWidth // 计算比例 html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio + 'px' // 重置基准字号&#125;// 单页面设置内容宽度基准字号（找到中间区域）function initSingleRem (dom1 = 'app', dom2 = 'app') &#123; let operateDom1 = document.getElementById(dom1) let operateDom2 = document.getElementById(dom2) let operateDomWidth1 = operateDom1.offsetWidth let operateDomWidth2 = operateDom2.offsetWidth let sRatio1 = ((750 / 1205) * sh) / sw // 设计稿和屏幕的比例 let sRatio2 = sw / operateDomWidth1 // 屏幕和最外层div的比例 if (sh / sw &lt; 1205 / 750) &#123; // 高小宽大的手机 operateDom2.style.width = operateDomWidth2 * sRatio1 * sRatio2 + 'px' // 设置里层div的宽 html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio1 * sRatio2 + 'px' // 重置基准字号 operateDom1.style.width = sw + 'px' // 最后将最外层div设为满屏 &#125; else &#123; html.style.fontSize = html.style.fontSize.slice(0, -2) * sRatio2 + 'px' // 重置基准字号 &#125;&#125;// 单屏且最外层div铺满屏幕（例如满屏列表项）// 注意：布局时对于接近铺满屏幕的线勿直接适用长度值function initSingleWidth (dom) &#123; let operateDom = document.getElementById(dom) operateDom.style.width = sw + 'px'&#125;// 单屏且内部div铺满屏幕（例如页面中部分元素铺满）function initWidth (dom) &#123; let operateDom = document.getElementById(dom) let operateDomWidth = operateDom.offsetWidth operateDom.style.width = sw + 'px' operateDom.style.marginLeft = -(sw - operateDomWidth) / 2 + 'px'&#125;export &#123; initRem, initSingleRem, initSingleWidth, initWidth&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪类画三角箭头]]></title>
    <url>%2Fcss%2F%E4%BC%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AE%AD%E5%A4%B4.html</url>
    <content type="text"><![CDATA[使用before伪类 123456789.box:before&#123; content: ''; border-top: 9px solid transparent;/*方框上部分背景颜色为透明*/ border-bottom: 9px solid transparent;/*方框下部分背景为透明*/ border-right: 9px solid #eee;/*箭头背景颜色*/ position: absolute;/*绝对定位1*/ top: 25px;/*距离顶部位置偏移量2*/ left: -9px;/*距离左边位置偏移量3*/ /*123都是控制显示位置的*/&#125; 使用after伪类 123456789.box:after&#123; content: ''; border-top: 7px solid transparent; border-bottom: 7px solid transparent; border-right: 7px solid #fbfdfb;/*箭头背景颜色，覆盖前面的#eee颜色，使其颜色与整体颜色一致*/ position: absolute; top: 27px; left: -7px;&#125; tip:需要显示朝向那边，就不需要设置哪边的border，其对向的颜色需设置border，两边设置transparent透明,所有效果均为border模拟出来 如：此例箭头朝向左边，也即是border-left不设置，border-right上色，border-top和border-bottom透明]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他不常用的a链接]]></title>
    <url>%2Fhtml%2F%E5%85%B6%E4%BB%96a%E9%93%BE%E6%8E%A5.html</url>
    <content type="text"><![CDATA[邮箱链接1234567891011121314151617&lt;!-- 最简式 --&gt;&lt;a href="mailto:xxx@xx.com"&gt;联系站长&lt;/a&gt;&lt;!-- cc标签帮你填抄送地址 --&gt;&lt;a href="mailto:xxx@xx.com?cc=xxxx@xx.com"&gt;联系站长&lt;/a&gt;&lt;!-- bcc标签帮你填暗送地址 --&gt;&lt;a href="mailto:xxx@xx.com?bcc=xxxx@xx.com"&gt;联系站长&lt;/a&gt;&lt;!-- subject标签帮你填主题 --&gt;&lt;a href="mailto:xxx@xx.com?subject=给你主页提个建议"&gt;有话直说&lt;/a&gt;&lt;!-- body标签帮你填邮件内容 --&gt;&lt;a href="mailto:xxx@xx.com?body=你的网页做得不错啊,不过就是人气不够哦"&gt;评价&lt;/a&gt;多址发送&lt;a href="mailto:xxx@xx.com,xxxx@xx.com"&gt;联系站长&lt;/a&gt; QQ对话框1&lt;a href="tencent://message/?uin=602455990&amp;Site=QQ交谈&amp;Menu=yes"&gt;点击打开QQ聊天对话框&lt;/a&gt; 电话链接1&lt;a href="tel:13811112222"&gt;13811112222&lt;/a&gt; 短信链接12345678&lt;!-- 给一个号码发短信 --&gt;&lt;a href="sms:10086"&gt;给 10086 发短信&lt;/a&gt;&lt;!-- body标签给一个号码发送已编辑好的短信 --&gt;&lt;a href="sms:10086?body=cxye"&gt;给 10086 发送内容为"cxye"的短信&lt;/a&gt;&lt;!-- body标签给多个号码发送已编辑好的短信 --&gt;&lt;a href="sms:10086,10010?body=cxye"&gt;给 10086 和 10010 发送内容为"cxye"的短信&lt;/a&gt; 注意：发短信的时候有可能会出现乱码，这个与页面的编码格式有关系，需要将页面的编码格式改为 Unicode(UTF-8)。 安卓市场12&lt;!-- 激活安卓市场的搜索功能 --&gt;&lt;a href="market://search?q=MyApp"&gt;MyApp&lt;/a&gt;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析链接中的参数]]></title>
    <url>%2Fjavascript%2F%E8%A7%A3%E6%9E%90%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8F%82%E6%95%B0.html</url>
    <content type="text"><![CDATA[分析 ？参数：?aaa=true&amp;bbb=false hash参数：#aaa=true&amp;bbb=false 解析?参数方法 利用正则表达式 12345678function getQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = decodeURI(window.location.search).substr(1).match(reg); if (r !== null) return unescape(r[2]); return null;&#125;getQueryString('id'); 利用字符串和数组方法（此方法和解析#参数一致，使用window.location.search） 12345678910111213141516171819function getURLParam(strParamName)&#123; var strReturn=''; var query = this.location.search.substring(1); //获取URL中？后面的部分 if (query.length &gt; 0)&#123; var params = query.split("&amp;"); // 以&amp;符号将参数字符串拆分成数组 for (var i = 0 ; i &lt; params.length ; i++)&#123; var pos = params[i].indexOf("="); var name = params[i].substring(0, pos); // 每个参数对的名称 var value = params[i].substring(pos + 1); // 每个参数对的值 if (name == strParamName) &#123; // 找出需要的参数对的值 strReturn = value; &#125; &#125; &#125; return strReturn;&#125;getURLParam('id');// 原理：利用location.search找到?后面的部分，利用&amp;及split组合拆分成数组，利用=及substring解析出每个数组中的名称和值 解析hash参数方法 利用字符串和数组方法（此方法和解析？参数一致，使用window.location.hash）12345678910111213141516171819function getURLHashParam(strParamName)&#123; var strReturn=''; var query = this.location.hash.substring(1); //获取URL中#后面的部分 if (query.length &gt; 0)&#123; var params = query.split("&amp;"); // 以&amp;符号将参数字符串拆分成数组 for (var i = 0 ; i &lt; params.length ; i++)&#123; var pos = params[i].indexOf("="); var name = params[i].substring(0, pos); // 每个参数对的名称 var value = params[i].substring(pos + 1); // 每个参数对的值 if (name == strParamName) &#123; // 找出需要的参数对的值 strReturn = value; &#125; &#125; &#125; return strReturn;&#125;getURLHashParam('id');// 原理：利用location.hash找到#后面的部分，利用&amp;及split组合拆分成数组，利用=及substring解析出每个数组中的名称和值]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符和字节]]></title>
    <url>%2Fhtml%2F%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E8%8A%82.html</url>
    <content type="text"><![CDATA[ASCII码：一个英文字母占一个字节的空间，一个中文汉字占两个字节的空间UTF-8编码：一个英文字符等于一个字节，一个中文等于三个字节Unicode编码：一个英文等于两个字节，一个中文等于两个字节 字符以下均对于ASCII编码格式 1 个空格：占 1 个字符 1 个汉字：占 2 个字符 1 个字母：占 1 个字符 全角符号：占 2 个字符 半角符号：占 1 个字符 字节以下均对于ASCII编码格式 字节：Byte (B) 位： bit (b) 、1 个二进制数据 1GB = 1024MB 1MB = 1024KB 1KB = 1024Byte 1Byte = 8bit (1B = 8b) 1 个汉字 = 1个字符 = 2个字节(2 Byte) = 16 位(16 bit)1 个英文或数字 = 1个字符 = 1 个字节(1 Byte) = 8 位(8 bit) 前端 1 个空格：占 1 个字符 多个空格：多个空格只显示一个空格，即 1 个空格占 1 个字符 &amp;nbsp;： 2 个&amp;nbsp;相当于一个空格，即 2 个&amp;nbsp; 占 1 个字符，一个文字的间隔需要 4 个 &amp;nbsp; 1 个汉字：占 2 个字符 1 个字母：占 1 个字符]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue安装jquery]]></title>
    <url>%2Fvue%2Fvue%E5%AE%89%E8%A3%85jquery.html</url>
    <content type="text"><![CDATA[vue组件中使用jquery 引入CDN1-2或1-3-4-5 1、index.html中引入CDN 2、如果使用window. 在组件中可以直接使用window.$或window.jQuery就可以了 3、如果不想使用window. 可以在build的配置文件中增加全局变量别名123externals: &#123; jquery: 'jQuery'&#125; 4然后在组件中增加（externals中的和import中的和使用的需统一）1import jQuery from 'jquery' 5、然后就可以使用jQuery了1jQuery('.class')..... 不引入CDN不引入CDN就不能使用window.jQuery，也无需到externals中设置别名1、安装jquery1cnpm i -D jquery 2、组件内import1import jQuery from 'jquery' 3、使用1jQuery('.class').....]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex组件间通信]]></title>
    <url>%2Fvue%2Fvuex%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[http://vuex.vuejs.org/zh-cn/intro.htmlhttp://www.tuicool.com/articles/vQBbiiQ 应用原理：A组件 通过 actions 中的事件处理 dispatch 一个 mutations 事件(驼峰式命名) =&gt;mutations 来接收上面的事件，并触发 state 状态改变(大写下划线命名) =&gt;state 响应上面的改变，并存储下来，state专门用来存储交互的date数据 =&gt;B组件 通过 getters 来接收 上面 state 的状态 注：使用vuex时页面不能刷新，否则会丢失vuex数据 数据流为了更好地理解 Vuex app 中的数据流，我们来开发一个简单的计数器 app。注意：这个例子仅仅是为了更好地解释概念，在实际情况中并不需要在这种简单的场合使用 Vuex. Store1234567891011121314151617181920212223242526// store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 应用初始状态const state = &#123; count: 0&#125;// 定义所需的 mutationsconst mutations = &#123; INCREMENT (state) &#123; state.count++ &#125;, DECREMENT (state) &#123; state.count-- &#125;&#125;// 创建 store 实例export default new Vuex.Store(&#123; state, mutations&#125;) Actions123// actions.jsexport const increment = (&#123; dispatch &#125;) =&gt; dispatch('INCREMENT')export const decrement = (&#123; dispatch &#125;) =&gt; dispatch('DECREMENT') Vue 组件里使用模板12345&lt;div&gt; Clicked: &#123;&#123; count &#125;&#125; times &lt;button v-on:click="increment"&gt;+&lt;/button&gt; &lt;button v-on:click="decrement"&gt;-&lt;/button&gt;&lt;/div&gt; 代码12345678910111213141516// 仅需要在根组件中注入 store 实例一次即可import store from './store'import &#123; increment, decrement &#125; from './actions'const app = new Vue(&#123; el: '#app', store, vuex: &#123; getters: &#123; count: state =&gt; state.count &#125;, actions: &#123; increment, decrement &#125; &#125;&#125;) 你会注意到组件本身非常简单：它所做的仅仅是绑定到 state、然后在用户输入时调用 actions。 你也会发现整个应用的数据流是单向的，正如 Flux 最初所定义的那样： 用户在组件中的输入操作触发 action 调用；Actions 通过分发 mutations 来修改 store 实例的状态；Store 实例的状态变化反过来又通过 getters 被组件获知。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django静态文件设置方法]]></title>
    <url>%2Fhtml%2Fdjango%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[全局替换静态资源方法：123// 使用正则替换："\./([^\s]+)" -------- "&#123;% static 'newyear/$1' %&#125;"// 上面的newyear为当前项目的名称 用法: 所有页面顶部引用： 1&#123;% load staticfiles %&#125; 公用的css文件或js外部引入： 1&#123;% include '**/header.html' %&#125; a链接href地址：跳转的页面名如果是驼峰式命名，需改成下划线连接，如indexPage改成index_page；且需指明以何种方式跳转，此处为website:，因为PC端和m端的页面是放在一个目录下的，如website:表示以PC端方式跳转，wapsite:表示以m端方式跳转： 12&#123;% url 'website:index_page' %&#125;&#123;% url 'wapsite:index_page' %&#125; img标签src地址： 1&#123;% static 'website/img/logo.png' %&#125; link标签href地址： 1&#123;% static 'website/css/index.css' %&#125; script标签src地址： 1&#123;% static 'website/js/index.js' %&#125; for循环（开始处加第一行，结尾处加第二行）： 12&#123;% for item in items %&#125;&#123;% endfor %&#125; for循环含特殊控制（最后一下特殊处理，此处表示最后一项含有123456```js&#123;% for item in items %&#125;&#123;% if forloop.last %&#125;&lt;/a&gt;&#123;% endif %&#125;&#123;% endfor %&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-validator表单验证]]></title>
    <url>%2Fvue%2Fvue-validator%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html</url>
    <content type="text"><![CDATA[简单用法 1、安装vue-validator 2、main.js中引入vue-validator12import Validator from 'vue-validator'Vue.use(Validator) 3、表单中使用常用的验证包括 required 必填 min 、max 最小最大值 minlength 、maxlength 最小最大长度 pattern 正则表达式12345678910111213validator(name="validator") // name名称任意，但唯一，同一页面可使用多个validator input(v-model="userName" v-validate:user-name="&#123; required : true &#125;") p.error(v-if="$validator.userName.required") 请输入用户名 input(v-model="userPwd" v-validate:user-pwd="&#123; required : true &#125;") p.error(v-if="$validator.userPwd.required") 请输入用户密码 input(v-model="userSpend" v-validate:user-spend="&#123; required : true, min : 100, max : 10000 &#125;") p.error(v-if="$validator.userSpend.required || $validator.userSpend.min || $validator.userSpend.max") 请输入用户每月话费，100~10000 input(v-model="userNickname" v-validate:user-nickname="&#123; required : true, minlength : 1, maxlength : 10 &#125;") p.error(v-if="$validatoruserNickname.required || $validatoruserNickname.minlength || $validatoruserNickname.maxlength") 请输入用户昵称，长度1~10 1234567891011121314151617data () &#123; btnNotActive:&#125;,computed: &#123; btnNotActive () &#123; this.$validator.userName || this.$validator.userPwd || this.$validator.userSpend || this.$validator.userNickname&#125;,methods: &#123; btnClick () &#123; if (!btnNotActive) &#123; // 已激活状态才可点击 console.log('按钮点击') &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource前后端请求]]></title>
    <url>%2Fvue%2Fvue-resource%E5%89%8D%E5%90%8E%E7%AB%AF%E8%AF%B7%E6%B1%82.html</url>
    <content type="text"><![CDATA[vue 有自己的请求机制，即vue-resource https://github.com/pagekit/vue-resource 123456789&lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.0.3/vue-resource.min.js&quot;&gt;&lt;/script&gt;&#123; // GET or POST this.$http.get(&apos;url&apos;).then((response) =&gt; &#123; // success callback &#125;, (response) =&gt; &#123; // error callback &#125;)&#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断用户设备]]></title>
    <url>%2Fjavascript%2Fjs%E5%88%A4%E6%96%AD%E8%AE%BE%E5%A4%87.html</url>
    <content type="text"><![CDATA[判断PC端还是移动端123456789function mobilecheck() &#123; var check = false; (function(a,b) &#123; if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true&#125;)(navigator.userAgent||navigator.vendor||window.opera); return check;&#125;if (mobilecheck()) &#123; // 非pc环境&#125; 判断设备是IOS设备还是其他设备123456789101112131415161718192021222324var browser=&#123; //检测设备 versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; trident: u.indexOf(&apos;Trident&apos;) &gt; -1, presto: u.indexOf(&apos;Presto&apos;) &gt; -1, webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, mobile: !!u.match(/AppleWebKit.*Mobile.*/), ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 , iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, webApp: u.indexOf(&apos;Safari&apos;) == -1 &#125; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125;;if(browser.versions.ios || browser.versions.iPhone || browser.versions.iPad)&#123; // 苹果设备&#125; else &#123; // 非苹果设备&#125; 判断是否是微信1var isOnWeixin = navigator.userAgent.indexOf("MicroMessenger") &gt; -1; // 识别客户端 在微信中判断当前设备123456789if(isOnWeixin)&#123; //微信端 if(browser.versions.ios || browser.versions.iPhone || browser.versions.iPad)&#123; //苹果设备 &#125; else &#123; //非苹果设备 &#125;&#125; else &#123; //非微信端&#125; 参考：http://ju.outofmemory.cn/entry/117648]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.location地址栏详解]]></title>
    <url>%2Fhtml%2Fwindow.location%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[示例链接：http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html?id=2&amp;name=ddd 12345678window.location.hef: 全部地址window.location.search: 后面参数 （?id=2&amp;name=ddd）window.location.host: 主机名 （mp.weixin.qq.com）window.location.hostname: 主机名 （mp.weixin.qq.com）window.location.origin: 域名 （http://mp.weixin.qq.com）window.location.pathname: 路径 （/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html）window.location.protocol: 协议 （http:）window.location.port: 端口 （此例没有）]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli脚手架]]></title>
    <url>%2Fvue%2Fvue-cli%E8%84%9A%E6%89%8B%E6%9E%B6.html</url>
    <content type="text"><![CDATA[vue-cli单页面脚手架123456789101、cd到总文件夹2、cnpm install -g vue-cli3、vue init webpack *** （webpack表示一种模式，***表示所需的项目名称） 如果安装vue1.0 webpack#1.04、回车...（前三个yes，后三个no）5、cd 到项目目录6、cnpm install7、cnpm run dev8、执行cnpm run build （启动编译，生成编译后的dist文件） 基于vue-cli改写的多页面模板脚手架 https://github.com/jarvan4dev/vue-multi-pagehttp://codecloud.net/17221.htmlhttps://github.com/cpm828/vue-multi-cli]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现置顶和置底效果]]></title>
    <url>%2Fjquery%2F%E5%AE%9E%E7%8E%B0%E7%BD%AE%E9%A1%B6%E5%92%8C%E7%BD%AE%E5%BA%95.html</url>
    <content type="text"><![CDATA[置顶效果 123456789101112$(window).on('scroll', function() &#123; if ($(window).scrollTop() &gt;= 100) &#123; // 滚动了100之后显示 $('.gotopbox').fadeIn(300); &#125; else &#123; $('.gotopbox').fadeOut(300); &#125;&#125;);$('.gotopbox').on('click', function()&#123; // 点击置顶 $('html, body').animate(&#123; scrollTop: '0px' &#125;, 500);&#125;); 置底效果 123456789101112$(window).on('scroll', function() &#123; if ($(window).scrollTop() &gt;= 100) &#123; // 滚动了100之后显示 $('.gotopbox').fadeIn(300); &#125; else &#123; $('.gotopbox').fadeOut(300); &#125;&#125;);$('.gobottombox').on('click', function()&#123; // 点击置顶 $('html, body').animate(&#123; scrollTop: document.body.clientHeight+'px' &#125;, 500);&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件传递数据]]></title>
    <url>%2Fvue%2Fvue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[父组件修改子组件 vue官方介绍：http://cn.vuejs.org/v2/guide/components.html#单向数据流 传递单个变量例1： 父组件：123456789101112// html:btn(@click="isShowDesigner = true")// 引用子组件designer(:msg.sync='isShowDesigner' v-show="isShowDesigner")// script:data()&#123; return &#123; isShowDesigner: false &#125;&#125;,components: &#123;Designer&#125; 子组件designer：1234567891011// html:btn(@click="dismiss()")// script:props: ['msg'],methods: &#123; dismiss()&#123; this.msg = false &#125;&#125; 例1解析：例1父子组件之间传递的是一个变量，父级派发一个msg事件，用来传递isShowDesigner变量，子组件通过props来接收父级派发的事件msg。此时在父组件中使用isShowDesigner变量，子组件中使用msg代替isShowDesigner变量 传递一个object对象例2： 父组件：12345678910111213// html:btn(@click="designerMessage.isShowDesigner = true")// 引用子组件designer(:designer-msg.sync='designerMessage' v-show="designerMessage.isShowDesigner")// script:data()&#123; designerMessage: &#123; isShowDesigner: false, designerInfo: '' &#125;&#125;,components: &#123;Designer&#125; 子组件designer：1234567891011121314151617// html:input(v-model="inputText")btn(@click="dismiss()")// script:props: ['designerMsg'],data() &#123; return &#123; inputText: '' &#125;&#125;,methods: &#123; dismiss()&#123; this.designerMsg.isShowDesigner = false this.designerMsg.designerInfo = this.inputText &#125;&#125; 例2解析：例2中父级派发designer-msg（不能使用驼峰时，连接符），子级通过designerMsg（使用驼峰时）接收，传递的是一个对象，传递对象时可不使用.sync，默认就是双向绑定；当子组件有多个父级时，props后面可以写多个 指定验证规则的传递如果传入的数据不符合要求，Vue会发出警告父组件：1234567891011// htmldesigner(:prop-a="propDataA", :prop-b="propDataB", :prop-c="propDataC")// scriptdata () &#123; return &#123; propDataA: '', propDataB: '', propDataC: '' &#125;&#125; 子组件designer:1234567891011121314151617181920212223242526272829303132// html// scriptprops: &#123; // 基础类型检测(null允许任何类型) propA: Number, // 可能是多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字且有默认值 poopD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'Hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; valiator: function (value) &#123; return value &gt; 10 &#125; &#125;&#125; type可以是下面原生构造器： String Number Boolean Function Object Array Symbol type也可以是一个自定义的构造器函数，使用instanceof检测 子组件修改父组件 vue官方介绍：http://cn.vuejs.org/v2/guide/components.html#使用-v-on-绑定自定义事件other：http://www.cnblogs.com/wisewrong/p/6266038.html 只触发事件，不传递数据子组件designer:1234567btn(@click=&quot;ShowSibling&quot;)methods：&#123; ShowSibling () &#123; this.$emit(&apos;showBrother&apos;) // 派发一个事件，显示兄弟组件 &#125;&#125; 父组件：1234567891011designer(@showBrowther=&quot;showOtherChildren&quot;)data () &#123; return &#123; &#125;&#125;,methods: &#123; showOtherChildren (msg) &#123; this.otherChildren.isShow = true // 控制显示其他的子组件 &#125;&#125; 触发事件同时传递数据子组件designer:123456789101112btn(@click=&quot;ShowSibling&quot;)data () &#123; return &#123; propHandle: &apos;&apos; &#125;&#125;,methods：&#123; ShowSibling () &#123; this.$emit(&apos;showBrother&apos;, propHandle) // 派发一个事件，去显示兄弟组件，同时传递transmitData数据 &#125;&#125; 父组件：123456789101112131415designer(@showBrowther=&quot;showOtherChildren&quot;)data () &#123; return &#123; getData: &apos;&apos; &#125;&#125;,methods: &#123; // 此例在html中写成@showBrowther=&quot;showOtherChildren&quot; // 也可在事件中心写this.$on(&apos;showOtherChildren&apos;, &#123;&#125;) showOtherChildren (msg) &#123; this.otherChildren.isShow = true // 控制显示其他的子组件 this.getData = msg // 控制显示其他的子组件 &#125;&#125; 兄弟组件之间修改 vue官方介绍：http://cn.vuejs.org/v2/guide/components.html#非父子组件通信vue1.0升2.0：https://cn.vuejs.org/v2/guide/migration.html#dispatch-和-broadcast-替换other：http://www.javascriptcn.com/read-1774.html 有时候两个非父子组件之间也需要通信，如兄弟组件或祖父子组件，我们可以考虑使用一个空的Vue实例作为中央事件总线： 公共js:1234import Vue from 'vue'let eventHub = new Vue()export default eventHub 子组件A:12345678910// NewTodoInputimport eventHub from '../utilities/centerHub'methods: &#123; addTodo: function () &#123; eventHub.$emit('add-todo', &#123; text: this.newTodoText &#125;) this.newTodoText = '' &#125;&#125; 子组件B:123456789// DeleteTodoButtonimport eventHub from '../utilities/centerHub'methods: &#123; deleteTodo: function (id) &#123; eventHub.$emit('delete-todo', id) &#125;&#125; 父组件：12345678910111213141516171819202122// Todoscreated: function () &#123; eventHub.$on('add-todo', this.addTodo) eventHub.$on('delete-todo', this.deleteTodo)&#125;,// 最好在组件销毁前// 清除事件监听beforeDestroy: function () &#123; eventHub.$off('add-todo', this.addTodo) eventHub.$off('delete-todo', this.deleteTodo)&#125;,methods: &#123; addTodo: function (newTodo) &#123; this.todos.push(newTodo) &#125;, deleteTodo: function (todoId) &#123; this.todos = this.todos.filter(function (todo) &#123; return todo.id !== todoId &#125;) &#125;&#125; 复杂组件通信复杂的组件通信应当考虑使用vuex来通信 vuex官方介绍：http://vuex.vuejs.org/zh-cn/intro.html个人：http://pimichen.com/vue/vuex%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html 注：$dispatch和$broadcast在vue2.0中已经被移除]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本溢出显示...]]></title>
    <url>%2Fcss%2F%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA....html</url>
    <content type="text"><![CDATA[单行文本溢出123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 多行文本溢出方法1（存在兼容性，兼容移动端）12345678overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;padding-left: r(12);word-wrap: break-word; //防止长单词溢出word-break: break-all; //防止长单词折行 方法2（伪类实现，只适合已确定超出指定行数的）12345678910111213141516p&#123; position:relative; height: 3em; // 定高，超过两行隐藏 overflow: hidden; word-wrap: break-word; word-break: break-all;&#125;p::after&#123; content:"..."; font-weight:bold; position:absolute; bottom:0; right:0; padding: 0 2px; background: -webkit-linear-gradient(left, transparent, #fff 55%);&#125; 方法3(jQuery.dotdotdot) 参考：Github、官网12345$(document).ready(function() &#123; $("#wrapper").dotdotdot(&#123; // configuration goes here &#125;);&#125;); 方法4(Clamp.js) 参考：https://github.com/josephschmitt/Clamp.js123var module = document.getElementById("clamp-this-module");$clamp(module, &#123;clamp: 3&#125;); 方法5（ftellipsis.js） 参考：https://github.com/ftlabs/ftellipsis12345var element = document.getElementById('my-element');var ellipsis = new Ellipsis(element);ellipsis.calc();ellipsis.set();]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css设置placeholder]]></title>
    <url>%2Fcss%2Fcss%E8%AE%BE%E7%BD%AEplaceholder.html</url>
    <content type="text"><![CDATA[http://stackoverflow.com/questions/4919680/html5-placeholder-css-padding 123456789101112input::-webkit-input-placeholder &#123; /* WebKit browsers */ line-height: 1.5em;&#125;input:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */ line-height: 1.5em;&#125;input::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ line-height: 1.5em;&#125;input:-ms-input-placeholder &#123; /* Internet Explorer 10+ */ line-height: 1.5em;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PC端导航条上二级菜单的提示箭头]]></title>
    <url>%2Fhtml%2FPC%E5%AF%BC%E8%88%AA%E5%9B%BE%E9%BC%A0%E6%A0%87%E5%88%92%E8%BF%87%E7%AE%AD%E5%A4%B4%E7%9A%84%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%8F%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[字体下载 1234@font-face&#123; src: url('../font/arrow.ttf'); font-family: 'arrow';&#125; 1234567891011121314151617181920*:after &#123; box-sizing: border-box;&#125;.user-mail:after&#123; content: "\e602"; position: absolute; top: 50%; right: 0; transform: translate(0, -50%); font-family: 'arrow'; /*自定义字体来显示小图标*/ font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; vertical-align: middle;&#125;.user-mail:hover:after&#123; content: "\e603";&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meta标签]]></title>
    <url>%2Fhtml%2Fmeta%E6%A0%87%E7%AD%BE.html</url>
    <content type="text"><![CDATA[name属性 description网站描述（content中为一段介绍语） 1&lt;meta name="description" content="今天是个好日子，嘻嘻哈哈我们真开心。"&gt; keywords关键字（content中为关键字，以英文逗号分开） 1&lt;meta name="keywords" content="**,**,**,**"&gt; viewport移动端窗口 1&lt;meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no"&gt; 参数：width=device-width:视口宽度等于设备浏览器视窗宽度initial-scale=1 :缩放比为1:1，对于retina屏，根据dpr的值设定该值user-scalable=no :禁止移动端缩放 12345var scaleValue = 1.0 / dpr;var metaEl = document.createElement(&apos;meta&apos;);metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scaleValue + &apos;, maximum-scale=&apos; + scaleValue + &apos;, minimum-scale=&apos; + scaleValue + &apos;, user-scalable=no&apos;);document.getElementsByTagName(&apos;head&apos;)[0].appendChild(metaEl); 详见：http://www.ghugo.com/css-retina-hairline/ robots定义搜索引擎爬虫的索引方式 1&lt;meta name="robots" content="none"&gt; 参数：none : 搜索引擎将忽略此网页，等价于 noindex，nofollow。noindex : 搜索引擎不索引此网页。nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于 index，follow。index : 搜索引擎索引此网页。follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。 搜索引擎爬虫重访时间 1&lt;meta name="revisit-after" content="7 days" &gt; 作者信息 1&lt;meta name="author" content="Lxxyx,841380530@qq.com"&gt; 网页制作软件 1&lt;meta name="generator" content="Sublime Text3"&gt; 版权信息 1&lt;meta name="copyright" content="Lxxyx"&gt; //代表该网站为Lxxyx个人版权所有。 http-equiv属性 X-UA-Compatible浏览器采取何种版本渲染当前页面 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; //指定IE和Chrome使用最新版本渲染当前页面 cache-control指定请求和响应遵循的缓存机制 1&lt;meta http-equiv="cache-control" content="no-cache"&gt; 参数：no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响 应）maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。 expires网页到期时间 1&lt;meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" /&gt; Set-Cookie设置cookie 12&lt;meta http-equiv="Set-Cookie" content="name, date"&gt; //格式&lt;meta http-equiv="Set-Cookie" content="User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT"&gt; //具体范例 refresh指定时间内页面自动刷新或指向指定页面 12&lt;meta http-equiv="refresh" content="2"&gt; //2秒刷新一次&lt;meta http-equiv="refresh" content="2；URL=http://www.baidu.com"&gt; //2秒后跳转到百度页面]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当锚点遇上顶部header占位的解决办法]]></title>
    <url>%2Fhtml%2FPC%E5%AF%BC%E8%88%AA%E6%9D%A1%E4%B8%8A%E4%BA%8C%E7%BA%A7%E8%8F%9C%E5%8D%95%E7%9A%84%E6%8F%90%E7%A4%BA%E7%AE%AD%E5%A4%B4.html</url>
    <content type="text"></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[footer自适应底部位置]]></title>
    <url>%2Fhtml%2Ffooter%E8%87%AA%E9%80%82%E5%BA%94%E4%BD%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[对于页面的footer部分，有时有这样的需求1、footer始终固定在页面的底部。2、当页面内容少于一屏时显示在页面底部，多于一屏时跟随内容前进，在内容的底部。 对于1来说，直接定位在底部就可以对于2来说，就需要考虑情况了，我们可以使用css来解决这种情况 解决办法：margin + padding + min-height 中间主体部分使用min-height：100% ，padding上下为header和footer的高度 header使用margin-bottom为负的高度，footer使用margin-top为负的高度 中间区域最小高度为一屏，小于一屏时显示一屏高度，大于一屏时为内容高度 html：123&lt;div class=&quot;header&quot;&gt;头部&lt;/div&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;底部&lt;/div&gt; css:1234567891011121314151617181920212223242526*&#123; margin: 0; padding: 0; box-sizing: border-box;&#125;html,body &#123; height: 100%;&#125;.header &#123; height: 80px; margin-bottom: -80px; background: #1381cc; color: #FFF; position: relative;&#125;.content &#123; background: #CCC; min-height: 100%; padding: 80px 0 100px;&#125;.footer &#123; height:100px; margin-top: -100px; background: #0c4367; color: #FFF;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行命令自动复制粘贴文件]]></title>
    <url>%2Fnode%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[拷贝脚本，修改后面的复制粘贴目录即可：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495var fs = require(&apos;fs&apos;)var path = require(&quot;path&quot;)var process = require(&apos;process&apos;)// 文件遍历，为一切操作的基础方法function traversal (dir, cb_isDir, cb_isFile) &#123; var absDir = path.resolve(dir) fs.readdirSync(absDir).forEach(file =&gt; &#123; var pathname = path.join(absDir, file) if (fs.statSync(pathname).isDirectory()) &#123; // 文件夹操作 // stop： 是否停止在该文件夹遍历 // 回调函数中不返回或返回false，继续遍历该文件夹。 // 回调函数中返回true, 停止遍历该文件夹。例如回调函数要删除文件夹时。 // 回调函数中返回字符串，会按返回值进行遍历。例如回调函数更改了文件夹名称时。 var stop = false if (cb_isDir) stop = cb_isDir(pathname) if(!stop) &#123; // 如果停止标志返回false，则继续遍历 traversal(pathname, cb_isDir, cb_isFile) &#125; else if (typeof stop === &apos;string&apos;) &#123; // 如果停止标志返回了新的路径，则遍历新的路径 traversal(path.resolve(stop), cb_isDir, cb_isFile) &#125; &#125; else &#123; // 文件操作 if(cb_isFile) cb_isFile(pathname) &#125; &#125;)&#125;// 复制文件function copy (src, dest) &#123; // 内部函数，对指定路径的复制操作 function _copy(pathname) &#123; var destPath = path.resolve(pathname) .replace(path.resolve(src), path.resolve(dest)) if (fs.statSync(pathname).isFile()) &#123; // 如果原路径是文件，直接复制 console.log(`正在复制文件$&#123;destPath&#125; ...`) if (src === pathname) &#123; fs.writeFileSync(path.join(destPath, path.basename(src)), fs.readFileSync(path.resolve(pathname))) &#125; else &#123; fs.writeFileSync(path.join(destPath), fs.readFileSync(path.resolve(pathname))) &#125; &#125; else &#123; // 如果原路径是文件夹，检测是否在目标路径存在 // 若不存在则新建文件夹，否则不做任何事情 try &#123; fs.statSync(destPath) &#125; catch (err) &#123; if (err.code === &apos;ENOENT&apos;) &#123; console.log(`正在创建文件夹$&#123;destPath&#125; ...`) fs.mkdirSync(destPath) &#125; else console.error(err) &#125; &#125; &#125; // copy函数主体 if (fs.statSync(src).isDirectory()) traversal(src, _copy, _copy) else _copy(src)&#125;// 清除指定目录下的所有文件（不删除目录）function clear(src) &#123; traversal(src, null, pathname =&gt; &#123; console.log(`正在删除文件$&#123;pathname&#125; ...`) fs.unlinkSync(pathname) &#125;) traversal(src, pathname =&gt; &#123; console.log(`正在删除文件夹$&#123;pathname&#125; ...`) fs.rmdirSync(pathname) return true &#125;, null)&#125;// 执行本项目复制命令命令!function()&#123; // 复制前的目录 var former_template = &apos;./dist&apos; var former_static = &apos;./dist/static&apos; // 复制后的目录 var dist_template = &apos;../kuaihongbao/guessgame/templates&apos; var dist_static = &apos;../kuaihongbao/guessgame/static&apos; // 清除目录 clear(dist_template) clear(dist_static) // 复制目录 copy(former_template + &apos;/guess-index.html&apos;, dist_template) copy(former_static, dist_static)&#125;() 使用方法 手动执行复制命令 1run build完之后执行命令：node build/**.js 自动复制命令对于vue-cli来说，将脚本添加到build目录下 12在 packet.json中的script dev build 中添加 &quot;&amp;&amp; node build/**.js&quot;编译：cnpm run build 时会自动执行复制脚本 注意1后端需要的index文件的名称可能不一定，在vue/config/index.js中的编译配置里面修改编译后的名称即可]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见兼容性的处理办法]]></title>
    <url>%2Fcss%2Fcss%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[前端常见的浏览器兼容性问题及解决方法 png24位的图片在iE6浏览器上出现背景解决方案：做成PNG8，也可以引用一段脚本处理。 浏览器默认的margin和padding不同解决方案：加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。如：#box{ float:left; width:10px; margin:0 0 0 10px;}解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。( _ 这个符号只有ie6会识别)这种情况之下IE会产生20px的距离 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用 “+” 将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456bb &#123; background-color:#f1ee18; /*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff; /*IE6、7识别*/ _background-color:#1e0bd1; /*IE6识别*/&#125; IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute 获取自定义属性；Firefox下,只能使用getAttribute获取自定义属性解决方法：统一通过getAttribute获取自定义属性 IE下，event对象有 x、y 属性，但是没有pageX、pageY属性; Firefox下，event对象有pageX、pageY属性，但是没有 x、y 属性解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示解决方法：可通过加入 CSS 属性-webkit-text-size-adjust: none;解决 超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有hover和active了解决方法：改变CSS属性的排列顺序 L-V-H-A 1234a:link &#123;&#125;a:visited &#123;&#125;a:hover &#123;&#125;a:active &#123;&#125; 怪异模式问题：漏写 DTD 声明，Firefox 仍然会按照标准模式来解析网页，但在 IE 中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写 DTD 声明的好习惯。现在可以使用html5 推荐的写法：&lt;!DOCTYPE html&gt; 上下margin重合问题：ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。解决方法：养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 ie6对png图片格式支持不好解决方案：引用一段脚本处理]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试知识点]]></title>
    <url>%2Fother%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[请输入密码：提交 闭包面试题123456789func(1)(2) = 3func(3)(5) = 8由上例推导函数主体function func(num1) &#123; return function func(num2) &#123; return num1 + num2 &#125;&#125; 对web标准及W3C的理解和认识标签闭合、标签小写、使用外部链接脚本和样式、结构层行为层和表现层的分离、内容能被更多的用户访问、内容能被更多的设备访问、更少的代码及组件，容易维护 什么是前端？前台的设计,包括动画制作,图像处理,文字编辑,版面设计一名合格的前端开发工程师，应该具有一定的审美能力和基础的美工操作能力，能很好的与交互及视觉协作 xhtml和html的区别 html是一种基本的web网页设计语言，xhtml是一个基于xml的置标语言 不同点： xhtml必须正确嵌套 xhtml元素必须关闭 标签名必须小写 xhtml文档必须拥有根元素 为什么选择H5 更具有语义性 更支持搜索引擎的搜索（直观的认识标签） 阅读性更强，支持残障人士的阅读 H5的特性 简单易记的语言标签 简单易记的编码类型 不需要标签闭合 标签名不区分大小写 语义化的新增标签 表单增强 视频和音频 canvas绘画 css引入方式：行内样式、内嵌样式、外部链接样式、导入样式（@import url(&quot;&quot;);）link和@import的区别：link无兼容性，link支持js操控 css权重优先级!important &gt; 内嵌样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器和伪类选择器 &gt; 通用选择器 SEO优化文件合并、文件压缩、CDN托管（内容分发网络）、利用缓存 主流浏览器的内核和厂商前缀： 火狐：Gecko -moz- 谷歌：webkit -webkit- IE:ie内核/Trident -ms- 欧朋：Presto -o- 强制转换和隐式转换 强制：parseInt、parseFloat、number 隐式：（直接将一种类型赋值给另一种类型） parseInt()、parseFloat()和number parseInt()：将字符串开头的整数分解出来，转换为整数 parseInt(“123”)、parseInt(“123.45”)、parseInt(“123.45abc”) 返回123 parseInt(“abc123”)、parseInt(true) 返回NaN parseFloat()：将字符串开头的整数或浮点数分解出来，转换为浮点数 parseFloat(“123.45”)、parseFloat(“123.45abc”) 返回123.45 parseFloat(“abc 123.45”)、parseFloat(“true”) 返回NaN number()：将对象的值转换成数字 Javascript的对象Javascript的本地对象、内置对象、宿主对象和自定义对象 本地对象：date、array、string、number、object、function、regexp、boolean,可以new实例化 内置对象：global、load、Math不可以实例化（每个内置对象都是本地对象） 宿主（浏览器）对象：document、window 自定义对象：开发人员自定仪的对象通常来说：本地对象和内置对象可以归为一类，即分为本地对象、宿主对象和自定义对象 JS的数据类型JS是一种弱语言类型的语言number、string、boolean、object、function、underfined 基本类型：存放在栈中：number、string、boolean 引用类型：存放在堆中：object、function 事件绑定和普通事件的区别事件绑定可以添加多个事件 事件冒泡、事件捕获、事件委托、事件绑定、事件默认行为 事件冒泡：触发子级事件会同时向上触发父级的事件addEventListener(&#39;click&#39;,abc,false); // 默认事件冒泡 阻止事件冒泡：event.stopPropagation(); // return false; 事件捕获：触发父级事件会同时向下触发子级的事addEventListener(&#39;click&#39;,abc,true); //事件捕获 事件委托：让其他的元素帮忙处理事件，如让ul来处理li的事件 123456789101112&lt;!-- HTML: --&gt;&lt;ul id="parent-list"&gt; &lt;li id="post-1" class="it-1"&gt;Item 1&lt;/li&gt; &lt;li id="post-2"&gt;Item 2&lt;/li&gt; &lt;li id="post-3"&gt;Item 3&lt;/li&gt; &lt;li id="post-4"&gt;Item 4&lt;/li&gt; &lt;li id="post-5"&gt;Item 5&lt;/li&gt; &lt;li id="post-6" class="it-1"&gt;Item 6&lt;/li&gt; &lt;span id="post-7" class="pt-7"&gt;&lt;/span&gt; &lt;strong id="post-8"&gt;&lt;/strong&gt; &lt;em id="post-9" class="pt-7"&gt;&lt;/em&gt;&lt;/ul&gt; 12345678910111213141516// JS:$('#parent-list').on('click', 'li', function()&#123; //为子级绑定事件 var number = $(this).index(); //获取当前子级的索引值 console.log('number', number); var check = $('li').eq(number).attr('id'); //获取相应的属性值 console.log('check', check); alert('当前的id为：' + check);&#125;);$('#parent-list').on('click', function(e)&#123; var ev = e || window.event; //事件对象兼容 var etarget = ev.target || ev.srcElement; //事件源兼容 if (etarget &amp;&amp; etarget.nodeName == 'LI') &#123; //nodeName为大写字母 alert('当前的id为：' + etarget.id); &#125;&#125;); 事件绑定：为某个对象绑定事件，可以绑定多个 1234567// JS:addEventListener('click',abc,false); //W3C绑定attachEvent('onclick',abc); //IE绑定// jQuery:bind();on(); 事件默认行为：如链接a 阻止事件默认行为：return false; 或 event.preventDefault(); 函数闭包允许使用内部函数（函数定义和函数表达式位于另一个函数的函数体内），这些内部函数可以访问它们所在外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。也就是内部函数在外部函数返回后执行。而当这个内部函数执行时，它仍然必须访问其外部函数的局部变量、参数以及内部函数。这些局部变量、参数和函数声明的值是外部函数返回的值，但也会受到内部函数的影响 ajax中get和post区别 get post 从服务器上获取数据 向服务器上传递数据 将表单数据添加到url后面 将表单数据放在虚拟载体中 不安全，用户可以看到数据 相对用户安全，操作对用户不可见 传输数据量小，url长度限制默认 传输数据量大（上传文件只能使用post） AJAX的异步机制，优缺点核心是XMLHttpRequest对象XMLHttpRequest对象是的JS脚本能够实现对服务器的异步请求，向后台发送请求并接收服务器响应，动态获取响应数据来更新局部页面 优点 页面无刷新即可更新页面，用户体验好 异步方式与服务器通信，不需要打断用户操作，响应能力快 可以让客户端来处理一些工作，减轻服务器带宽 不需要下载插件 促进页面和数据的分离 缺点： 兼容性 破坏前进和后退按钮 对流媒体和移动设备支持易购 对搜索引擎的支持比较弱12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// JS:if(window.XMLHttpRequest)&#123; var ajax = new XMLHttpRequest();&#125;else&#123; var ajax = new ActiveXObject(“Microsoft.XMLHttp”);&#125;ajax.open('GET','***',true);ajax.send();ajax.onreadystatechange = function()&#123; if(ajax.readyState == 4)&#123; if(ajax.status == 200)&#123; alert(ajax.responseText); &#125;else&#123; alert(“失败！”); &#125; &#125;&#125;// JQuery:$.ajax(&#123; url: 'api.php', type: 'GET', dataType: 'json', timeout: 3000, data: &#123; num1: num1, num2: num2 &#125;, beforeSend: function(xhr, settings) &#123; // 发送请求前 console.log('beforeSend', xhr, settings); &#125;, success: function(data, status, xhr) &#123; // 请求成功 console.log('success', data, status, xhr); if (data.code === 0) &#123; console.log('处理成功'); $('#result').val(data.result); &#125; else &#123; console.log('处理失败'); &#125; &#125;, error: function(xhr, errorType, error) &#123; // 请求失败 console.log('error', xhr, errorType, error); alert('请求失败'); &#125;, complete: function(xhr, status) &#123; // 请求成功或失败都执行 console.log('complete', xhr, status); &#125;&#125;); 测出页面加载时间 12345678910111213&lt;!-- HEAD: --&gt;&lt;script&gt; var a = new Date().getTime(); //获取初始时间&lt;/script&gt;&lt;!-- BODY: --&gt;&lt;script&gt; window.onload = function()&#123; document.getElementById('div1').innerHTML = "页面加载时间："+ (new Date().getTime()-a)+"毫秒"; &#125;&lt;/script&gt;&lt;div id="div1"&gt;&lt;/div&gt; ECMAScript规范最新版：ECMA-262 《ECMAScript国际标准（第6版）》 2015年6月 ECMAScrip规范是为了解决早期Web浏览器支持的Javascript脚本编程语言而制定的技术标准，目前来说，被浏览器广泛支持的是 ECMAScript 规范第三版 包括： 在广大Web浏览器/Web服务器等宿主环境中实现的Javascript 在Microsoft Internet Explorer（IE浏览器）/IIS中实现的JScript 在Adobe/Macromedia的Flash、Director等软件中实现的ActionScript 实现的基本内容： 类型：Undefined、Null、Boolean、Number、String 和 Object 对象和属性：对象是属性的集合，属性包括命名数据属性、命名访问器属性和内部属性 函数：三种创建方法 使用构造函数function 使用函数声明 使用函数表达式 数组：内置对象array，本身相当于一个构造函数，可以用来创建新的数组实例 Array.prototype.every：该函数用来判断数组中的全部元素是否都满足给定的条件。条件是通过作为参数的另一个函数来指定的。函数的返回值（true或 false）决定了条件是否满足 Array.prototype.forEach：该函数用来遍历数组中的所有元素，对每个元素调用由参数指定的函数 Array.prototype.map：该函数对数组中的每个元素执行特定的处理，并把处理的结果保存在一个新的数组中 Array.prototype.filter：该函数根据给定的条件对数组中的元素进行过滤。只有满足条件的元素才会出现在结果数组中 Array.prototype.reduce 和 Array.prototype.reduceRight：这两个函数用来对数组中的元素进行累积操作。上一次操作的结果会作为下一次操作的输入值。两个函数的区别在于 reduceRight 是从数组的末尾开始进行处理。 JSON：第五版开始支持，JSON 也通常被用来作为客户端与服务器端之间的数据传输格式代码执行：ECMAScript 代码的执行由运行环境来完成，通过 eval 函数也可以指定一段需要执行的代码，代码的基本执行方式是从上到下，顺序执行 严格模式： 注：必须实现该规范描述的所有的“类型、值、对象、属性、函数和程序语法及语义”，并且必须支持Unicode字符标准（UCS）。在此基础上，每个具体实现还可以指定“额外的类型、值、对象、属性和函数”，可以定义新的“程序和正则表达式语法”等. JavaScript三大组成： ECMAScript：描述了语言的语法和基本对象 DOM：描述处理网页内容的方法和接口 BOM：描述处理与浏览器进行交互的方法与接口最新版为ECMA-262 第三版 对应为1.5 JavaScript（2.0版本在制定中） 两种响应式网页的设计 跳转方式当不同的设备访问我们的网站时候，通过JS去判定这是一个什么设置，如果是手机，那就直接跳转到另外一个网站。这样的方面比较古老，要求要有两个网站，一个是手机网站，一个是PC网站。 更换样式通过JS去判断当前访问网站的屏幕宽度，然后调用不同的CSS样式文件。这样的方法比较方便，一个网站，只要做几个尺寸的样式表就能实现响应式网站。也可以直接使用CSS中的媒体查询直接通过屏幕宽度选择相应的样式 解决IE6 bug的方法 双边距：float ——&gt;display:inline 超链接点击后失效：——&gt;按照书写顺序：link visited hover active z-index——&gt;给父级添加position:relative png透明——&gt;使用JS代码修改 min-height——&gt;!important select在ie6中被遮盖——&gt;frame 无法定义1px左右的容器——&gt;IE6的默认行高造成，使用over:hidden;zoom:0.08 ;line-height:1px title和alt的区别 alt是当图片不显示的时候用文字代替 title是当鼠标停留的时候出现提示信息 css sprites的使用及作用把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量，提高加载速度 三种盒模型 content-box（默认）box-sizing: content-box; 只算内容，表示padding、border、margin不计算在设置的width和height中即 盒模型宽度 = content + padding + border + margin padding-box（不常用）box-sizing: padding-box; 从padding开始算，表示padding计算在设置的width和height中即 盒模型宽度 = content + border + margin border-box（特殊盒模型、开发常用）box-sizing: border-box; 表示padding、border计算在设置的width和height中即 盒模型宽度 = content + margin 开发时常在根元素设置：box-sizing: border-box; 其余元素，设置box-sizing: inherit;继承根部的 清除浮动 使用空标签清除浮动clear:both; 使用overflow:auto; after伪元素清除浮动给父级设置after伪元素，不可以设置before12345#content:after&#123; content:""; display:block; clear:both;&#125; split()和join()的区别 split()是将字符串切割成数组 join()是数组转换成字符串29、 数组方法 push()：尾部添加 pop()：尾部删除 unshift()：头部添加 shift()：头部删除 splice()：任意位置的删除或添加 splice(操作位置，删除个数，[添加的数组项1]，[添加的数组项2]) 删除个数为零，表示不删除，直接添加数组项 删除个数不为零且无添加项，表示直接删除几项 删除个数不为零，表示先删除几项，再添加数组项 reverse：用于对数组数据的倒序排列 sort：对数组里数据的排序，可以给sort函数加一个排序函数作为参数 数组去重： 12345678910111213var myArray = [0, 1, 6, 9, 0, 2, 4, 5, 4];function aaa()&#123; var newArray = []; //一个新的临时数组 for(var i = 0; i &lt; myArray.length; i++)&#123; //遍历当前数组 //如果当前数组的第i项已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (newArray.indexOf(myArray[i]) == -1)&#123; newArray.push(myArray[i]); &#125; &#125; alert("新的数组：" + newArray);&#125;aaa(); IE和DOM时间流的区别 执行顺序不一样 参数不一样 事件不加on this指向问题 IE和标准下有哪些兼容性的写法 123var oEvent = e || event;var oDocumentElement = document.documentElement.clientWidth || document.body.clientWidth;var oTarget = oEvent.srcElement || oEvent.target; 添加、删除、替换、插入 添加：appendChild() 删除：removeChild() 替换：replaceChild() 插入insertBefore() window.onload和$(document).ready的区别 window.onload是在页面（所有元素）加载完毕后执行不能同时编写多个，可用addLoadEvent()解决多个问题 $(document).ready时DOM结构绘制完毕后就执行，不必等到加载完毕可以同时编写多个可简化$()==和===的不同 ==会自动转换类型 ===不会自动转换类型 DOM和BOM DOM：文档对象模型document BOM：浏览器对象模型window、event、frame、history、location、navigator、screen display:none和visiblity:hidden的区别 display:none:不在文档流中，完全隐藏 visibility:hidden:还在文档流中，看不见但摸得着 分别写出几个HTML文字标签 文本居中：不赞成使用 文字加粗： 文字强调： 强烈语气的强调文本： 带下划线的文本： 不赞成使用 文字倾斜： 上标文本：sup 下标文本：sub 字体：不赞成使用 H5新增标签 time定义时间、wbr定义视频、video定义视频、audio定义声音、source定义媒介源、 track定义媒体播放器的文本轨道datalist定义下拉列表、keygen定义生成秘钥、 output定义输出的一些类型、canvas定义图形、figcation定义figure元素标题、 figure定义媒介内容的分组、header定义页眉、nav定义导航、main定义主窗口、 aside定义侧栏、footer定义页脚 jQuery的特点 轻量级JS框架 选择器使用方便 链式操作和隐式迭代 简化了JS代码 简化了AJAX操作 兼容主流浏览器，不需要考虑兼容 丰富的第三方插件 可扩展性强 一个大容器里面的图片或div如何设置可以让其垂直居中、水平居中 将图片设置成背景图片 12345678910&lt;!-- HTML: --&gt;&lt;div class="div1"&gt;&lt;!-- CSS: --&gt;.div1&#123; width:700px; height:600px; border:1px solid #000; background:url(1.jpg) no-repeat center center;&#125; 使用table-cell是标签元素以表格单元格的形式呈现 123456789101112131415&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;img src="1.jpg" alt=""&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; display:table-cell; width:800px; height:800px; border:1px solid #000; text-align:center; vertical-align:middle;&#125;img&#123; vertical-align:middle;&#125; 增加一个空的span元素，使用vertical-align 1234567891011121314151617181920212223&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;span&gt;&lt;/span&gt; &lt;img src="1.jpg" alt=""&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:700px; height:600px; border:1px solid #000; text-align:center;&#125;span&#123; display:inline-block; width:1px; height:100%; vertical-align:middle;&#125;img&#123; display:inline; vertical-align:middle;&#125; 延伸：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐 在图片外围套个盒子，使用margin-top 1234567891011121314151617181920212223&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;div class="div2"&gt; &lt;img src="1.jpg" alt=""&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:700px; height:600px; border:1px solid #000;&#125;.div2&#123; width:400px; height:300px; margin-top:50%; margin-left:50%;&#125;img&#123; margin-top:-50%; margin-left:-50%;&#125; 使用定位 + transform 123456789101112131415161718192021&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:500px; height: 500px; border: 1px solid #f00; position:relative;&#125;.div2&#123; width: 200px; height: 200px; border: 1px solid #0f0; position: absolute; left: 50%; top: 50%; -webkit-transform:translate(-50%,-50%);&#125; flex弹性布局 12345678910111213141516171819&lt;!-- HTML: --&gt;&lt;div class="div1"&gt; &lt;div class="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- CSS: --&gt;.div1&#123; width:500px; height: 500px; border: 1px solid #f00; justify-content:center; //水平居中 align-items:center; //垂直居中 display: -webkit-flex; //表示弹性布局&#125;.div2&#123; width: 200px; height: 200px; border: 1px solid #0f0;&#125; css兼容IE6下双边距bug：两个浮动的元素，第一个设置左边距，IE6下显示双倍间距解决办法：给浮动的元素增加display:inline IE6下3像素bug：前面的浮动，后面的不浮动，后面的上来，现代浏览器显示浮动在上面，不浮动的在下面，IE6中显示浮动的在左边，不浮动的在右边，并且有3个像素的间距。解决办法：前面的浮动，后面的也设置浮动给前面浮动的元素增加 _margin-right:-3px; img图片有默认间距：解决办法：vertical-align:middle/bottom/baseline 当应用于表单元素时，如输入框和按钮垂直错位时，给表单增加vertical-align:middle 标签最低高度min-height兼容：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !ImportAnt; height:200px; overflow:visible;}显示效果，容器最小高度为200px,内容大于200px时，容器会被撑高，而不会出现滚动条 不同浏览器的标签默认的外边距和内间距不同：margin:0; padding:0; 设置较小高度标签：设置字号高度等于标签高度其他符号：使用方法：使用了渐进识别的方式，从总体中逐渐排除局部_:IE6支持+:IE6、7支持\0:IE8支持\9:IE6、7、8支持 box-sizing:border-box; width:50%; /表示显示父级的一般长/ 允许以确切的方式定义适应某个区域的具体内容。 即可以设置该元素在相对于其父级的容器大小所显示的比例 高阶函数高阶函数是至少满足下列一个条件的函数： 接受一个函数或多个函数作为输入 输出一个函数三个高阶函数：map、filter、reduce map：将每个数组元素通过某种方法进行转换 filter：用于选择数组元素中满足某种条件的元素 reduce：把数组元素组合计算为一个值 雅虎军规雅虎军规是网站页面性能优化的黄金守则 尽量减少HTTP的请求次数 减少DNS（域名系统）的查找次数 避免跳转 可缓存的AJAX 推迟加载内容 预加载 减少DOM元素的数量 根据域名划分页面内容 使iframe的数量最小 不要出现404错误 使用CDN（内容分发网络） 为文件头指定Expires或Cache-Control G-zip压缩文件内容 配置ETag 尽早刷新输出缓冲 使用GET来完成AJAX请求 把样式表至于顶部 避免使用CSS表达式 使用外部JavaScript和CSS 削减JavaScript和CSS 使用代替@import 避免使用滤镜 把脚本至于页面底部 提出重复脚本 减少DOM访问 开发智能事件处理程序 减小Cookie体积 对于页面内容使用无cookie域名 优化图像 优化CSS Spirite 不要在HTML中缩放图像 favicon要小而且可缓存 保持单个内容小于25K 打包组件成复合文本 setTimeout和setInterval的区别 setITimeout只执行一次 清除：clearTimeout(对象); setInterval会自动重复执行 清除：clearInterval(对象); div+css实现三列布局，左右两列固定，中间列自适应宽度12345678910&lt;!-- HTML --&gt;&lt;div id="left"&gt;左栏固定宽度为200px&lt;/div&gt;&lt;div id="right"&gt;右栏固定宽度为200px&lt;/div&gt;&lt;div id="center"&gt;中间自适应宽度&lt;/div&gt;&lt;!-- 注意：布局一定是 左 右 中 --&gt;&lt;!-- CSS --&gt;#left&#123; width:200px; float:left; border:1px solid #000; min-height:400px;&#125;#right&#123; width:200px; float:right; border:1px solid #000; min-height:400px;&#125;#center&#123; margin:0 210px; border:1px solid #000; min-height:400px;&#125; 伪类和伪元素的区别 伪类：向某些选择器添加某些特殊效果 伪元素：将特殊的效果添加到某些选择器 浏览器navigator navigator.appName：获取浏览器名称 navigator.appCodeName：获取浏览器的代码名 navigator.appVersion：获取浏览器版本 navigator.cpuClass：获取浏览器的CPU等级 navigator.cookieEnabled：返回指明浏览器是否启用cookie的布尔值 浏览器历史记录history history只有一个属性，长度 history.length history.forword() //前进 history.back() //后退 history.go() //参数为整数，前进几个页面，参数为负数，后退几个页面 history.go(.com) //到达历史记录列表里第一个包含”.com”的url 使用location对象包含当前加载页面的url信息 使用location对象导航： location.href = “www.**”; //原始页面还保存在历史记录中 location.replace(“www.***”); //旧url被删除，只保留新的url 刷新页面： location.reload(); 文本溢出隐藏并显示为… 123456789101112131415161718&lt;!-- 单行文本溢出： --&gt;.div&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;&#125;&lt;!-- 多行文本溢出： --&gt;.div&#123; width:300px; border: 1px solid #0f0; display: -webkit-box; overflow: hidden; text-overflow:ellipsis; word-break:break-all; -webkit-box-orient:vertical; -webkit-line-clamp:3; //控制显示的行数&#125; 通用面试问题：1、 自我介绍面试什么职位，为什么从事这个行业（发展前景和个人爱好） 2、 面试时被公司反问还有什么问题对公司未来的发展？公司的培训力度？实习期多长时间？如果我能成功的入职贵公司，公司对我有什么期待和要求？ 3、 个人优缺点 4、 职业规划 5、 如果再工作中由于失误造成一定的损失怎么解决？承担错误，分清责任team共担，尽快解决检讨自己，分析原因，避免再犯 前端必须了解：CSS hackDOM结构DOM操作事件XMLHttpRequest严格模式与混杂模式盒模型块级元素与行内元素浮动元素HTML与XHTMLJSON 前端面试大纲：HTML&amp;CSS:WEB标准、浏览器内核差异、兼容性、hack、布局、盒模型、选择器优先级及使用、H5、CSS3、移动端JavaScript:数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模块引擎、前端MVC、路由、Nodejs、JSON、ajax其他：HTTP、WEB安全、正则、优化、重构、响应式、团队协作、可维护、SEO、UED、架构、职业生涯]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux目录解释]]></title>
    <url>%2Flinux%2Flinux%E7%9B%AE%E5%BD%95%E8%A7%A3%E9%87%8A.html</url>
    <content type="text"><![CDATA[Linux 根目录计算机下的根目录 (pm@pm-pc:/$ ) 12345678910111213/bin # 存放必要的命令/boot # 存放内核以及启动所需的文件等/dev # 存放设备文件/etc # 存放系统的配置文件/home # 用户文件的主目录，用户数据存放在其主目录中/lib # 存放必要的运行库/mnt # 存放临时的映射文件系统，我们常把软驱和光驱挂装在这里的floppy和cdrom子目录下。/proc # 存放存储进程和系统信息/root # 超级用户的主目录/sbin # 存放系统管理程序/tmp # 存放临时文件的目录/usr # 包含了一般不需要修改的应用程序，命令程序文件、程序库、手册和其它文档。/var # 包含系统产生的经常变化的文件，例如打印机、邮件、新闻等假脱机目录、日志文件、格式化后的手册页以及一些应用程序的数据文件等等。建议单独的放在一个分区。[separator] home目录1/home 主文件夹目录 个人电脑1/home/pm/ # (pm@pm-pc:) (终端默认) 各文件123456/Project/Deskup/Documents/Downloads/Music...... 操作使用cd **和cd ..来进入和退出目录]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[innerText和textContent的异同]]></title>
    <url>%2Fjavascript%2FinnerText%E5%92%8CtextContent%E7%9A%84%E5%BC%82%E5%90%8C.html</url>
    <content type="text"><![CDATA[参考资料：http://www.jb51.net/article/25082.htm innerText: IEtextContent: FF innerText它的内容实际上就是你在浏览器看到的内容。它会将innerHTML中的转义字符（&lt;、 &amp;）进行换码它将元素的innerHTML换码、解释，最终显示出来去除各种格式信息留下的纯文本。它会将多个空格并成一个空格对待，会把换成换行符，而本来的换行符却并不会引起换行 总结：换行必须使用标签，回车无效 多个空格只显示一个空格 textContent它的内容则是innerHTML去除所有标签后的内容它会将innerHTML中的转义字符（&lt;、 &amp;）进行换码不对任何html标签进行解释，而是直接剔除它们。不对innerHTML中的文本按照HTML的方式进行格式转换 比如多个空格不会合并为一个空格，换行符仍然存在，相反却不会导致换行 总结：换行必须回车，无效 多个空格不会合并成一个 操作1、HTML转义（对&gt;、&lt;、&amp;等转义字符进行处理）2、经过HTML解释和CSS解释3、剔除格式信息 innerText: 处理1、2、3 textContent: 只处理1]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML和JavaScript特别技巧集锦]]></title>
    <url>%2Fjavascript%2Fhtml%E5%92%8Cjs%E7%89%B9%E5%88%AB%E6%8A%80%E5%B7%A7%E9%9B%86%E9%94%A6.html</url>
    <content type="text"><![CDATA[让弹出窗口总是在最上面: 1&lt;body onblur="this.focus();"&gt; 不要滚动条让竖条没有: 1&lt;body style="overflow:scroll;overflow-y:hidden"&gt;&lt;/body&gt; 让横条没有: 1&lt;body style="overflow:scroll;overflow-x:hidden"&gt;&lt;/body&gt; 两个都去掉？更简单了 1&lt;body scroll="no"&gt;&lt;/body&gt; 怎样去掉图片链接点击后，图片周围的虚线？ 1&lt;a href="#" onFocus="this.blur()"&gt;&lt;img src="logo.jpg" border=0&gt;&lt;/a&gt; 电子邮件处理提交表单 123&lt;form name="form1" method="post" action="mailto:**@**.com" enctype="text/plain"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 在打开的子窗口刷新父窗口的代码里如何写？ 1window.opener.location.reload() 如何设定打开页面的大小 12打开页面的大小&lt;body onload="top.resizeTo(300,200);"&gt;打开页面的位置&lt;body onload="top.moveBy(300,200);"&gt; 在页面中如何加入不是满铺的背景图片,拉动页面时背景图不动 12345678&lt;style&gt;body&#123; background-image:url(logo.gif); background-repeat:no-repeat; background-position:center; background-attachment: fixed&#125;&lt;/style&gt; 获得一个窗口的大小 12document.body.clientWidth;document.body.clientHeight 怎么判断是否是字符 12if (/[^/x00-/xff]/g.test(s)) alert("含有汉字");else alert("全是字符"); 日期减去天数等于第二个日期 123456789101112&lt;script language="javascript"&gt;function cc(dd,dadd)&#123; //可以加上错误处理 var a = new Date(dd); a = a.valueOf(); a = a - dadd * 24 * 60 * 60 * 1000; a = new Date(a); alert(a.getFullYear() + "年" + (a.getMonth() + 1) + "月" + a.getDate() + "日");&#125;cc("12/23/2002",2)&lt;/script&gt; 脚本永不出错 12345678&lt;script language="javascript"&gt;&lt;!-- Hidefunction killErrors() &#123;return true;&#125;window.onerror = killErrors;// --&gt;&lt;/script&gt; ENTER键可以让光标移到下一个输入框 1&lt;input onkeydown="if(event.keyCode==13) event.keyCode=9"&gt; 各种样式的光标 auto ：标准光标 default ：标准箭头 hand ：手形光标 wait ：等待光标 text ：I形光标 vertical-text ：水平I形光标 no-drop ：不可拖动光标 not-allowed ：无效光标 help ：?帮助光标 all-scroll ：三角方向标 move ：移动标 crosshair ：十字标 e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize 页面进入和退出的特效进入页面: 12&lt;meta http-equiv="Page-Enter" content="revealTrans(duration=x, transition=y)"&gt; 推出页面: 1&lt;meta http-equiv="Page-Exit" content="revealTrans(duration=x, transition=y)"&gt; 这个是页面被载入和调出时的一些特效。duration表示特效的持续时间，以秒为单位。transition表示使用哪种特效，取值为1-23: 0 矩形缩小1 矩形扩大2 圆形缩小3 圆形扩大4 下到上刷新5 上到下刷新6 左到右刷新7 右到左刷新8 竖百叶窗9 横百叶窗10 错位横百叶窗11 错位竖百叶窗12 点扩散13 左右到中间刷新14 中间到左右刷新15 中间到上下16 上下到中间17 右下到左上18 右上到左下19 左上到右下20 左下到右上21 横条22 竖条23 以上22种随机选择一种 在规定时间内跳转 1&lt;meta http-equiv=V="REFRESH" content="5;url=http://www.51js.com"&gt; 网页是否被检索 1&lt;meta name=&quot;ROBOTS&quot; content=&quot;属性值&quot;&gt; 其中属性值有以下一些:属性值为”all”: 文件将被检索，且页上链接可被查询；属性值为”none”: 文件不被检索，而且不查询页上的链接；属性值为”index”: 文件将被检索；属性值为”follow”: 查询页上的链接；属性值为”noindex”: 文件不检索，但可被查询链接；属性值为”nofollow”: 文件不被检索，但可查询页上的链接。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular validate 表单验证]]></title>
    <url>%2Fangular%2Fangular_validate%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html</url>
    <content type="text"><![CDATA[1、CDN 1http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js 2、DEMO 1234567891011121314151617181920212223242526272829303132333435&lt;h1&gt;angular validate&lt;/h1&gt;&lt;form name=&quot;myForm&quot; ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot; novalidate&gt; 用户名：&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; ng-model=&quot;user&quot; required ng-minlength=&quot;2&quot; ng-maxlength=&quot;5&quot;/&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.user.$dirty &amp;&amp; myForm.user.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.user.$error.required&quot;&gt;用户名是必须的&lt;/span&gt; &lt;span ng-show=&quot;myForm.user.$error.minlength&quot;&gt;用户名至少两个字符&lt;/span&gt; &lt;span ng-show=&quot;myForm.user.$error.maxlength&quot;&gt;用户名至多五个字符&lt;/span&gt; &lt;/span&gt; &lt;br&gt; 年龄：&lt;br&gt; &lt;input type=&quot;number&quot; name=&quot;age&quot; ng-model=&quot;age&quot; required ng-min=&quot;18&quot; ng-max=&quot;60&quot;/&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.age.$dirty &amp;&amp; myForm.age.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.age.$error.required&quot;&gt;年龄是必须的&lt;/span&gt; &lt;span ng-show=&quot;myForm.age.$error.min&quot;&gt;年龄必须大于18&lt;/span&gt; &lt;span ng-show=&quot;myForm.age.$error.max&quot;&gt;年龄必须小于60&lt;/span&gt; &lt;/span&gt;&lt;br&gt; 邮箱：&lt;br&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;email&quot; required /&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.email.$dirty &amp;&amp; myForm.email.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.email.$error.required&quot;&gt;邮箱是必须的&lt;/span&gt; &lt;span ng-show=&quot;myForm.email.$error.email&quot;&gt;非法的邮箱格式&lt;/span&gt; &lt;/span&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; ng-disabled=&quot;myForm.user.$pristine || myForm.user.$invalid || myForm.age.$pristine || myForm.age.$invalid || myForm.email.$pristine || myForm.email.$invalid&quot;&gt;&lt;!-- 无填写记录或者内容不合法时，按钮为不可点击状态 --&gt;&lt;!-- 此验证为表单实时验证 --&gt;&lt;/form&gt; form中的novalidate表示禁用浏览器默认的验证 $dirty: 表单有填写记录 $pristine: 表单没有填写记录 $valid: 字段内容是合法的 $invalid: 字段内容是非法的 参考：http://www.runoob.com/try/try.php?filename=try_ng_validate]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux相关操作]]></title>
    <url>%2Ftools%2Ftmux%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[tmux快捷键（已经修改了默认配置）12345678910111213141516171819tmux 终端快捷键设置：cat ~/.tmux.conf 查看sudo vim ~/.tmux.conf 修改使用tmux开启多个终端，快捷键如下：tmux 进入tmux我的快捷键使用（通过cat ~/.tmux.conf设置）:Ctrl + A 、 - 横向分屏Ctrl + A 、 | 竖向分屏exit 关闭当前窗口Ctrl + A 、D # 将多个终端放入后台隐藏，显示一个终端tmux at # 重新切换回多个终端状态Ctrl + A、（up、down、left、right） # 在多个终端中切换输入Ctrl + A +（up、down、left、right） # 改变当前终端的大小Ctrl + A、[ 、（up、down、left、right） # 在当前终端可以滚ZCtrl + A、Z # 当前终端最大化最小化Ctrl + A、C # 当前窗口分屏（全屏）Ctrl + A、， # 更改窗口地步名称 修改配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 编码setw -g utf8 onset -g status-utf8 on# 基础设置set -g default-terminal "screen-256color"set -g display-time 3000set -g escape-time 0set -g history-limit 65535set -g base-index 1set -g pane-base-index 1# 前缀绑定 (Ctrl+a)set -g prefix ^aunbind ^bbind a send-prefix# 分割窗口unbind '"'bind - splitw -vunbind %bind | splitw -h# 选中窗口bind-key k select-pane -Ubind-key j select-pane -Dbind-key h select-pane -Lbind-key l select-pane -R# copy-mode 将快捷键设置为 vi 模式setw -g mode-keys vi# 启用鼠标(Tmux v2.1 之前)setw -g mode-mouse onset -g mouse-select-pane onset -g mouse-resize-pane onset -g mouse-select-window on# Ubuntu 支持复制bind -t vi-copy y copy-pipe "xclip -sel clip -i"# 启用鼠标(Tmux v2.1)#setw -g mouse on# to enable mouse scroll, see https://github.com/tmux/tmux/issues/145#issuecomment-150736967#bind -n WheelUpPane if-shell -F -t = "#&#123;mouse_any_flag&#125;" "send-keys -M" "if -Ft= '#&#123;pane_in_mode&#125;' 'send-keys -M' 'copy-mode -e'"# 更新配置文件bind r source-file ~/.tmux.conf \; display "已更新"]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器相关操作]]></title>
    <url>%2Ftools%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[vim快捷键常用操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102需使用sudo apt-get install vim # Linuxsudo homebrew install vim # Mac OS终端输入vim即可进入到vim编辑器：# vim不保存退出vim编辑器：# :q! &lt;Enter&gt;跳到vim之外（需小心，所有的改变都会丢失）# :qa!&lt;Enter&gt;保存修改的文件并退出：# :wq &lt;Enter&gt; / :wq! &lt;Enter&gt;回到正常状态：# Esc撤销：# u：从最后执行的命令挨个撤销(只能撤销未保存退出的)往回撤销：# Ctrl - R：撤销撤销命令移动光标：挨个移动：# up(k)、down(j)、left(h)、right(l)整屏移动：# &lt;Ctrl-f&gt;：向下移动一屏()# &lt;Ctrl-d&gt;：向下移动半屏(down)# &lt;Ctrl-b&gt;：向上移动一屏()# &lt;Ctrl-u&gt;：向上移动半屏(up)其他快速移动：# 0：移动到行首# 2w：向前移动到2个单词的首字母# 3e：向前移动到3个单词的末尾# G：到文件尾# gg：到文件首# numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）# &lt;Ctrl - g&gt;：查看当前行信息：文件名、行号、全文行号、占全文百分比、列号# H：移动光标到屏幕上面# M：移动光标到屏幕中间# L：移动光标到屏幕下面单词自动补全：# Ctrl + D 或 Tab删除：# x：删除一个字母# dd：删除一个当前行# 2dd：删除连续的两行# cw/ce：删除当前单词并进入插入模式，可修改当前错误单词# c$：删除当前行在光标后面的所有字符并进入插入模式，大幅修改添加：# a：在光标处添加，类似i替换：# r：点击r后即可替换当前1个字符，使用单个字符的修改插入：# i：在当前字符的左边插入# I：在当前行首插入# a：在当前字符的右边插入# A：在当前行尾插入# o：在当前行下面插入一个新行# O：在当前行上面插入一个新行选择（高亮）：# v：按字符选择。经常使用的模式，所以亲自尝试一下它。# V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。# Ctrl +V：按块选择。非常强大。剪切、复制：# d：剪贴选择的内容到剪贴板。# y：拷贝选择的内容到剪贴板。# c：剪贴选择的内容到剪贴板并且进入插入模式。## dd：剪切当前行。# yy：拷贝当前行。# cc：剪切当前行并且进入插入模式。## D：剪切从光标位置到行尾到剪贴板。# Y：拷贝当前行。# C：和 D 类似，最后进入插入模式。## x：剪切当前字符到剪贴板。# s：和x类似，不过最后进入插入模式。粘贴：# p：粘贴（当前一步为删除操作时，删除的字符会存在寄存器中，此时按p会在当前光标的下一行粘贴插入）搜索查找：# /error： / + 需要搜索的单词，可顺向查找，输入n可查找到下一个，输入N可反方向查找到下一个# ?error：？ + 需要搜索的单词，可逆向查找匹配括号：# %：光标定位在括号的某一处，输入%后光标自动切换到匹配的另外一处在VIM中输入外部命令：# ！：输入！+ 外部命令，如！+ls]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器相关操作]]></title>
    <url>%2Flinux%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[vim快捷键常用操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100需使用sudo apt-get install vim(mac安装：sudo homebrew install vim)安装终端输入vim即可进入到vim编辑器：# vim不保存退出vim编辑器：# :q! &lt;Enter&gt;跳到vim之外（需小心，所有的改变都会丢失）# :qa!&lt;Enter&gt;保存修改的文件并退出：# :wq &lt;Enter&gt; / :wq! &lt;Enter&gt;回到正常状态：# Esc撤销：# u：从最后执行的命令挨个撤销(只能撤销未保存退出的)往回撤销：# Ctrl - R：撤销撤销命令移动光标：挨个移动：# up(k)、down(j)、left(h)、right(l)整屏移动：# &lt;Ctrl-f&gt;：向下移动一屏()# &lt;Ctrl-d&gt;：向下移动半屏(down)# &lt;Ctrl-b&gt;：向上移动一屏()# &lt;Ctrl-u&gt;：向上移动半屏(up)其他快速移动：# 0：移动到行首# 2w：向前移动到2个单词的首字母# 3e：向前移动到3个单词的末尾# G：到文件尾# gg：到文件首# numG：移动光标到指定的行（num）。（比如 10G 就是到第 10 行）# &lt;Ctrl - g&gt;：查看当前行信息：文件名、行号、全文行号、占全文百分比、列号# H：移动光标到屏幕上面# M：移动光标到屏幕中间# L：移动光标到屏幕下面单词自动补全：# Ctrl + D 或 Tab删除：# x：删除一个字母# dd：删除一个当前行# 2dd：删除连续的两行# cw/ce：删除当前单词并进入插入模式，可修改当前错误单词# c$：删除当前行在光标后面的所有字符并进入插入模式，大幅修改添加：# a：在光标处添加，类似i替换：# r：点击r后即可替换当前1个字符，使用单个字符的修改插入：# i：在当前字符的左边插入# I：在当前行首插入# a：在当前字符的右边插入# A：在当前行尾插入# o：在当前行下面插入一个新行# O：在当前行上面插入一个新行选择（高亮）：# v：按字符选择。经常使用的模式，所以亲自尝试一下它。# V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。# Ctrl +V：按块选择。非常强大。剪切、复制：# d：剪贴选择的内容到剪贴板。# y：拷贝选择的内容到剪贴板。# c：剪贴选择的内容到剪贴板并且进入插入模式。## dd：剪切当前行。# yy：拷贝当前行。# cc：剪切当前行并且进入插入模式。## D：剪切从光标位置到行尾到剪贴板。# Y：拷贝当前行。# C：和 D 类似，最后进入插入模式。## x：剪切当前字符到剪贴板。# s：和x类似，不过最后进入插入模式。粘贴：# p：粘贴（当前一步为删除操作时，删除的字符会存在寄存器中，此时按p会在当前光标的下一行粘贴插入）搜索查找：# /error： / + 需要搜索的单词，可顺向查找，输入n可查找到下一个，输入N可反方向查找到下一个# ?error：？ + 需要搜索的单词，可逆向查找匹配括号：# %：光标定位在括号的某一处，输入%后光标自动切换到匹配的另外一处在VIM中输入外部命令：# ！：输入！+ 外部命令，如！+ls]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装搜狗输入法后失效的解决办法]]></title>
    <url>%2Flinux%2Flinux%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E5%90%8E%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[方法一:重新启动搜狗输入法通过下面的两个命令重启搜狗输入法,看重启之后是否可以正常使用:12~$ killall fcitx~$ killall sogou-qinpanel 方法二:检查修复安装依赖因为我是在正常使用下出现的问题,所以不是安装依赖的问题不适用,刚安装好的朋友如果无法使用,可以用下面的领了排查或者修复安装依赖问题1~$ sudo apt-get install -f 方法三：删除配置文件，重启搜狗ubuntu下搜狗的配置文件在 ~/.config下的3个文件夹里： SogouPY、SogouPY.users、sogou-qimpanel 删除这3个文件夹，然后重启搜狗。 我使用方法三解决了无法输入中文问题。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发规范]]></title>
    <url>%2Fother%2F%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[通用 用2个空格缩进 文件、目录名全部小写，单词之间用”_”隔开 文件统一采用UTF-8编码 删除行位多余的空格 HTML 标签合理化，对于兼容性要求不高的可使用HTML5的语义化标签，如header、footer、article、section等 标签合理嵌套，越短越好，dom层级尽量简单 尽量使用class，少用id class、id命名形象化，一律采用小写，单词之间”-“隔开，不允许使用大写字母和”_” 自定义的属性以”data-“开头 属性编写顺序： class id,name data-* src,for,type,href,value title,alt role,aria-* meta IE 兼容模式&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; CSS 不要使用@import，这种指令要慢很多，会增加请求次数，多使用link或使用sass等预处理器 用两个空格代替tab，保证能在所有环境下展现一致 少使用浮动、定位等布局 尽量减少选择器的层级 CSS左括号与选择器同行，右括号另起一行，左花括号前空一格 CSS选择器尽量用用class，少使用标签，如p{}、.test p{}等 不要在rgb()、rgba()值内部的括号中的逗号后面插入空格 对于属性值和颜色知，省略小于1的小数前面的0，如.5代替0.5，-.5px代替-0.5px 十六进制应该全部小写，且尽量使用简写形式，例如#fff 避免给0值指定单位 为选择器的属性添加双引号，如input[type=&quot;text&quot;] 选择器分组时，将单独的选择器单独放一行 CSS样式一行只写一条，可读性高 媒体查询尽量放在相关规则的地方，否则容易遗忘 带前缀的属性，让每个属性在垂直方向对齐，便于阅读 1234567/* bad css */.selector, .selector-secondary, .selector[type=text] &#123; padding:15px; margin:0px 0px 15px; background-color:rgba(0, 0, 0, 0.5); box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF&#125; 12345678910/* good css */.selector,.selector-secondary,.selector[type="text"] &#123; padding: 15px; margin-bottom: 15px; background-color: rgba(0,0,0,.5); -webkit-box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF&#125; JavaScript 变量名、函数名使用小驼峰，如requestFlag 类名使用大驼峰，如ClassData 常量名全面大写并用”_”分隔，jQuery变量使用$开头 在后端返回的数据list中增加前端字段，用”_”开头，区分前后端字段 少使用全局变量和全局函数 代码过多时考虑进行封装 语句以分号结束 避免使用多行注释/**/，多使用单行注释// 文件注释开发者信息能够体现开发人员对文件的贡献，这样便于team其他人员快速找到出处，便于后期维护 123/** * Created by Pimi.chen on 2017/04/30. */ 如果是页面html、css由制作同学开发，js由交互同学开发，交互同学拿到页面后如需要在dom中补充class或id，以”JS-“开头，区分css和js所需类 IMG 格式：透明图片使用png，不透明的使用jpg 上线前必须使用tinypng进行压缩图片]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2Flinux%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[Linux常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122根目录表示： pm@pm-pc:/$主文件目录表示： pm@pm-pc:~$超级用户主目录表示：root@pm-pc:~# （输入sudo -i 可以切换到root权限，按ctrl+d 可退出root权限）cd 改变目录# cd home 或 cd /home 查找home目录并定位# cd home/pm 查找home目录下的pm目录并定位# cd ~ 回到用户目录# cd .. 返回上一级# cd ../.. 返回上两级ls 查看文件详情# ls -a 列出文件下的所有文件# ls -l 列出文件的详细信息# ls -al 列出文件下的所有文件的详细信息# ls -s 在每个文件的后面打印出文件大小# ls -t 按时间进行排序# ls -R 将目录下的所有子目录都列出来# ls -S 以文件大小进行排序# ls -L 列出文件的Link链接# 注意大小写参数的区别cp 复制（将前面的文件复制到后面的文件中，若最后的文件不存在，则报错，加-R复制目录）# cp file1 file2 将文件file1复制到文件file2# cp file1 file2 file3 将文件file1和file2复制到文件file3# cp -i file1 file2 采用交互方式将文件file1复制到文件file2# cp -f file1 file2 因file2已存在所以强制将文件file1复制到文件file2# cp -R dir1 dir2 将目录dir1复制到dir2中# cp -R file1 file2 dir1 dir2 将fiel1、file2、目录dir1复制到dir2中mv 移动或重命名（将前面的文件移动到后面的文件中）# mv test.log test1.txt 将文件test.log重命名为test1.txt（因为都是文件而不是文件夹，所以只能改名不能移动）# mv test1.txt file1 将文件test1.txt移动到fiel1文件夹中# mv log1.text log2.text log3.text file1 将文件og1.text、log2.text、log3.text都移动到file1文件夹中# mv -i file1 file2 将file1文件夹移动到file2文件夹中，如果存在，则询问# mv -f file1 file2 将file1文件夹移动到file2文件夹中，即使存在，也会直接覆盖# mv -u file1 file2 将file1文件夹移动到file2文件夹中，如果存在，当源文件file1更新时，才会更新# mv dir1 dir2 将dir1目录移动到dir2目录中，如果dir2不存在，则为重命名# mv * ../ 移动当前文件夹下的所有文件到上一级目录# mv log1.txt -b log2.txt 加-b表示文件在覆盖前做简单备份mkdir 创建文件夹（必须增加sudo 最高权限）# sudo mkdir aa 在当前文件夹下创建文件夹aa# sudo mkdir aa/bbb/cccc 创建该目录下的文件夹cccctouch 创建文件 （必须增加sudo 最高权限）# sudo touch aa.txt 在当前目录下创建文件aa.txt# sudo touch aa/bbb/cccc.txt 创建该目录下的文件cccc.txtrm 删除文件或文件夹 （必须增加sudo 最高权限，删除文件必须加-rf）# sudo rm aa.js 删除当前目录下的aa.js# sudo rm aa/bbb/cccc.js 删除该目录下的文件cccc.js# sudo rm -f aa.js 强制删除当前目录下的aa.js# sudo rm -f aa/bbb/cccc.js 强制 删除该目录下的文件cccc.js# sudo rm -i aa.js 先询问再删除当前目录下的aa.js# sudo rm -i aa/bbb/cccc.js 先询问再删除该目录下的文件cccc.js# sudo rm -rf aa 删除当前目录下的文件aa# sudo rm -rf aa/bbb/cccc 删除该目录下的文件ccccpwd 查看完整路径# pwdapt-get 安装文件（每种系统的命令不一致，Ubuntu的命令为apt-get，最高权限sudo安装）# sudo apt-get install **ifconfig 查看IP地址（不能再超级用户root下查找）# ifconfig 查找所有ip信息# ifconfig | grep 192 使用grep快速查找处192的信息grep 管道符过滤# ifconfig | grep 192 查找打印ip地址# grep word file_name 打印file_name文件中的word字符串所在的一行# grep -i Word file_name 打印file_name文件中的Word或word（不区分大小写）字符串所在的一行# grep -c wordfile_name 打印file_name文件中word字符串的个数# grep -n wordfile_name 打印file_name文件中word字符串所在的一行并列出行数# grep -w word file_name 打印file_name文件中word字符串（只匹配整个单词，不匹配字符串的一部分，如word_name不算）所在的一行并列出行数# grep word file_name --color 打印file_name文件中的word字符串所在的一行并给***高亮ssh 通过ip地址访问局域网电脑ssh pm@192.168.20.133 （通过ip连接系统）12**** （电脑密码）杀死进程：# ps -ef | grep node # 查看node进程是否存在，-e表示显示所有进程，-f表示全格式，-ef表示两者# 找到被占用进程，查找第二个参数id号，假定为10001# kill -9 10001 # 杀死解除端口占用1.查找被占用的端口# netstat -tln# netstat -tln | grep 802.查看端口属于哪个程序# lsof -i :803.杀死端口被占用的进程# kill -9 进程id查看系统软件状态# service *** status系统软件重启# service *** restart清空终端# Ctrl + L更改主机名# vim /etc/hosts 查看# sudo vim /etc/hosts 修改 # 如：输入127.0.0.1 hongbaocloud.com 保存修改并退出后，原先访问的127.0.0.1或localhost就可以改为hongbaocloud.com访问了 # 注：vim编辑器只是其中一个选择，也可以选择其他的编辑器（如subl或atom）打开文件并修改配置]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux点击链接打开chrome显示空页面解决办法]]></title>
    <url>%2Flinux%2Flinux%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5%E6%89%93%E5%BC%80chrome%E6%98%BE%E7%A4%BA%E7%A9%BA%E9%A1%B5%E9%9D%A2.html</url>
    <content type="text"><![CDATA[Ubuntu 点击链接弹出chrome是空白页 原因： 1~/.local/share/applications/ 该目录下有google-chorome.desktop文件，浏览器会优先使用.local下的配置 解决办法：1sudo vim google-chrome.desktop 修改，或者删除该文件即可1Exec=/opt/google/chrome/chrome %U]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装微信]]></title>
    <url>%2Flinux%2Flinux%E5%AE%89%E8%A3%85%E5%BE%AE%E4%BF%A1.html</url>
    <content type="text"><![CDATA[Electronic WeChat Electronic WeChat 是利用 Electron 开源框架而打造的一款第三方微信客户端，目前支持 Linux 和 Mac OS X 系统。 Electronic WeChat 具有一些不错的特性，包括拖入图片、文件即可发送，能够阻止他人撤回消息，可以显示贴纸消息，以及直接打开重定向的链接等等。 要在 Linux 下安装 Electronic WeChat，可以下载 linux-x64.tar.gz（64 位，选择适合自己系统的架构）后执行： tar zxvf linux-x64.tar.gz cd dist/Electronic\ WeChat-linux-x64 ./Electronic\ WeChat 然后使用手机扫描二维码即可登录。 看到下面的图是不是很开^_^ 参考：https://github.com/geeeeeeeeek/electronic-wechat参考：https://github.com/geeeeeeeeek/electronic-wechat/releases]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2Fother%2Fhexo.html</url>
    <content type="text"><![CDATA[博客框架: Hexo Website、Hexo GitHub博客主题: Hexo-theme-next Website、Hexo-theme-next GitHub Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Startinstall1234567$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install Start CreateCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装QQ]]></title>
    <url>%2Flinux%2Flinux%E5%AE%89%E8%A3%85QQ.html</url>
    <content type="text"><![CDATA[Wine QQ7.8 支持的版本：ubuntu 12.04，32位由于时间及人手原因，没有来得及测试其他发行版，此版本基于32位ubuntu 12.04开发，也请大家多多帮助测试其他发行版，非常感谢！ 安装方法：ubuntu系统安装说明：如以前装过其他版本的Wine QQ，请先卸载（通过dpkg -l | grep qq查看），然后运行：sudo dpkg -i WineQQ7.8-20151109-Longene.deb 非Ubuntu系统：1、解压deb包2、按照deb的目录结构，复制的对应的目录，如把opt目录下的所有文件复制到系统的/opt目录下，3、在终端运行qq即可 成功后的截图： 是不是很开心^_^ 我自己安装的目前存在一些问题，一旦网络切换（电脑没网的情况下）就会自动掉线，而且还不能重新登录，重启电脑或将QQ进程杀死后才能重开。 掉线后处理：1、杀进程123ps -ef | grep qqkill -9 ** 2、重启 虽然有这些问题，但总比没有要好，凑合着用吧！哈哈！ 下载地址百度网盘参考链接]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux创建桌面图标]]></title>
    <url>%2Flinux%2Flinux%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87.html</url>
    <content type="text"><![CDATA[如果是系统自带的程序，默认的桌面图标放在 /usr/share/applications/下面，可以直接将对应的图标放到当前用户的~/Desktop/目录下即可 如果是从网上下载已编译的二进制文件(eclipse之类的)，可以进行手动的创建 将以下代码放在一个sublime.desktop的文件中，并复制到桌面上，授予可执行权限即可： 12345678910111213141516171819[Desktop Entry]Categories=Development;Comment[zh_CN]=Comment=Exec=/home/zhxia84/software/tool/SublimeText2/sublime_textGenericName[zh_CN]=IDEGenericName=IDEIcon=/home/zhxia84/software/tool/SublimeText2/Icon/32x32/sublime_text.pngMimeType=Name[zh_CN]=sublimeName=sublimePath=StartupNotify=trueTerminal=falseType=ApplicationX-DBUS-ServiceName=X-DBUS-StartupType=X-KDE-SubstituteUID=falseX-KDE-Username=owen 参考：http://www.cnblogs.com/xiazh/p/3821863.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的js的各种宽高值]]></title>
    <url>%2Fjavascript%2Fjs%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98.html</url>
    <content type="text"><![CDATA[常见的js的各种宽高值 document.document.clientHeight:页面窗口高度document.body.clientHeight:页面内容高度document.body.scrollTop:滚动条的高度，在顶部为0]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe嵌入网页高度自适应]]></title>
    <url>%2Fjavascript%2Fiframe%E5%B5%8C%E5%85%A5%E7%BD%91%E9%A1%B5%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94.html</url>
    <content type="text"><![CDATA[原理：1、使用document.body.scrollHeight获取iframe的高度，作为hash添加给window.top.location2、在主页面获取window.top.location的hash值，再将该值赋给iframe高度 iframe中：12345var hostUrl = window.top.location.toString().split("#")[0]; // 去除hash后的字符串if (hostUrl) &#123; hostUrl += "#height=" + document.body.scrollHeight; // 将高度存放在hash中 window.top.location = hostUrl;&#125; 主页面中：123456789function iframeHeight() &#123; var hash = window.location.hash.slice(1); // 获取第一个hash，即iframe存在地址栏的hash参数 if (hash &amp;&amp; /height=/.test(hash)) &#123; document.getElementById('iframePage').height = hash.replace("height=", ""); &#125; setTimeout(iframeHeight, 200);&#125;iframeHeight();]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被遗忘的位运算符]]></title>
    <url>%2Fjavascript%2F%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    <content type="text"><![CDATA[前言整数：ECMAScript整数包括有符号整数（允许正数和负数）和无符号整数（只允许正数），在ECMAScript中，所有整数字面量默认都是有符号整数 有符号整数：数值范围从-2147483648到2147483647 无符号整数：数值范围从0到4294967295 123var i = 18, j = -18;alert(i.toString(2)); // -&gt; '10010'alert(j.toString(2)); // -&gt; '-10010' 位运算符NOT(~)1、把运算符转为32位二进制数字 2、再转为它的二进制反码 3、把二进制反码转为浮点数 简：对数字求负，然后减1，比如～25 === -26 位运算符AND(&amp;)它对数字的二进制进行操作，把数字转换为二进制后，把每个数字的数对齐，不够补0，然后以下面的规则进行OR运算： 1 对 1 -&gt; 1 1 对 0 -&gt; 0 0 对 1 -&gt; 0 0 对 0 -&gt; 0 因此， 16 &amp; 15 = 0， 15 &amp; 14 = 14 1234516: 1000015: 01111----------------00: 0000000: 0 1234515: 0111114: 01110----------------00: 0111000: 14 位运算符OR(|)它对数字的二进制进行操作，把数字转换为二进制后，把每个数字的数对齐，不够补0，然后以下面的规则进行AND运算： 1 对 1 -&gt; 1 1 对 0 -&gt; 1 0 对 1 -&gt; 1 0 对 0 -&gt; 0 因此， 16 | 15 =16， 15 | 14 = 15 1234516: 1000015: 01111----------------00: 1111100: 16 1234515: 0111114: 01110----------------00: 0111100: 15 左移运算(&lt;&lt;)有符号右移运算(&gt;&gt;)无符号右移运算(&gt;&gt;&gt;)用例“4”的整数次幂（链接：http://web.jobbole.com/86290/） 给定一个32位有符号整数（32 bit signed integer），写一个函数，检查这个整数是否是“4”的N次幂，这里的N是非负整数。不使用常规循环和遍历 思路：利用二进制位数 和 位运算符 &amp; 解决 123440 = 1B41 = 100B42 = 10000B43 = 1000000B 也就是每个数比上一个数的二进制后面多两个零嘛。最重要的是，“4”的幂的二进制数只有 1 个“1”。判断一个二进制数只有 1 个“1”，只需要： 1(num &amp; num - 1) === 0 但是，二进制数只有 1 个“1”只是“4”的幂的必要非充分条件，因为“2”的奇数次幂也只有 1 个“1”。所以，我们还需要附加的判断： 1(num &amp; num - 1) === 0 &amp;&amp; (num &amp; 0xAAAAAAAA) === 0 为什么是 num &amp; 0xAAAAAAAA === 0? 因为这个确保 num 的二进制的那个 “1” 出现在“奇数位”上，也就确保了这个数确实是“4”的幂，而不仅仅只是“2”的幂 最终结果： 12345function isPowerOfFour(num) &#123; return num &gt; 0 &amp;&amp; (num &amp; (num-1)) === 0 &amp;&amp; (num &amp; 0xAAAAAAAA) === 0;&#125;;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React小Demo]]></title>
    <url>%2Freact%2Freact%E5%B0%8Fdemo.html</url>
    <content type="text"><![CDATA[参考：阮一峰 React 入门实例教程 注意1、引入三个js文件2、script中注明type=”text/babel” 即使用JSX的语法（JSX：在JS中直接使用HTML标签语法）3、使用ReactDOM.render() CDN123&lt;script src="react.js"&gt;&lt;/script&gt;&lt;script src="react-dom.js"&gt;&lt;/script&gt;&lt;script src="browser.min.js"&gt;&lt;/script&gt; 或： 123456&lt;script src="https://npmcdn.com/react@15.3.1/dist/react.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/react-dom@15.3.1/dist/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"&gt;&lt;/script&gt; Demo1：简单React12345678&lt;div id="example" class="container"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; ReactDOM.render( &lt;h1&gt;Hello, React !&lt;/h1&gt;, document.getElementById('example') );&lt;/script&gt; 结果： Demo2：渲染简单数组12345678910111213141516&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var names = ['Alice', 'Emily', 'Kate']; ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 遇到HTML标签（以 &lt; 开头），就用HTML规则解析；遇到代码块（以 { 开头），就用JavaScript规则解析 Demo3：渲染带标签的数组1234567891011121314&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;, &lt;p&gt;Reactsdjfkasfj&lt;/p&gt; ]; ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example') );&lt;/script&gt; 结果： Demo4：组件1234567891011121314&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;HelloMessage name="John" /&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 1、HelloMessage就是一个组件类，React.createClass 方法用于生成一个组件类，组件类必须有自己的render方法，用于输入组件 2、组件类的第一个字面必须大写，否则报错，组件类只能包含一个顶层标签，否则报错 3、模板插入就会自动生成一个组件类的实例 4、通过this.props来读取组件的属性，组件属性如果有class属性需要写成className，for属性需要写成htmlFor，因为class和for是JavaScript的保留字 Demo5：this.props.children12345678910111213141516171819202122232425&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var NotesList = React.createClass(&#123; render: function() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125; &#125;); ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 1、this.props对象属性与组件的属性一一对应，但是this.props.children属性例外，它表示组件的所有子节点 2、NotesList组件有两个span子节点，可以通过this.props.children读取 3、如果当前组件没有子节点，它就是underfined；如果有一个子节点，数组类型是object；如果有多个子节点，数据类型就是array 4、React提供一个React.Children方法来处理this.props.children Demo6：PropTypes，组件属性验证12345678910111213141516171819&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var data = 123; // 使用123会报错，必须使用字符串'123...' var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;MyTitle title=&#123;data&#125; /&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： 1、PropTupes属性用来验证组件实例属性是否符合要求 2、此例中使用PropsTypes来验证title必须是字符串，所有当data=123时会报错，提示类型错误，当data=’123’时则顺利通过 Demo7：getDefaultProps，设置组件属性默认值1234567891011121314151617181920&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt; var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : 'Hello World' &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;MyTitle /&gt;, document.getElementById('example') );&lt;/script&gt; 结果： 详解： getDefaultProps方法用来设置组件属性的默认值 Demo8：获取真实DOM节点123456789101112131415161718&lt;div id="example"&gt;&lt;/div&gt;&lt;script type="text/babel"&gt;var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);&lt;/script&gt; 详解： 1、组件并不是真实的DOM节点，而是存在于内存之中的一种虚拟结构，叫做虚拟DOM。只有当它插入文档以后，才会变成真实的DOM。所有的DOM变动，都先在虚拟DOM上发生，然后再将实际发生变动的部分，反映在真实的DOM上，这种算法叫做DOM diff，可以极大的提高网页的性能表现。 2、虚拟DOM拿不到用户输入的，使用ref属性获取真实的DOM节点。此例中this.refs.[refName]返回真实DOM节点，在click事件后确保了真实的DOM]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期介绍]]></title>
    <url>%2Freact%2Freact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[React 生命周期如下：12345678910111213141516171819componentWillMount：1、渲染前调用render：2、渲染componentDidMount：3、第一次渲染完调用，此时可获取domcomponentWillReceiveProps：4、接收到一个新的props时调用shouldComponentUpdate：5、接收props或state时判断是否该updatecomponentWillUpdate：6、接收到props或state时开始更新render：7、rendercomponentDidUpdate：8、组件更新完毕componentWillUnmount：～移除组件时调用 生命周期实例demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="http://static.runoob.com/assets/react/react-0.14.7/build/react.min.js"&gt;&lt;/script&gt; &lt;script src="http://static.runoob.com/assets/react/react-0.14.7/build/react-dom.min.js"&gt;&lt;/script&gt; &lt;script src="http://static.runoob.com/assets/react/browser.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; var Button = React.createClass(&#123; getInitialState: function () &#123; return &#123; data: 0 &#125;; &#125;, // 自定义事件 setNewNumber: function () &#123; // this.setState(&#123;data: this.state.data + 1&#125;) // this.setState(function (state) &#123; // return &#123;data: state.data + 1&#125; // &#125;) this.setState(function (state) &#123; state.data++ &#125;) &#125;, render: function () &#123; return ( &lt;div&gt; &lt;button onClick = &#123; this.setNewNumber &#125;&gt;INCREMENT&lt;/button&gt; &lt;Content myNumber = &#123; this.state.data &#125; /&gt; &lt;/div&gt; ); &#125; &#125;); var Content = React.createClass(&#123; // 1、渲染前调用 componentWillMount:function () &#123; console.log('Component Will Mount!') &#125;, // 3、第一次渲染完调用，此时可获取dom componentDidMount: function () &#123; console.log('Component Did Mount!') &#125;, // 4、接收到一个新的props时调用 componentWillReceiveProps: function () &#123; console.log('Component Will Receive Props!') &#125;, // 5、接收props或state时判断是否该update shouldComponentUpdate: function (nextProps, nextState) &#123; console.log('Should Component Update') return true; &#125;, // 6、接收到props或state时开始更新 componentWillUpdate: function () &#123; console.log('Component Will Update!') &#125;, // 7、再次render // 8、组件更新完毕 componentDidUpdate: function () &#123; console.log('Component Did Update!') &#125;, // ～移除组件时调用 componentWillUnmount: function () &#123; console.log('Component Will UnMount!') &#125;, // 2、渲染 render: function () &#123; console.log('Render') return ( &lt;div&gt; &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; // 正确的顺序： // 1、componentWillMount // 2、render // 3、componentDidMount // // 4、componentWillReceiveProps // 5、shouldComponentUpdate // 6、componentWillUpdate // 7、render // 8、componentDidUpdate // // 9、componentWillReceiveProps // 10、shouldComponentUpdate // 11、componentWillUpdate // 12、render // 13、componentDidUpdate // // ～componentWillUnmount &#125;) ReactDOM.render( &lt;Button /&gt;, document.getElementById('example') ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[export和module.export语法]]></title>
    <url>%2Fjavascript%2Fjs-module.html</url>
    <content type="text"><![CDATA[export（es6语法） 参考：阮一峰 export命令 在vue中，可以将所有的外部函数、变量等写在一个外部的js文件中并使用export暴露出来，再在相关的组件中import相应的函数或变量 method.js：123456789101112131415161718192021function aa (a, b) &#123; ***** ***** ***** return ***;&#125;function bb (c, d) &#123;&#125;var cc;var dd;输出1（输出多个）：export &#123;aa, bb, cc ,dd&#125; 输入1（对应输入时加括号）：import &#123;aa&#125; from &apos;&apos;输出2（输出一个）：export default aa输入2（对应输入时无括号）：import aa from &apos;&apos; 组件：1234567import &#123;aa, cc&#125; from &apos;method.js&apos; // import 需要的变量或函数import * from &apos;method.js&apos; // 当需要import所有的变量或函数时methods : &#123; var mn = aa(123, 456);&#125;组件里面可以直接使用method.js里面的函数或变量，如果放在组件里面，则需要使用this.aa(), 这样会造成文件过长，不易阅读，且重用性差 module.exports（node语法）Module.exports导出的其实是整个模块对象 exports（node语法） 参考:小白妹妹写代码 module.export和export exports是对Module.exports的一种引用，常规情况下，两者基本一致，可以混用，但部分情况下不可 例1：OK12345module.exports.name = '小白妹妹';exports.age = 10;module.exports.print = function()&#123; console.log(12345)&#125;; 例2：OK123456789module.exports = &#123; name = '小白妹妹';&#125;;exports.age = 10;module.exports.print = function()&#123; console.log(12345)&#125;; 例3：ERROR123456789module.exports = &#123; name = '小白妹妹';&#125;;exports = &#123; age:10&#125;; // exports现在是&#123;age:10&#125;这个对象的引用，不再是module.exports的引用了console.log(module); //你会看到Module的exports中只有name属性！！ 例4：ERROR12345678exports.age = 10;console.log(module); //你会看到Module的exports中多了age属性module.exports = &#123; name = '小白妹妹';&#125;;console.log(module); //你会看到Module的exports中还是只有name属性！！！ 使用 例1：es6 export单个变量或方法导出导入 1234567891011121314A.js:function a () &#123;&#125;// 输入：export default a B.js:// 输入：import a from 'A.js'// 使用：a() 例2：es6 export多个变量或方法导出导入 1234567891011121314151617181920212223242526A.js:function a () &#123;&#125;function b () &#123;&#125;function c () &#123;&#125;// 输出:export &#123;a, b, c&#125;B.js:// 输入1：import &#123;a, b, c&#125; from 'A.js'// 使用1：a()、b()、c()// 输入2 或*号全部导出：import * as method from 'A.js'// 使用2：method.a()、method.b()、method.c() 例3：Node.js module.exports 多个变量或方法导入导出 12345678910111213141516171819202122232425262728293031A.js:function a () &#123;&#125;function b () &#123;&#125;function c () &#123;&#125;// 输出：module.exports &#123;a, b, c&#125;B.js:// 输入1：import &#123;a, b, c&#125; from 'A.js'// 使用1：a()、b()、c()// 输入2 或*号全部导出：import * as method from 'A.js'// 使用2：method.a()、method.b()、method.c()// 输入3 别名全部导出（当只有一个方法时不支持别名导出）：import method from 'A.js'// 使用3method.a()、method.b()、method.c() 例4：Node.js 使用Module.exports直接导出 12345678910111213141516171819202122232425A.js:// 直接输出module.exports = &#123; a: function() &#123;&#125;, b: function() &#123;&#125;, c: function() &#123;&#125;&#125;B.js:// 输入1：import &#123;a, b, c&#125; from 'A.js'// 使用1：a()、b()、c()// 输入2：import method from 'A.js'// 使用2：method.a()、method.b()、method.c() 例5：Node.js exports 导出失败，不可用 12345678910111213A.js:function a () &#123;&#125;function b () &#123;&#125;function c () &#123;&#125;// 输出exports &#123;a, b, c&#125;B.js:// 输入import &#123;a, b, c&#125; from 'A.js' 总结1、es6 export支持：default aa 导出aa导入、{aa, bb}导出{aa, bb}导入、* as method全部导入 2、es6 export不支持：别名导入 3、node.js module.exports支持：{aa, bb}导出{aa, bb}导入、* as method全部导入、method别名导入 4、node.js module.exports不支持： 5、node.js exports 不支持：少于exports 6、require对应的是module.export]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery实现大转盘效果]]></title>
    <url>%2Fjquery%2Fjquery%E5%AE%9E%E7%8E%B0%E5%A4%A7%E8%BD%AC%E7%9B%98%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[插件： jQueryRotate.2.2 支持：ie8旋转插件 效果： 下载：百度云盘]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax规范]]></title>
    <url>%2Fjquery%2Fajax%E8%AF%B7%E6%B1%82%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132$.ajax(&#123; url: '', type: '', dataType: 'json', timeout: 3000, data: &#123; num1: num1, num2: num2 &#125;, beforeSend: function(xhr, settings) &#123; // 发送请求前 console.log('beforeSend', xhr, settings); &#125;, success: function(data, status, xhr) &#123; // 请求成功 console.log('success', data, status, xhr); if (data.code === 200) &#123; console.log('处理成功'); &#125; else &#123; console.log('处理失败'); &#125; &#125;, error: function(xhr, errorType, error) &#123; // 请求失败 console.log('error', xhr, errorType, error); alert('请求失败'); &#125;, complete: function(xhr, status) &#123; // 请求成功或失败都执行 console.log('complete', xhr, status); &#125;&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss用法]]></title>
    <url>%2Fcss%2Fscss%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[变量sass中可以定义变量，方便统一修改和维护1234567$fontStack: Helvetica, sans-serif;$primaryColor: #333;body &#123; font-family: $fontStack; color: $primaryColor;&#125; 转换成： 1234body &#123; font-family: Helvetica, sans-serif; color: #333;&#125; 嵌套sass可以进行选择器的嵌套，表示层级关系，看起来很优雅整齐1234567891011nav &#123; background: red; ul &#123; margin: 0; padding: 0; list-style: none; li &#123; display: inline-block; &#125; &#125;&#125; 转换成： 1234567891011nav &#123; background: red;&#125;nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav ul li &#123; display: inline-block;&#125; 导入sass中如导入其他sass文件，最后编译为一个css文件，优于纯css的@import123456789101112131415_reset.css如下：html,body,ul,ol &#123; margin: 0; padding: 0;&#125;base.css如下：@import 'reset';body &#123; font-size: 100% Helvetica, sans-serif; background-color: #efefef;&#125; 转换后： 12345678html, body, ul, ol &#123; margin: 0; padding: 0;&#125;body &#123; background-color: #efefef; font-size: 100% Helvetica, sans-serif;&#125; mixin混合sass中可用mixin定义一些代码片段，且可传参数，方便日后根据需求调用。从此处理css3的前缀兼容轻松便捷。 适用于css3加厂商前缀、加背景图、设置宽高等123456789@mixin box-sizing ($sizing) &#123; -webkit-box-sizing:$sizing; -moz-box-sizing:$sizing; box-sizing:$sizing;&#125;.box-border&#123; border:1px solid #ccc; @include box-sizing(border-box);&#125; 转换成： 123456.box-border &#123; border: 1px solid #ccc; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 扩展/继承sass可通过@extend来实现代码组合声明，使代码更加优越简洁。123456789.message &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; @extend .message; //表示公用message的样式 border-color: green;&#125; 转换成： 12345678.message, .success &#123; border: 1px solid #cccccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125; 运算sass可进行简单的加减乘除运算等123article &#123; width: 600px / 960px * 100%;&#125; 转换成： 123article&#123; width: 62.5%;&#125; ##颜色sass中集成了大量的颜色函数，让变换颜色更加简单12345678$linkColor: #08c;a &#123; text-decoration:none; color:$linkColor; &amp;:hover&#123; color:darken($linkColor,10%); &#125;&#125; 转换成： 1234567a &#123; text-decoration: none; color: #0088cc;&#125;a:hover &#123; color: #006699;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端点击300ms延迟的解决方法]]></title>
    <url>%2Fhtml%2F%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF300ms%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[meta标签法：禁用缩放12&lt;meta name="viewport" content="user-scalable=no"/&gt;&lt;meta name="viewport" content="initial-scale=1,maximum-scale=1"/&gt; user-scalable=no表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。 meta标签法：更改默认的视口宽度1&lt;meta name="viewport" content="width=device-width"/&gt; width=device-width表明是一个响应式的网站，够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。 css方法1touch-action: none; IE10+支持，chrome等赞不支持 FastClick插件方法1234567891011121314151617181920212223&lt;script src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"&gt;&lt;/script&gt;&lt;script&gt;/*js用法：*/if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false);&#125;/*jquery用法：*/$(function() &#123; FastClick.attach(document.body);&#125;);/*zepto用法：*/if ('addEventListener' in document) &#123; window.Zepto(document).on('DOMContentLoaded', function () &#123; window.FastClick.attach(document.body) &#125;)&#125;&lt;/script&gt; 快速模拟一个click，并禁止掉原有的click 总结1、2、3方法均不好用，建议使用FastClick插件]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pug语法]]></title>
    <url>%2Fhtml%2Fpug%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[原本是叫jade的，后来因为jade的版本问题，官方已改称pug了，后续使用均用pug pug是什么？ 模板引擎 用js实现 供node使用 pug安装nodeJs中输入一下命令12npm install pug -gpug -h pug语法标签12p 转换成 &lt;p&gt;&lt;/p&gt;input 转换成 &lt;input/&gt; 文本123456789101112131415161718192021222324252627282930//标签中添加文本p 欢迎学习pug语法 转换成： &lt;p&gt;欢迎学习pug语法 &lt;/p&gt;//标签中嵌套标签p 欢迎学习pug语法 &lt;b&gt;哈哈&lt;/b&gt; 装换成： &lt;p&gt;欢迎学习pug语法 &lt;b&gt;哈哈&lt;/b&gt;&lt;/p&gt;//标签中有大段的块内容1、在标签后面添加 .script. console.log(&quot;aaaaa&quot;); console.log(&quot;bbbbb&quot;);转换成：&lt;script&gt; console.log(&quot;aaaaa&quot;); console.log(&quot;bbbbb&quot;);&lt;/script&gt;2、在每段后面添加 |script | console.log(&quot;aaaaa&quot;); | console.log(&quot;bbbbb&quot;);转换成：&lt;script&gt; console.log(&quot;aaaaa&quot;); console.log(&quot;bbbbb&quot;);&lt;/script&gt; 属性1234//以()来分割属性a(rel=&quot;aa&quot;, href=&quot;http://www.baidu.com&quot;) click转换成：&lt;a rel=&quot;aa&quot; href=&quot;&quot;http://www.baidu.com&quot;&gt;click&lt;/a&gt; 注释1234567891011121314151617181、单行注释// 这是一个单行注释转换成：&lt;!-- 这是一个单行注释 --&gt;2、多行注释body // p 这是一个注释段落转换成：&lt;body&gt;&lt;!--p 这是一个注释段落--&gt;3、不输出的注释// - 这段注释不会输出p 文本测试转换成：&lt;p&gt;文本测试&lt;/p&gt;&lt;/body&gt; doctype123456添加一个doctype只需要一个doctype，然后跟一个可选的值，默认是htmldoctype html转换成：&lt;!DOCTYPE html&gt;后面可选值包括： xml、transitionall、strict、frameset、1.1、basic、mobile 设置id或class123456789101112131、标签后面跟上#id，.classname，如果没有标签则使用默认标签div#contentp#infoa.btn转换成：&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;p id=&quot;info&quot;&gt;&lt;/p&gt;&lt;a class=&quot;btn&quot;&gt;&lt;/a&gt;2、1个id和多个classa#download-btn.btn.blue-btn转换成：&lt;a id=&quot;download&quot; class=&quot;btn blue-btn&quot;&gt;&lt;/a&gt;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp用法]]></title>
    <url>%2Fnode%2Fgulp%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[gulpfile.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const gulp = require('gulp');const pug = require('pug'); // pugconst gulpPug = require('gulp-pug'); // gulp-pugconst sass = require('gulp-sass'); // sassconst prefixer = require('gulp-autoprefixer'); // 代码不压缩const sourcemaps = require('gulp-sourcemaps'); // js文件解压缩const babel = require('gulp-babel'); // es6转换const concat = require('gulp-concat'); // 压缩js文件为1个const imagemin = require('gulp-imagemin'); // 图片压缩const browserSync = require('browser-sync').create(); // 自动刷新const fileinclude = require('gulp-file-include'); // 引入公共文件gulp.task('pug', function()&#123; return gulp.src('./src/*.pug') .pipe(gulpPug(&#123; pug: pug, pretty: true &#125;)) .pipe(gulp.dest('dist/'))&#125;);gulp.task('sass', function()&#123; return gulp.src("./src/css/*.scss") .pipe(sass().on('error', sass.logError)) .pipe(prefixer()) .pipe(gulp.dest("./dist/css")) .pipe(browserSync.stream());&#125;);gulp.task('img', function()&#123; return gulp.src('src/img/*') .pipe(imagemin()) .pipe(gulp.dest('dist/img'))&#125;);gulp.task('es6', () =&gt; &#123; return gulp.src('src/js/*.js') .pipe(sourcemaps.init()) .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(concat('main.js')) .pipe(sourcemaps.write('.')) .pipe(gulp.dest('dist/js'));&#125;);gulp.task('fileinclude', function() &#123; gulp.src('src/**.html') .pipe(fileinclude(&#123; prefix: '@@', basepath: '@file' &#125;)) .pipe(gulp.dest('dist'));&#125;);// Static Server + watching scss/html filesgulp.task('serve', ['sass', 'pug', 'es6', 'img'] , function()&#123; browserSync.init(&#123; server: "./dist" &#125;); gulp.watch("./src/css/*.scss", ['sass']); gulp.watch("./src/img/*", ['img']).on('change', browserSync.reload); gulp.watch("./src/js/*.js", ['es6']).on('change', browserSync.reload); gulp.watch("./src/*.pug", ['pug']).on('change', browserSync.reload);&#125;);gulp.task('default', ['serve']); package.json1234567891011121314151617181920212223242526272829&#123; "name": "gulp", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "repository": &#123; "type": "git", "url": "" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "babel-preset-es2015": "^6.9.0", "browser-sync": "^2.13.0", "gulp": "^3.9.1", "gulp-autoprefixer": "^3.1.0", "gulp-babel": "^6.1.2", "gulp-concat": "^2.6.0", "gulp-file-include": "^1.0.0", "gulp-imagemin": "^3.0.1", "gulp-pug": "^3.2.0", "gulp-sass": "^2.3.2", "gulp-sourcemaps": "^1.6.0", "pug": "^2.0.0-beta11" &#125;&#125; 项目结构目录 用法123cd srcgulp # 会在主目录下生成一个dist文件 附加前端经常需要讲生成的目录拷贝到后端目录下，但对于django这样的后端，有其特定的语法，所以需要加上一些特定的标签，使用全局替换：123&quot;\./([^\s]+)&quot; 替换成 &quot;&#123;% static &apos;newyear/$1&apos; %&#125;&quot; // newyear表示项目名称html头部加：&#123;% load staticfiles %&#125;]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Init]]></title>
    <url>%2Fgit%2Fgit%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[对于首次上传项目到github或企业gitlab12345678910111213新建projectcd ~/projectgit initgit add .git commit -m "***"git remote ... // 与远程仓库建立连接git push -u origin master]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git ssh key操作]]></title>
    <url>%2Fgit%2Fssh_key.html</url>
    <content type="text"><![CDATA[12345ssh-keygen -t rsa -C "$your_email" // 生成SSH KEYcat ~/.ssh/id_rsa.pub // 列出SSH KEYclip -sel clip &lt; ~/.ssh/id_rsa.pub // 将SSH KEY复制到粘贴板]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2Fgit%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[经常忘记git的一些命令，so还是把常用的一些命令记下来，忘记了再来查 git和svn的区别 svn是集中式版本控制系统 git是分布式版本控制系统 git常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101init 初始化// mkdir aa// cd aa// git init 把当前目录变成git可以管理的仓库，初始化add 添加// git add readme1.txt 把文件1添加到仓库// git add readme2.md 把文件2添加到仓库commit 提交// git commit -m &quot;添加的是什么文件&quot; 把文件提交到仓库（-m后面的是本次提交的说明）// add和commit的区别// 操作共两部，先add，后commit// 因为commit可以一次提交很多文件，所以可以多次add不同的文件// git add file1.txt// git add file2.txt file3.txt// git commit -m &quot;add file1、file2 and file3&quot;status 仓库状态// git status status命令可以时刻掌握仓库当前的状态diff 差异// git diff diff命令可以比较版本差异log 版本// git log log命令可以查看历史记录（从近到远）checkout 撤销工作区（本地）修改// git checkout --readme.txt 把 readme.txt 文件在工作区的修改全部撤销1:如果readme.txt还未存放到暂存区，执行后就回到和版本库一样的状态2:如果readme.txt已经存放到暂存区，执行完后就回到暂存区中一样的状态总之：就是回到上一次git add 或 git commit的状态reset(默认为--mixed) 版本撤回// git reset --soft HEAD 回退时不重置暂存区和工作区// git reset --mixed HEAD 回退时重置缓存区，默认选项（--mixed可不写）// git reset --hard HEAD 回退时重置暂存区和工作区// git reset HEAD^ 回退到上一版本，并重置暂存区// git reset HEAD~10 回退到10个版本之前，并重置暂存区// git reset --hard HEAD^ 回退到上一版本，并重置工作区和暂存区// git reset --hard HEAD~10 回退到10个版本之前，并重置工作区和暂存区// git reset 不指定HEAD，用来清空暂存区的修改// git reset filename 清空暂存区中指定文件的修改// git reset --hard 不指定HEAD，用来清空工作区和暂存区的修改// git reset --hard filename 清空工作区和暂存区中指定文件的修改// 撤回时，首先判断是否需要版本回退（HEAD控制），再判断工作区是否保留（--hard控制）// 工作区撤回：git checkout / git checkout filename// 暂存区撤回（工作区保留）: git reset / git reset filename// 暂存区撤回（工作区不保留）： git reset --hard / git reset --hard filename// 版本区撤回（工作区保留）: git reset HEAD / git reset HEAD// 版本区撤回（工作区不保留）：git reset --hard HEAD / git reset --hard HEAD filenamereflog 记录每一次commit命令// 查看之前版本的commit id，然后可以返回来// 穿梭和回退// HEAD指向的版本就是当前的版本，使用命令 git reset --hard commit_id// 穿梭历史前：用 git log 先查看提交历史，确定要回退到历史的哪个版本// 要重返未来：用 git reflog 先查看命令历史，确定要回重回到未来的哪个版本rm 删除（先删除后提交）//git rm test.txt//git commit -m &quot;remove test.txt&quot;//rm -rf .git 删除git信息，脱离git//find . -name &quot;.git&quot; | xargs rm -Rf 本地文件夹下的git文件，然后在重新初始化新建的git仓库stash 暂存//git stash 对当前的暂存区和工作区状态进行保存//git stash list 列出所有保存的进度列表//git statsh pop [--index][&lt;stash&gt;] 恢复工作进度--index：不仅回复工作区，还恢复暂存区&lt;stash&gt;：指定恢复一个具体进度，如果没有参数，默认恢复最新进度如：git stash pop --index stash@&#123;0&#125; 恢复编号为0的进度的工作区和暂存区push 将分支推送成为远端上的分支//git push &lt;remote&gt; [branch]//git push origin master:master //将master分支下的本地修改push到master分支下（可初始化时提交未修改的分支，当前在其他分支时可使用，若当前已经在master分支，则使用 git push即可）pull 下载数据//git pull 从远端的服务器上下载数据，实现同步更新//git pull origin master //从其他分支上拉取master下的代码clone 克隆项目//git clone **** 首次克隆线上项目到本地,*****表示git地址remote 远程分支//git remote set-url origin Url 更换url（ssh url 和 http url）//git remote -v 查看远程//git remote rm origin 删除远程//git remote add origin Url 设置远程//git remote prune origin 清理远程无效分支config 配置别名（配置目录在主目录下.gitconfig中，如不需要，删除记录即可）//git config --global alias.st status（将git status 配置成git st）//git config --global alias.ad add（将git add 配置成git ad）//git config --global alias.cm commit（将git commit配置成git cm） git分支 branch12345678910branch 分支//git branch 查看分支//git branch &lt;name&gt; 创建分支//git checkout &lt;name&gt; 切换分支//git checkout -b &lt;name&gt; 创建+切换分支//git merge &lt;name&gt; 合并某分支到当前分支//git branch -d &lt;name&gt; 删除本地分支//git push origin :master 删除远程分支(或git push origin --delete master，只删除远程分支，本地不会删除)// git for-each-ref --format=&apos;%(committerdate) %09 %(authorname) %09 %(refname)&apos; | sort -k5n -k2M -k3n -k4n 查看分支创建者和创建时间 git pull12345678910111213141516171819202122git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;git pull origin next:master // 表示取回origin主机上的next分支与本地分支master合并git pull origin next // 表示拉取远程next分支与本地next分支合并等同于/**/git fetch // 表示先从远程上获取最新版本到本地，不会自动合并git merge origin/next // 表示合并/**/某些场合，git会在本地分支和远程分支之间建立一种tracking追踪关系，如git clone，通常为对应分支，也可手动建立追踪关系：git branch --set-upstream master origin/next // 表示指定本地的master分支追踪远程的origin/next分支当建立追踪关系后：git pull origin // 表示本地的当前分支自动与origin主机上的追踪分支进行合并，如上方的会将远程next分支拉取到本地master分支上git pull // 如果当前分支只有一个追踪的分支，可以省略origin，当前分支会自动与唯一一个追踪分支进行合并良好的拉取过程：git fetch origin master:tmp // 拉取远程的master分支到本地tmp分支git diff tmp // 对比本地分支和刚从master分支上拉取下来的差异git merge tmp // 合并 git push123456789git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push // 表示将当前分支推送到origin诸暨市的对应分支（操作当前分支）git push origin master // 表示将本地的master分支推送到origin主机的master分支，如果master不存在，则会被创建（可操作当前分支，也可操作其他分支）git push -u origin master // 当前分支与多个主机存在追踪关系，使用-u指定一个默认主机，之后就可以使用git push了git push --all origin // 将本地所有分支都推送到远程主机origingit push origin :master等同于git push origin --delete master // 删除远程master分支]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM安装插件]]></title>
    <url>%2Fnode%2Fnpm%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[安装组件要添加项目到您的package.json的devDependencies：12345npm i -D ***或：npm install &lt;package_name&gt; --save -dev 要添加项目到您的package.json的dependencies：12345npm i ***或：npm install &lt;package_name&gt; --save 删除组件1cnpm uninstall *** *** --save-dev 安装自动补全厂商前缀 安装autoprefixer-loader 1cnpm i -D autoprefixer-loader 配置loader 1234&#123; test: /\.scss$/, loader: 'autoprefixer!sass'&#125;]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS，RequireJS，SeaJS 归纳笔记]]></title>
    <url>%2Fjavascript%2Fjs-module-loader.html</url>
    <content type="text"><![CDATA[文章出处 文章摘自Kaijun的博客：CommonJS,RequireJS,SeaJS归纳笔记 Foreword Here comes Module! 随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。 于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。 Catalog CommonJS &amp; Node History RequireJS &amp; AMD SeaJS &amp; CMD AMD vs CMD WebPack 123function autoDetect()&#123; console.log(&apos;ye, it is written in JavaScript!&apos;)&#125; CommonJS &amp; Node Javascript: not just for browsers any more! —— CommonJS Slogen 前端模块化的事实标准之一，2009 年 8 月，CommonJS 诞生。 CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。 让我们看看 Node 中的实现：123456789// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper// "as though the module was wrapped in a function"var a = require('./a') // 加载模块（同步加载）a.doSomething() // 等上一句执行完才会执行exports.b = function()&#123; // 暴露 b 函数接口 // do something&#125; exports是一个内置对象，就像require是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写module.exports就可以了。 CommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。 因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是： 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境） 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。 都在向着 COMMON 的方向进化：兼容不同风格，兼容浏览器和服务器两种环境 本文接下来要讨论的典例是： RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法） SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法） History 此段落参考自玉伯的 前端模块化开发那点历史 09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 Modules/1.0 规范，并且在 Node.js 等环境下取得了很不错的实践。 09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派： Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。 Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。这个稍后再细说。 Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了 补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 add和use 两个源自于 YUI Modules 的函数名替换了 define 和 require ，但其原理更接近 RequireJS ，与 YUI Modules 的 Y 沙箱 Attach 机制并不相同 RequireJS &amp; AMDAMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。 RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题： As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do? 所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来 当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容： 123456define(function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); The AMD loader will parse out the require(&#39;&#39;) calls by using Function.prototype.toString(), then internally convert the above define call into this: 123456define(['require', 'dependency1', 'dependency2'], function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); 出于Function.prototype.toString()兼容性和性能的考虑，最好的做法还是做一次 optimized build AMD 和 CommonJS 的核心争议如下： 1. 执行时机Modules/1.0: 1var a = require("./a") // 执行到此时，a.js 才同步下载并执行 AMD: （使用 require 的语法糖时） 12345define(["require"],function(require))&#123; // 在这里，a.js 已经下载并且执行好了 // 使用 require() 并不是 AMD 的推荐写法 var a = require("./a") // 此处仅仅是取模块 a 的 exports&#125;) AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的） 但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。 2. 书写风格AMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近： 12345define(["a", "b", "c"],function(a, b, c)&#123; // 提前申明了并初始化了所有模块 true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。&#125;) 不过，在笔者看来，风格喜好因人而异，主要还是预执行和懒执行的差异。 另外，require 2.0 也开始思考异步处理软依赖（区别于一定需要的硬依赖）的问题，提出了这样的方案： 123456// 函数体内：if(status)&#123; async(['a'],function(a)&#123; a.doSomething() &#125;)&#125; SeaJS &amp; CMDCMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。 不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。 CMD Specification English (CMDJS-repo) Chinese (SeaJS-repo) CMD 主要有 define, factory, require, export 这么几个东西 define define(id?, deps?, factory) factory factory(require, exports, module) require require(id) exports Object CMD 推荐的 Code Style 是使用 CommonJS 风格的 require： 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已 12345678910111213define(function(require, exports) &#123; // 获取模块 a 的接口 var a = require('./a'); // 调用模块 a 的方法 a.doSomething(); // 对外提供 foo 属性 exports.foo = 'bar'; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露 1234567891011define('hello', ['jquery'], function(require, exports, module) &#123; // 模块代码... // 直接通过 return 暴露接口 return &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。 AMD vs CMD虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同： 对于依赖的模块，AMD 是提前执行，CMD 是懒执行。（都是先加载） CMD 推崇依赖就近，AMD 推崇依赖前置。 看代码： 12345678// AMD 默认推荐define(['./a', './b'], function(a, b) &#123; // 依赖前置，提前执行 a.doSomething() b.doSomething()&#125;) 12345678910// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() var b = require('./b') // 依赖就近，延迟执行 b.doSomething()&#125;) WebPack working… 文章出处 文章摘自Kaijun的博客：CommonJS,RequireJS,SeaJS归纳笔记]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
